{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sistemas Hardware-Software \u00b6 Bem vindo ao curso de Sistemas Hardware-Software 2025/1. Professor : Fabio Lubacheski (e-mail: fabioagl@insper.edu.br ) Ninjas : Tales de Freitas Ver\u00f4nica Lima Aulas \u00b6 SEG 15:45 - 17:45 (Lab \u00c1gil 2) QUI 15:45 - 17:45 (Lab \u00c1gil 2) Atendimento: QUI 14:00 - 15:30 (Lab \u00c1gil 1) Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamento: Avalia\u00e7\u00f5es Intermedi\u00e1ria (AI) e Final (AF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os Laborat\u00f3rios ser\u00e3o disponibilizados neste site Ver crit\u00e9rios de avalia\u00e7\u00e3o na aula 01 Para consultar informa\u00e7\u00f5es detalhadas sobre a disciplina acesse o Plano de Aula","title":"Home"},{"location":"#sistemas-hardware-software","text":"Bem vindo ao curso de Sistemas Hardware-Software 2025/1. Professor : Fabio Lubacheski (e-mail: fabioagl@insper.edu.br ) Ninjas : Tales de Freitas Ver\u00f4nica Lima","title":"Sistemas Hardware-Software"},{"location":"#aulas","text":"SEG 15:45 - 17:45 (Lab \u00c1gil 2) QUI 15:45 - 17:45 (Lab \u00c1gil 2) Atendimento: QUI 14:00 - 15:30 (Lab \u00c1gil 1)","title":"Aulas"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamento: Avalia\u00e7\u00f5es Intermedi\u00e1ria (AI) e Final (AF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os Laborat\u00f3rios ser\u00e3o disponibilizados neste site Ver crit\u00e9rios de avalia\u00e7\u00e3o na aula 01 Para consultar informa\u00e7\u00f5es detalhadas sobre a disciplina acesse o Plano de Aula","title":"Avalia\u00e7\u00e3o"},{"location":"sobre/","text":"Entregas de Atividades e Labs \u00b6 Data in\u00edcio Atividade/Lab Como entregar Prazo 03/02 Instala\u00e7\u00e3o Sem entrega, apenas instale o Ubuntu 22.04! 10/02 15:45 10/02 Atv01-inteiros Github (Lembre de Criar repo e Configurar webhook ) 19/02 23h59 20/02 Atv02-intro-gdb Github 27/02 23h59 24/02 Atv03-funcoes Github 07/03 23h59 27/02 Lab01-hackerlab Github 27/03 23h59 06/03 Atv04-condicionais-funcoes Github 13/03 23h59 10/03 Atv05-loops Github 16/03 23h59 13/03 Atv06-variaveis-locais Github 20/03 23h59 17/03 Atv07-arrays Github 23/03 23h59 20/03 Atv08-malloc Github 27/03 23h59 07/04 Atv09-TAD Github 11/04 23h59 10/04 Atv10-processos Github 17/04 23h59 10/04 Lab02-processos Github 12/05 23h59 17/04 Atv11-entrada-saida Github 24/04 23h59 08/05 Atv12-threads Github 15/05 23h59 05/13 Lab03-threads Github 31/05 23h59 15/05 Atv13-barrier Github 22/05 23h59 Provas \u00b6 Multir\u00e3o C : final da primeira semana AI : 27/03 - quinta-feira - hor\u00e1rio: 16h00 \u00e0s 19:00 AF : 29/05 - quinta-feira - hor\u00e1rio: 16h00 \u00e0s 19:00 - laborat\u00f3rioo \u00c1gil I e II SUB : 09/06 - segunda-feira - hor\u00e1rio: 10h00 \u00e0s 13h00","title":"Entregas e Prazos"},{"location":"sobre/#entregas-de-atividades-e-labs","text":"Data in\u00edcio Atividade/Lab Como entregar Prazo 03/02 Instala\u00e7\u00e3o Sem entrega, apenas instale o Ubuntu 22.04! 10/02 15:45 10/02 Atv01-inteiros Github (Lembre de Criar repo e Configurar webhook ) 19/02 23h59 20/02 Atv02-intro-gdb Github 27/02 23h59 24/02 Atv03-funcoes Github 07/03 23h59 27/02 Lab01-hackerlab Github 27/03 23h59 06/03 Atv04-condicionais-funcoes Github 13/03 23h59 10/03 Atv05-loops Github 16/03 23h59 13/03 Atv06-variaveis-locais Github 20/03 23h59 17/03 Atv07-arrays Github 23/03 23h59 20/03 Atv08-malloc Github 27/03 23h59 07/04 Atv09-TAD Github 11/04 23h59 10/04 Atv10-processos Github 17/04 23h59 10/04 Lab02-processos Github 12/05 23h59 17/04 Atv11-entrada-saida Github 24/04 23h59 08/05 Atv12-threads Github 15/05 23h59 05/13 Lab03-threads Github 31/05 23h59 15/05 Atv13-barrier Github 22/05 23h59","title":"Entregas de Atividades e Labs"},{"location":"sobre/#provas","text":"Multir\u00e3o C : final da primeira semana AI : 27/03 - quinta-feira - hor\u00e1rio: 16h00 \u00e0s 19:00 AF : 29/05 - quinta-feira - hor\u00e1rio: 16h00 \u00e0s 19:00 - laborat\u00f3rioo \u00c1gil I e II SUB : 09/06 - segunda-feira - hor\u00e1rio: 10h00 \u00e0s 13h00","title":"Provas"},{"location":"aulas/01-inteiros/","text":"01 - Inteiros na CPU \u00b6 Os exerc\u00edcios da aula de hoje est\u00e3o no execut\u00e1vel bases_e_sinais . Aula com atividade para entrega! Confira em Conte\u00fados no Blackboard como criar seu reposit\u00f3rio para entregas e configurar o webhook do servidor de testes. Assim que criar seu reposit\u00f3rio, a atividade 01 j\u00e1 estar\u00e1 dispon\u00edvel nele. Configure o webhook para conseguir realizar as entregas. Atividade 01: atv01 \u00b6 Tip Leia o README dispon\u00edvel na pasta atv\\01-inteiros do seu reposit\u00f3rio de entregas! Nesta atividade, \u00e9 esperado que voc\u00ea realize diversas convers\u00f5es entre bases. O que voc\u00ea precisa fazer \u00e9: 1. Rodar programa bases_e_sinais 2. Colocar sua solu\u00e7\u00e3o em solucao.txt 3. Verificar se tudo est\u00e1 ok rodando (a saida final do programa \u00e9 Exerc\u00edcio correto! ) Ent\u00e3o, quando o execut\u00e1vel bases_e_sinais for chamado com ./bases_e_sinais < solucao.txt o esperado \u00e9 que seja obitido na sa\u00edda o texto Exerc\u00edcio correto! . Assim, tudo est\u00e1 Ok e voc\u00ea pode fazer o release! Boa atividade! Tip O README dispon\u00edvel na pasta atv\\01-inteiros tamb\u00e9m indica como realizar a entrega !","title":"01 - Inteiros na CPU"},{"location":"aulas/01-inteiros/#01-inteiros-na-cpu","text":"Os exerc\u00edcios da aula de hoje est\u00e3o no execut\u00e1vel bases_e_sinais . Aula com atividade para entrega! Confira em Conte\u00fados no Blackboard como criar seu reposit\u00f3rio para entregas e configurar o webhook do servidor de testes. Assim que criar seu reposit\u00f3rio, a atividade 01 j\u00e1 estar\u00e1 dispon\u00edvel nele. Configure o webhook para conseguir realizar as entregas.","title":"01 - Inteiros na CPU"},{"location":"aulas/01-inteiros/#atividade-01-atv01","text":"Tip Leia o README dispon\u00edvel na pasta atv\\01-inteiros do seu reposit\u00f3rio de entregas! Nesta atividade, \u00e9 esperado que voc\u00ea realize diversas convers\u00f5es entre bases. O que voc\u00ea precisa fazer \u00e9: 1. Rodar programa bases_e_sinais 2. Colocar sua solu\u00e7\u00e3o em solucao.txt 3. Verificar se tudo est\u00e1 ok rodando (a saida final do programa \u00e9 Exerc\u00edcio correto! ) Ent\u00e3o, quando o execut\u00e1vel bases_e_sinais for chamado com ./bases_e_sinais < solucao.txt o esperado \u00e9 que seja obitido na sa\u00edda o texto Exerc\u00edcio correto! . Assim, tudo est\u00e1 Ok e voc\u00ea pode fazer o release! Boa atividade! Tip O README dispon\u00edvel na pasta atv\\01-inteiros tamb\u00e9m indica como realizar a entrega !","title":"Atividade 01: atv01"},{"location":"aulas/02-ram/","text":"02 - Representa\u00e7\u00e3o de dados em RAM \u00b6 Experimentos \u00b6 Vamos trabalhar com os arquivos experimento0-4.c . Compile e execute cada um deles, execute e analise suas sa\u00eddas. Comente os resultados comparando os valores das constantes no c\u00f3digo em C e a sa\u00edda dos programas. Tente entender o que est\u00e1 acontecendo. Para compilar cada .c , utilize: $ gcc -Wall -pedantic experimento0.c -o e0 Exercise Examine o c\u00f3digo C do arquivo experimento0.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento1.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento2.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento3.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento4.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Representa\u00e7\u00e3o de struct em RAM \u00b6 A utiliza\u00e7\u00e3o de struct junta tudo que j\u00e1 vimos sobre representa\u00e7\u00e3o de todos os tipos de dados na mem\u00f3ria. N\u00e3o se esque\u00e7a de levar em conta as quest\u00f5es de alinhamento mostradas na parte expositiva da aula. Aten\u00e7\u00e3o! Voc\u00ea n\u00e3o dever\u00e1 abrir o c\u00f3digo de parte1.c . Ele est\u00e1 no reposit\u00f3rio para voc\u00ea poder conferir suas respostas. Vamos compilar?! Compile e execute parte1.c . Exercise Os endere\u00e7os mostrados na sa\u00edda de parte1 pertencem a um s\u00f3 struct declarado como struct player one . Quais s\u00e3o os tamanhos de cada campo? Dica : pode n\u00e3o ser poss\u00edvel identificar exatamente o tamanho de cada campo, mas \u00e9 esperado que voc\u00ea identifique ao menos o tamanho m\u00e1ximo de cada um. Exercise A segunda parte da sa\u00edda de parte1 mostra os endere\u00e7os de cada campo do struct. Note que &one e &one.icon s\u00e3o iguais. Voc\u00ea consegue explicar por que? Se n\u00e3o, volte na aula expositiva e reveja a parte sobre struct e alinhamento de mem\u00f3ria. Exercise Baseado nas respostas acima, declare abaixo o struct . Escreva-o da mesma maneira que usaria em um programa em C . Hora de conferir! Agora confira suas respostas no arquivo parte1.c . Examinando a execu\u00e7\u00e3o de programas usando gdb \u00b6 Podemos examinar um programa durante sua execu\u00e7\u00e3o usando o gdb . Podemos parar em qualquer instru\u00e7\u00e3o do programa, examinar conte\u00fado de registradores e da mem\u00f3ria e listar todos os s\u00edmbolos dispon\u00edveis (que podem ser fun\u00e7\u00f5es ou vari\u00e1veis globais). Dica! Para compilar um programa com suporte a debugging usamos a flag -g do gcc $ gcc -g -Wall -pedantic parte2.c -o parte2 Siga os passos para para carregar um programa usando o gdb : Lance o gdb e passe para ele seu programa: $ gdb ./parte2 Para sair, utilize: (gdb) quit Tip O gdb \u00e9 uma ferramenta poderosa que possui muitas op\u00e7\u00f5es. Sua documenta\u00e7\u00e3o est\u00e1 online e pode ser acessada em: https://sourceware.org/gdb/onlinedocs/gdb/index.html#Top . Uma explica\u00e7\u00e3o detalhadas dos comandos do gdb pode ser encontrada nesse link: https://diveintosystems.org/book/C3-C_debug/gdb_commands.html . Nesta primeira parte iremos abrir o arquivo parte2.c e olhar seu conte\u00fado. Tamb\u00e9m executaremos o programa compilado parte2 . Exercise Abra o c\u00f3digo parte2.c e liste os nomes das vari\u00e1veis globais declaradas e seus tamanhos. Anote tamb\u00e9m as fun\u00e7\u00f5es declaradas. Aten\u00e7\u00e3o, tarefa dupla! Para os pr\u00f3ximos exerc\u00edcios, compile o arquivo parte2.c com e sem debugging e repita cada exerc\u00edcio com ambas as vers\u00f5es do execut\u00e1vel. Exemplo de compila\u00e7\u00e3o: $ gcc -g -Wall -pedantic parte2.c -o parte2_debug $ gcc -Wall -pedantic parte2.c -o parte2_semdebug Exercise O comando info mostra informa\u00e7\u00f5es que podem ser obtidas a partir de um execut\u00e1vel. Execute-o e veja o que acontece. Exercise Use info para mostrar as fun\u00e7\u00f5es e vari\u00e1veis globais que existem em parte2 . Lembre de fazer tanto na vers\u00e3o com quanto na sem debugging ! Muita informa\u00e7\u00e3o! Muitos nomes s\u00e3o estranhos. Eles fazem parte do padr\u00e3o de arquivos execut\u00e1veis ELF , que cont\u00e9m informa\u00e7\u00f5es espec\u00edficas do sistema operacional usado. Voc\u00ea n\u00e3o precisa se preocupar com estes nomes. Exercise Qual \u00e9 o significado da primeira coluna do comando info variables ? Dica : o valor est\u00e1 em hexadecimal, que usamos na expositiva para mostrar ponteiros. Exercise Podemos usar o comando print para mostrar o valor inicial das vari\u00e1veis globais identificadas. Mostre o valor inicial de global_var usando este comando e compare com o visto no arquivo parte2.c . Dicas: Pode n\u00e3o funcionar de primeira. O qu\u00ea a mensagem de erro diz? A sintaxe de convers\u00e3o de tipos de C ( casting ) pode ser \u00fatil aqui. Exercise Podemos usar o gdb tamb\u00e9m para examinar a mem\u00f3ria de um execut\u00e1vel. Acesse esta p\u00e1gina da documenta\u00e7\u00e3o , entenda como usar o comando x e escreva abaixo qual o comando usado para mostrar o conte\u00fado do segundo item do vetor global_array . Em seguida, teste-o e garanta que funcionou corretamente. Link: https://sourceware.org/gdb/onlinedocs/gdb/Memory.html Dicas : volte nos exerc\u00edcios anteriores e encontre o endere\u00e7o do in\u00edcio do vetor calcule o endere\u00e7o do segundo elemento manualmente e passe para o comando x n\u00e3o se esque\u00e7a de buscar na mem\u00f3ria o tamanho correto do elemento Exercise global_array tem tipo short . Ou seja, \u00e9 formado por dois bytes. Mostre agora o conte\u00fado de cada um deles. Ou seja, voc\u00ea dever\u00e1 dar dois comandos para examinar a mem\u00f3ria. Explique como converter esses dois bytes para o valor mostrado no exerc\u00edcio anterior. Exercise Use agora o comando x para exibir global_str como uma string . Escreva o comando abaixo.","title":"02 - Representa\u00e7\u00e3o de dados em RAM"},{"location":"aulas/02-ram/#02-representacao-de-dados-em-ram","text":"","title":"02 - Representa\u00e7\u00e3o de dados em RAM"},{"location":"aulas/02-ram/#experimentos","text":"Vamos trabalhar com os arquivos experimento0-4.c . Compile e execute cada um deles, execute e analise suas sa\u00eddas. Comente os resultados comparando os valores das constantes no c\u00f3digo em C e a sa\u00edda dos programas. Tente entender o que est\u00e1 acontecendo. Para compilar cada .c , utilize: $ gcc -Wall -pedantic experimento0.c -o e0 Exercise Examine o c\u00f3digo C do arquivo experimento0.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento1.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento2.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento3.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento4.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa.","title":"Experimentos"},{"location":"aulas/02-ram/#representacao-de-struct-em-ram","text":"A utiliza\u00e7\u00e3o de struct junta tudo que j\u00e1 vimos sobre representa\u00e7\u00e3o de todos os tipos de dados na mem\u00f3ria. N\u00e3o se esque\u00e7a de levar em conta as quest\u00f5es de alinhamento mostradas na parte expositiva da aula. Aten\u00e7\u00e3o! Voc\u00ea n\u00e3o dever\u00e1 abrir o c\u00f3digo de parte1.c . Ele est\u00e1 no reposit\u00f3rio para voc\u00ea poder conferir suas respostas. Vamos compilar?! Compile e execute parte1.c . Exercise Os endere\u00e7os mostrados na sa\u00edda de parte1 pertencem a um s\u00f3 struct declarado como struct player one . Quais s\u00e3o os tamanhos de cada campo? Dica : pode n\u00e3o ser poss\u00edvel identificar exatamente o tamanho de cada campo, mas \u00e9 esperado que voc\u00ea identifique ao menos o tamanho m\u00e1ximo de cada um. Exercise A segunda parte da sa\u00edda de parte1 mostra os endere\u00e7os de cada campo do struct. Note que &one e &one.icon s\u00e3o iguais. Voc\u00ea consegue explicar por que? Se n\u00e3o, volte na aula expositiva e reveja a parte sobre struct e alinhamento de mem\u00f3ria. Exercise Baseado nas respostas acima, declare abaixo o struct . Escreva-o da mesma maneira que usaria em um programa em C . Hora de conferir! Agora confira suas respostas no arquivo parte1.c .","title":"Representa\u00e7\u00e3o de struct em RAM"},{"location":"aulas/02-ram/#examinando-a-execucao-de-programas-usando-gdb","text":"Podemos examinar um programa durante sua execu\u00e7\u00e3o usando o gdb . Podemos parar em qualquer instru\u00e7\u00e3o do programa, examinar conte\u00fado de registradores e da mem\u00f3ria e listar todos os s\u00edmbolos dispon\u00edveis (que podem ser fun\u00e7\u00f5es ou vari\u00e1veis globais). Dica! Para compilar um programa com suporte a debugging usamos a flag -g do gcc $ gcc -g -Wall -pedantic parte2.c -o parte2 Siga os passos para para carregar um programa usando o gdb : Lance o gdb e passe para ele seu programa: $ gdb ./parte2 Para sair, utilize: (gdb) quit Tip O gdb \u00e9 uma ferramenta poderosa que possui muitas op\u00e7\u00f5es. Sua documenta\u00e7\u00e3o est\u00e1 online e pode ser acessada em: https://sourceware.org/gdb/onlinedocs/gdb/index.html#Top . Uma explica\u00e7\u00e3o detalhadas dos comandos do gdb pode ser encontrada nesse link: https://diveintosystems.org/book/C3-C_debug/gdb_commands.html . Nesta primeira parte iremos abrir o arquivo parte2.c e olhar seu conte\u00fado. Tamb\u00e9m executaremos o programa compilado parte2 . Exercise Abra o c\u00f3digo parte2.c e liste os nomes das vari\u00e1veis globais declaradas e seus tamanhos. Anote tamb\u00e9m as fun\u00e7\u00f5es declaradas. Aten\u00e7\u00e3o, tarefa dupla! Para os pr\u00f3ximos exerc\u00edcios, compile o arquivo parte2.c com e sem debugging e repita cada exerc\u00edcio com ambas as vers\u00f5es do execut\u00e1vel. Exemplo de compila\u00e7\u00e3o: $ gcc -g -Wall -pedantic parte2.c -o parte2_debug $ gcc -Wall -pedantic parte2.c -o parte2_semdebug Exercise O comando info mostra informa\u00e7\u00f5es que podem ser obtidas a partir de um execut\u00e1vel. Execute-o e veja o que acontece. Exercise Use info para mostrar as fun\u00e7\u00f5es e vari\u00e1veis globais que existem em parte2 . Lembre de fazer tanto na vers\u00e3o com quanto na sem debugging ! Muita informa\u00e7\u00e3o! Muitos nomes s\u00e3o estranhos. Eles fazem parte do padr\u00e3o de arquivos execut\u00e1veis ELF , que cont\u00e9m informa\u00e7\u00f5es espec\u00edficas do sistema operacional usado. Voc\u00ea n\u00e3o precisa se preocupar com estes nomes. Exercise Qual \u00e9 o significado da primeira coluna do comando info variables ? Dica : o valor est\u00e1 em hexadecimal, que usamos na expositiva para mostrar ponteiros. Exercise Podemos usar o comando print para mostrar o valor inicial das vari\u00e1veis globais identificadas. Mostre o valor inicial de global_var usando este comando e compare com o visto no arquivo parte2.c . Dicas: Pode n\u00e3o funcionar de primeira. O qu\u00ea a mensagem de erro diz? A sintaxe de convers\u00e3o de tipos de C ( casting ) pode ser \u00fatil aqui. Exercise Podemos usar o gdb tamb\u00e9m para examinar a mem\u00f3ria de um execut\u00e1vel. Acesse esta p\u00e1gina da documenta\u00e7\u00e3o , entenda como usar o comando x e escreva abaixo qual o comando usado para mostrar o conte\u00fado do segundo item do vetor global_array . Em seguida, teste-o e garanta que funcionou corretamente. Link: https://sourceware.org/gdb/onlinedocs/gdb/Memory.html Dicas : volte nos exerc\u00edcios anteriores e encontre o endere\u00e7o do in\u00edcio do vetor calcule o endere\u00e7o do segundo elemento manualmente e passe para o comando x n\u00e3o se esque\u00e7a de buscar na mem\u00f3ria o tamanho correto do elemento Exercise global_array tem tipo short . Ou seja, \u00e9 formado por dois bytes. Mostre agora o conte\u00fado de cada um deles. Ou seja, voc\u00ea dever\u00e1 dar dois comandos para examinar a mem\u00f3ria. Explique como converter esses dois bytes para o valor mostrado no exerc\u00edcio anterior. Exercise Use agora o comando x para exibir global_str como uma string . Escreva o comando abaixo.","title":"Examinando a execu\u00e7\u00e3o de programas usando gdb"},{"location":"aulas/03-arquitetura-x86/","text":"03 - Arquitetura x86-64 \u00b6 No handout passado usamos o gdb para listar vari\u00e1veis globais, nomes de fun\u00e7\u00f5es e examinar endere\u00e7os de mem\u00f3ria. Neste handout vamos come\u00e7ar a usar o gdb tamb\u00e9m para examinar nossos programas durante sua execu\u00e7\u00e3o . Parando e continuando a execu\u00e7\u00e3o de um programa. \u00b6 Compile funcoes.c usando as flags: $ gcc -Og -g -Wall -std = c99 funcoes.c -o funcoes Tip Na compila\u00e7\u00e3o, -Og ir\u00e1 permitir otimiza\u00e7\u00f5es de c\u00f3digo que n\u00e3o interfiram no debugging. J\u00e1 o par\u00e2metro -g ir\u00e1 tornar dispon\u00edveis informa\u00e7\u00f5es \u00fateis para o debugging (como tipos de vari\u00e1veis e cabe\u00e7alhos das fun\u00e7\u00f5es) Exercise Abra o execut\u00e1vel com o gdb e liste suas fun\u00e7\u00f5es e suas vari\u00e1veis globais. N\u00e3o rode o programa ainda! Anote abaixo seus endere\u00e7os e nomes. Exercise O comando disas \u00e9 usado para mostrar as instru\u00e7\u00f5es de m\u00e1quina de uma fun\u00e7\u00e3o. Use-o para ver o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao1 . Liste abaixo quais registradores foram usados nesta fun\u00e7\u00e3o e qual o tamanho dos dados guardados neles. Exercise Com base nos tamanhos identificados, voc\u00ea consegue associar os registradores acima com as vari\u00e1veis no c\u00f3digo de funcao1 ? Exercise Use o comando break funcao1 para parar a execu\u00e7\u00e3o do programa quando a fun\u00e7\u00e3o funcao1 come\u00e7ar a executar. Execute o programa usando run . O qu\u00ea ocorre? Ap\u00f3s executar o run , utilize disas funcao1 e observe no c\u00f3digo da fun\u00e7\u00e3o uma seta indicando o pr\u00f3ximo comando a ser executado, que representa o breakpoint no in\u00edcio da fun\u00e7\u00e3o. Dica Os comandos info breakpoints , info b ou ainda i b podem ser utilizados para listar os breakpoints inseridos no c\u00f3digo! Exercise Podemos usar o comando info registers edi para ver o conte\u00fado atual do registrador %edi . Qual \u00e9 este valor? Verifique quais argumentos s\u00e3o passados para funcao1 no c\u00f3digo C e, com estas informa\u00e7\u00f5es em m\u00e3os, verifique sua resposta do Exerc\u00edcio 2 e escreva abaixo suas novas conclus\u00f5es. Exercise O comando stepi executa exatamente uma instru\u00e7\u00e3o de m\u00e1quina. Use-o uma vez e execute novamente disas funcao1 . O que aconteceu? \u00c9 poss\u00edvel saber em qual instru\u00e7\u00e3o o programa est\u00e1 parado? Dicas : se a primeira instru\u00e7\u00e3o for endbr64 , execute stepi mais uma vez! use disas de novo verifique novamente o conte\u00fado de %edi Exercise Cheque novamente o valor de %edi . Este valor condiz com a instru\u00e7\u00e3o executada? O que ela faz, exatamente? Exercise Use stepi para parar logo antes do retorno da fun\u00e7\u00e3o. Verifique o conte\u00fado do registrador %eax e compare-o com os prints feitos pelo program. Voc\u00ea consegue dizer seu uso? Exercise Vamos agora analisar o registrador %rsi . Toda vez que um registrador aparece entre ( ) estamos fazendo um acesso a mem\u00f3ria. Ao mostrar seu conte\u00fado usando info registers rsi recebemos o endere\u00e7o de mem\u00f3ria que cont\u00e9m o dado que queremos acessar. Exercise Use o comando x para mostrar, em decimal, o int que est\u00e1 armazenado no endere\u00e7o descoberto no exerc\u00edcio anterior. Confira seu resultado com o c\u00f3digo. Tip Execute o comando continue para continuar rodando o programa. Ele ir\u00e1 rodar at\u00e9 que o pr\u00f3ximo breakpoint seja alcan\u00e7ado ou at\u00e9 que o programa termine. Endere\u00e7amento relativo e vari\u00e1veis globais \u00b6 Na parte anterior analisamos o c\u00f3digo Assembly de nossa primeira fun\u00e7\u00e3o e vimos como mostrar o c\u00f3digo fonte de uma fun\u00e7\u00e3o usando disas mostrar o conte\u00fado de um registrador usando info registers executar exatamente uma instru\u00e7\u00e3o usando stepi Tamb\u00e9m vimos que ao colocar um registrador entre ( ) estamos fazendo um acesso a mem\u00f3ria. Esta opera\u00e7\u00e3o \u00e9 equivalente a desreferenciar um ponteiro usando *p . Neste roteiro iremos adicionar um detalhe importante: podemos fazer contas com endere\u00e7os usando esta nota\u00e7\u00e3o. Nos exemplo abaixo nos referimos a mem\u00f3ria como um grande vetor de bytes unsigned char M[] . Ou seja, ao acessar M[%rax] , por exemplo, estamos acessando o lugar na mem\u00f3ria cujo endere\u00e7o est\u00e1 escrito em %rax . 10(%rax) : acessa a mem\u00f3ria M[%rax + 10] . (%rax, %rdi, 4) : acessa a mem\u00f3ria M[%rax + 4 * % rdi] . Note que isto se parece com aritm\u00e9tica de ponteiros cujo tipo apontado seja inteiro, pois os endere\u00e7os pulam de 4 em 4 bytes. Exercise Saia e abra o gdb novamente. Mostre o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao2 e coloque um breakpoint em sua primeira instru\u00e7\u00e3o. Exercise Execute agora o programa. A execu\u00e7\u00e3o deve ter parado no in\u00edcio de funcao2 . Rode disas funcao2 . Exercise Voc\u00ea consegue identificar acessos a mem\u00f3ria em funcao2 ? Quais s\u00e3o de leitura e quais s\u00e3o de escrita? Qual o tamanho dos dados lidos/escritos? Exercise Qual o significado do registrador %rip ? Se n\u00e3o se lembrar reveja os slides. O tipo de acesso a mem\u00f3ria que estamos realizando se chama rip relative addressing . Este tipo de acesso \u00e9 reservado para vari\u00e1veis globais e dados somente leitura. Estes dados tem uma caracter\u00edstica especial: eles s\u00e3o copiados para a mem\u00f3ria seguindo o mesmo layout do arquivo execut\u00e1vel. Ou seja, as posi\u00e7\u00f5es relativas entre o c\u00f3digo e os dados globais s\u00e3o fixas. Exercise Anote abaixo o endere\u00e7o das fun\u00e7\u00f5es MOV que utilizam este acesso. Baseado nos exemplos acima, descubra o endere\u00e7o das vari\u00e1veis acessadas. Desenho de acesso a mem\u00f3ria usando %rip A figura abaixo ilustra como funciona o endere\u00e7amento usando o registrador %rip . Note que os deslocamentos s\u00e3o diferentes pois o endere\u00e7o da instru\u00e7\u00e3o atual \u00e9 diferente. Por\u00e9m, o resultado final do endere\u00e7o calculado em ambas instru\u00e7\u00f5es \u00e9 o mesmo, indicando que ambas se referem ao mesmo local na mem\u00f3ria. Exercise Confira se o valor identificado na quest\u00e3o anterior \u00e9 o mesmo mostrado a direita das instru\u00e7\u00f5es MOV na sa\u00edda do disas . O gdb j\u00e1 calcula este endere\u00e7o para facilitar nossa vida, mas \u00e9 interessante calcular isto manualmente uma vez para entender melhor o processo. Exercise Use o comando continue para continuar o programa. Voc\u00ea deve estar agora na segunda execu\u00e7\u00e3o de funcao2 . Use o comando x para mostrar o valor armazenado na mem\u00f3ria calculada acima. Lendo o c\u00f3digo do programa, voc\u00ea consegue dizer qual vari\u00e1vel \u00e9 armazenada neste endere\u00e7o? O valor atual \u00e9 o esperado para a segunda execu\u00e7\u00e3o de funcao2 ? Al\u00e9m de poder mostrar valores na mem\u00f3ria podemos escrever valores tamb\u00e9m. A sintaxe usada \u00e9 a seguinte: set *( (tipo *) 0x.....) = valor onde devemos substituir tipo por um tipo b\u00e1sico de C , 0x... pelo endere\u00e7o desejado e valor pelo valor que queremos escrever. Note que o que estamos fazendo \u00e9 um cast do endere\u00e7o 0x.... para um ponteiro de tipo e depois estamos acessando o valor apontado usando * ! Exercise Escreva o valor -10 na mem\u00f3ria da vari\u00e1vel global usada em funcao2 . Rode o programa at\u00e9 o fim. O resultado foi o esperado? Escreva abaixo os comandos utilizados. Desafio Localize na fun\u00e7\u00e3o main as chamadas ao comando printf , analise as chamadas para responder o pr\u00f3ximo exerc\u00edcio! Exercise Encontre os endere\u00e7o das strings de formata\u00e7\u00e3o do printf e use o comando x para mostr\u00e1-las no gdb. Escreva os comandos usados abaixo. Atividade para entrega! \u00b6 Aula com atividade para entrega . Confira seu reposit\u00f3rio de entregas do classroom! Aten\u00e7\u00e3o Fa\u00e7a git pull no seu reposit\u00f3rio de entregas que ir\u00e1 aparecer uma nova pasta dentro de atv . Dica Leia o README.md dispon\u00edvel na pasta da atividade para descobrir como resolver e entregar.","title":"03 - Arquitetura x86-64"},{"location":"aulas/03-arquitetura-x86/#03-arquitetura-x86-64","text":"No handout passado usamos o gdb para listar vari\u00e1veis globais, nomes de fun\u00e7\u00f5es e examinar endere\u00e7os de mem\u00f3ria. Neste handout vamos come\u00e7ar a usar o gdb tamb\u00e9m para examinar nossos programas durante sua execu\u00e7\u00e3o .","title":"03 - Arquitetura x86-64"},{"location":"aulas/03-arquitetura-x86/#parando-e-continuando-a-execucao-de-um-programa","text":"Compile funcoes.c usando as flags: $ gcc -Og -g -Wall -std = c99 funcoes.c -o funcoes Tip Na compila\u00e7\u00e3o, -Og ir\u00e1 permitir otimiza\u00e7\u00f5es de c\u00f3digo que n\u00e3o interfiram no debugging. J\u00e1 o par\u00e2metro -g ir\u00e1 tornar dispon\u00edveis informa\u00e7\u00f5es \u00fateis para o debugging (como tipos de vari\u00e1veis e cabe\u00e7alhos das fun\u00e7\u00f5es) Exercise Abra o execut\u00e1vel com o gdb e liste suas fun\u00e7\u00f5es e suas vari\u00e1veis globais. N\u00e3o rode o programa ainda! Anote abaixo seus endere\u00e7os e nomes. Exercise O comando disas \u00e9 usado para mostrar as instru\u00e7\u00f5es de m\u00e1quina de uma fun\u00e7\u00e3o. Use-o para ver o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao1 . Liste abaixo quais registradores foram usados nesta fun\u00e7\u00e3o e qual o tamanho dos dados guardados neles. Exercise Com base nos tamanhos identificados, voc\u00ea consegue associar os registradores acima com as vari\u00e1veis no c\u00f3digo de funcao1 ? Exercise Use o comando break funcao1 para parar a execu\u00e7\u00e3o do programa quando a fun\u00e7\u00e3o funcao1 come\u00e7ar a executar. Execute o programa usando run . O qu\u00ea ocorre? Ap\u00f3s executar o run , utilize disas funcao1 e observe no c\u00f3digo da fun\u00e7\u00e3o uma seta indicando o pr\u00f3ximo comando a ser executado, que representa o breakpoint no in\u00edcio da fun\u00e7\u00e3o. Dica Os comandos info breakpoints , info b ou ainda i b podem ser utilizados para listar os breakpoints inseridos no c\u00f3digo! Exercise Podemos usar o comando info registers edi para ver o conte\u00fado atual do registrador %edi . Qual \u00e9 este valor? Verifique quais argumentos s\u00e3o passados para funcao1 no c\u00f3digo C e, com estas informa\u00e7\u00f5es em m\u00e3os, verifique sua resposta do Exerc\u00edcio 2 e escreva abaixo suas novas conclus\u00f5es. Exercise O comando stepi executa exatamente uma instru\u00e7\u00e3o de m\u00e1quina. Use-o uma vez e execute novamente disas funcao1 . O que aconteceu? \u00c9 poss\u00edvel saber em qual instru\u00e7\u00e3o o programa est\u00e1 parado? Dicas : se a primeira instru\u00e7\u00e3o for endbr64 , execute stepi mais uma vez! use disas de novo verifique novamente o conte\u00fado de %edi Exercise Cheque novamente o valor de %edi . Este valor condiz com a instru\u00e7\u00e3o executada? O que ela faz, exatamente? Exercise Use stepi para parar logo antes do retorno da fun\u00e7\u00e3o. Verifique o conte\u00fado do registrador %eax e compare-o com os prints feitos pelo program. Voc\u00ea consegue dizer seu uso? Exercise Vamos agora analisar o registrador %rsi . Toda vez que um registrador aparece entre ( ) estamos fazendo um acesso a mem\u00f3ria. Ao mostrar seu conte\u00fado usando info registers rsi recebemos o endere\u00e7o de mem\u00f3ria que cont\u00e9m o dado que queremos acessar. Exercise Use o comando x para mostrar, em decimal, o int que est\u00e1 armazenado no endere\u00e7o descoberto no exerc\u00edcio anterior. Confira seu resultado com o c\u00f3digo. Tip Execute o comando continue para continuar rodando o programa. Ele ir\u00e1 rodar at\u00e9 que o pr\u00f3ximo breakpoint seja alcan\u00e7ado ou at\u00e9 que o programa termine.","title":"Parando e continuando a execu\u00e7\u00e3o de um programa."},{"location":"aulas/03-arquitetura-x86/#enderecamento-relativo-e-variaveis-globais","text":"Na parte anterior analisamos o c\u00f3digo Assembly de nossa primeira fun\u00e7\u00e3o e vimos como mostrar o c\u00f3digo fonte de uma fun\u00e7\u00e3o usando disas mostrar o conte\u00fado de um registrador usando info registers executar exatamente uma instru\u00e7\u00e3o usando stepi Tamb\u00e9m vimos que ao colocar um registrador entre ( ) estamos fazendo um acesso a mem\u00f3ria. Esta opera\u00e7\u00e3o \u00e9 equivalente a desreferenciar um ponteiro usando *p . Neste roteiro iremos adicionar um detalhe importante: podemos fazer contas com endere\u00e7os usando esta nota\u00e7\u00e3o. Nos exemplo abaixo nos referimos a mem\u00f3ria como um grande vetor de bytes unsigned char M[] . Ou seja, ao acessar M[%rax] , por exemplo, estamos acessando o lugar na mem\u00f3ria cujo endere\u00e7o est\u00e1 escrito em %rax . 10(%rax) : acessa a mem\u00f3ria M[%rax + 10] . (%rax, %rdi, 4) : acessa a mem\u00f3ria M[%rax + 4 * % rdi] . Note que isto se parece com aritm\u00e9tica de ponteiros cujo tipo apontado seja inteiro, pois os endere\u00e7os pulam de 4 em 4 bytes. Exercise Saia e abra o gdb novamente. Mostre o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao2 e coloque um breakpoint em sua primeira instru\u00e7\u00e3o. Exercise Execute agora o programa. A execu\u00e7\u00e3o deve ter parado no in\u00edcio de funcao2 . Rode disas funcao2 . Exercise Voc\u00ea consegue identificar acessos a mem\u00f3ria em funcao2 ? Quais s\u00e3o de leitura e quais s\u00e3o de escrita? Qual o tamanho dos dados lidos/escritos? Exercise Qual o significado do registrador %rip ? Se n\u00e3o se lembrar reveja os slides. O tipo de acesso a mem\u00f3ria que estamos realizando se chama rip relative addressing . Este tipo de acesso \u00e9 reservado para vari\u00e1veis globais e dados somente leitura. Estes dados tem uma caracter\u00edstica especial: eles s\u00e3o copiados para a mem\u00f3ria seguindo o mesmo layout do arquivo execut\u00e1vel. Ou seja, as posi\u00e7\u00f5es relativas entre o c\u00f3digo e os dados globais s\u00e3o fixas. Exercise Anote abaixo o endere\u00e7o das fun\u00e7\u00f5es MOV que utilizam este acesso. Baseado nos exemplos acima, descubra o endere\u00e7o das vari\u00e1veis acessadas. Desenho de acesso a mem\u00f3ria usando %rip A figura abaixo ilustra como funciona o endere\u00e7amento usando o registrador %rip . Note que os deslocamentos s\u00e3o diferentes pois o endere\u00e7o da instru\u00e7\u00e3o atual \u00e9 diferente. Por\u00e9m, o resultado final do endere\u00e7o calculado em ambas instru\u00e7\u00f5es \u00e9 o mesmo, indicando que ambas se referem ao mesmo local na mem\u00f3ria. Exercise Confira se o valor identificado na quest\u00e3o anterior \u00e9 o mesmo mostrado a direita das instru\u00e7\u00f5es MOV na sa\u00edda do disas . O gdb j\u00e1 calcula este endere\u00e7o para facilitar nossa vida, mas \u00e9 interessante calcular isto manualmente uma vez para entender melhor o processo. Exercise Use o comando continue para continuar o programa. Voc\u00ea deve estar agora na segunda execu\u00e7\u00e3o de funcao2 . Use o comando x para mostrar o valor armazenado na mem\u00f3ria calculada acima. Lendo o c\u00f3digo do programa, voc\u00ea consegue dizer qual vari\u00e1vel \u00e9 armazenada neste endere\u00e7o? O valor atual \u00e9 o esperado para a segunda execu\u00e7\u00e3o de funcao2 ? Al\u00e9m de poder mostrar valores na mem\u00f3ria podemos escrever valores tamb\u00e9m. A sintaxe usada \u00e9 a seguinte: set *( (tipo *) 0x.....) = valor onde devemos substituir tipo por um tipo b\u00e1sico de C , 0x... pelo endere\u00e7o desejado e valor pelo valor que queremos escrever. Note que o que estamos fazendo \u00e9 um cast do endere\u00e7o 0x.... para um ponteiro de tipo e depois estamos acessando o valor apontado usando * ! Exercise Escreva o valor -10 na mem\u00f3ria da vari\u00e1vel global usada em funcao2 . Rode o programa at\u00e9 o fim. O resultado foi o esperado? Escreva abaixo os comandos utilizados. Desafio Localize na fun\u00e7\u00e3o main as chamadas ao comando printf , analise as chamadas para responder o pr\u00f3ximo exerc\u00edcio! Exercise Encontre os endere\u00e7o das strings de formata\u00e7\u00e3o do printf e use o comando x para mostr\u00e1-las no gdb. Escreva os comandos usados abaixo.","title":"Endere\u00e7amento relativo e vari\u00e1veis globais"},{"location":"aulas/03-arquitetura-x86/#atividade-para-entrega","text":"Aula com atividade para entrega . Confira seu reposit\u00f3rio de entregas do classroom! Aten\u00e7\u00e3o Fa\u00e7a git pull no seu reposit\u00f3rio de entregas que ir\u00e1 aparecer uma nova pasta dentro de atv . Dica Leia o README.md dispon\u00edvel na pasta da atividade para descobrir como resolver e entregar.","title":"Atividade para entrega!"},{"location":"aulas/04-funcoes-mov/","text":"04 - Fun\u00e7\u00f5es \u00b6 Neste handout vamos trabalhar pela primeira vez na tradu\u00e7\u00e3o reversa de programas em Assembly para C . Nas \u00faltimas aulas vimos as instru\u00e7\u00f5es mov e add e na aula de hoje vimos uma tabela grande com as instru\u00e7\u00f5es aritm\u00e9ticas ( add , sub , mul , imul , div , etc). Como em todas as aulas, veremos hoje um detalhe a mais sobre arquitetura x64 : chamadas de fun\u00e7\u00f5es e argumentos. Fun\u00e7\u00f5es e seus argumentos \u00b6 Em x64 os argumentos das fun\u00e7\u00f5es s\u00e3o passados nos registradores e o valor de retorno \u00e9 colocado tamb\u00e9m em um registrador. Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores ( nesta ordem ): %rdi %rsi %rdx %rcx %r8 %r9 Argumentos ponto flutuante s\u00e3o passados nos registradores %xmm0 at\u00e9 %xmm7 . Valores de retorno inteiros ou ponteiros s\u00e3o colocados no registrador %rax . Valores de retorno ponto flutuante s\u00e3o colocados no registrador %xmm0 . Para chamar fun\u00e7\u00f5es usamos a instru\u00e7\u00e3o call seguido do endere\u00e7o de mem\u00f3ria da fun\u00e7\u00e3o. O gdb cria um \"apelido\" para estes endere\u00e7os de mem\u00f3ria usando o nome original da fun\u00e7\u00e3o no arquivo .c . Assim, estas instru\u00e7\u00f5es s\u00e3o mostradas, normalmente, como call func1 , por exemplo. Note que antes de cada call devemos preencher os argumentos nos registradores corretos. Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax (ou %xmm0 para ponto flutuante). N\u00e3o se esque\u00e7a da equival\u00eancia entre o tamanhos dos registradores e os tipos inteiros em C . Um resumo gr\u00e1fico pode ser visto nas figuras acima. 64 bits ( %rax , %rdi e outros que come\u00e7am com r ): long , unsigned long ou ponteiro; 32 bits ( %eax , %edi e outros que come\u00e7a com e e os que terminam em d como r10d ): int ou unsigned int ; 16 bits ( %ax , %di e outros com duas letras somente terminando em x ): short ou unsigned short 8 bits ( %al , %ah e outros com duas letras terminando em h ou l ): char ou unsigned char . Vamos agora praticar fazendo a tradu\u00e7\u00e3o de fun\u00e7\u00f5es que fazem aritm\u00e9tica simples entre inteiros (usando ou n\u00e3o ponteiros). O exemplo abaixo mostra todas as etapas que precisamos seguir para fazer a tradu\u00e7\u00e3o Assembly -> C. Exemplo guiado \u00b6 Dado o c\u00f3digo Assembly abaixo, fa\u00e7a sua tradu\u00e7\u00e3o para C 0000000000000000 <misterio1>: 0: 48 01 f7 add %rsi,%rdi 3: 48 8d 04 57 lea (%rdi,%rdx,2),%rax 7: c3 retq Assinatura da fun\u00e7\u00e3o \u00b6 Vamos come\u00e7ar pela assinatura da fun\u00e7\u00e3o. \u00c9 sempre \u00fatil identificar quais registradores s\u00e3o lidos antes de serem escritos. Isso nos ajuda a entender se um registrador \u00e9 um argumento da fun\u00e7\u00e3o ou se ele \u00e9 apenas usado como vari\u00e1vel local. Faremos isso escrevendo todos os registradores que podem ser argumentos em ordem e vendo se s\u00e3o lidos ou escritos primeiro: %rdi - lido primeiro ( add faz a opera\u00e7\u00e3o += ) %rsi - lido primeiro (no lado esquerdo do add ) %rdx - lido primeiro (no lado esquerdo do lea ) %rcx - n\u00e3o usado %r8 - n\u00e3o usado %r9 - n\u00e3o usado Logo, os registradores %rdi , %rsi e %rdx s\u00e3o argumentos da fun\u00e7\u00e3o. Consultando o box de arquitetura de computadores, vemos que a fun\u00e7\u00e3o recebe tr\u00eas argumentos do tipo long (pois usa os registradores de 64 bits). Note que o resultado das computa\u00e7\u00f5es \u00e9 guardado em %rax , que guarda sempre o retorno da fun\u00e7\u00e3o. Por usar a por\u00e7\u00e3o de 64 bits do registrador, o tipo de retorno tamb\u00e9m \u00e9 long . A assinatura da fun\u00e7\u00e3o \u00e9, portanto long misterio1(long a, long b, long c); Tip Ponteiros tamb\u00e9m usam os registradores de 64 bits. Por\u00e9m, olhando rapidamente o c\u00f3digo notamos que n\u00e3o h\u00e1 nenhum acesso a mem\u00f3ria. Logo, se trata realmente de long . O c\u00f3digo \u00b6 Vamos agora para o c\u00f3digo. Nossa primeira estrat\u00e9gia \u00e9 atribuir um nome para cada registrador. Os tr\u00eas registradores de argumentos j\u00e1 receberam os nomes a , b e c . Para deixar expl\u00edcito o papel do %rax vamos nome\u00e1-lo de retval . A primeira instru\u00e7\u00e3o add %rsi, %rdi realiza a adi\u00e7\u00e3o dos dois registradores e armazena em %rdi . Logo, sua tradu\u00e7\u00e3o direta seria: a += b ; A instru\u00e7\u00e3o lea (%rdi, %rdx, 2), %rax \u00e9 usada tanto para calcular endere\u00e7os de mem\u00f3ria quanto para aritm\u00e9tica simples. Vemos que \u00e9 o segundo caso pois, no c\u00f3digo seguinte, n\u00e3o acessamos a mem\u00f3ria com o valor calculado. Logo, podemos traduzir este trecho como retval = a + 2 * c ; Logo ap\u00f3s temos o ret , que \u00e9 traduzido como return retval ; Logo, nossa fun\u00e7\u00e3o \u00e9 traduzida como long misterio1 ( long a , long b , long c ){ long retval ; a += b ; retval = a + 2 * c ; return retval ; } Finalmente, podemos deixar nosso c\u00f3digo leg\u00edvel e escrev\u00ea-lo como long misterio1 ( long a , long b , long c ){ return a + b + 2 * c ; } Voc\u00ea pode verificar o c\u00f3digo original no arquivo exemplo1.c . O processo acima pode ser formalizado no seguinte algoritmo: Identifique quantos argumentos a fun\u00e7\u00e3o recebe Identifique os tipos de cada argumento (pode ser necess\u00e1rio olhar o c\u00f3digo assembly da fun\u00e7\u00e3o) D\u00ea um nome para cada registrador. Se um mesmo registrador \u00e9 usado com tamanhos diferentes ( %rdi e %edi s\u00e3o usados no c\u00f3digo), d\u00ea um nome diferente para cada tamanho. Fa\u00e7a a tradu\u00e7\u00e3o de cada instru\u00e7\u00e3o separadamente. Fique atento aos valores colocados em %rax e %eax perto do fim do c\u00f3digo. Esses valores ser\u00e3o retornados pela fun\u00e7\u00e3o. O c\u00f3digo gerado costuma ser ileg\u00edvel. Refatore-o para melhorar sua legibilidade. Tip A instru\u00e7\u00e3o lea pode ser usada tanto para aritm\u00e9tica quanto para c\u00e1lculo de endere\u00e7os. Para tirar a d\u00favida basta olhar se as pr\u00f3ximas instru\u00e7\u00f5es fazem acesso \u00e0 mem\u00f3ria com o endere\u00e7o calculado ou apenas usam o valor diretamente (aritm\u00e9tica). Os registradores de tamanhos menores s\u00e3o virtuais. Quanto escrevo em %ax estou escrevendo nos 16 bits menos significativos de %rax e de %eax tamb\u00e9m. Muitas instru\u00e7\u00f5es com operadores de 32bits zeram os 32bits superiores. Assim, vemos por exemplo a instru\u00e7\u00e3o mov $0, %eax sendo usada para zerar um long . Nesses casos \u00e9 necess\u00e1rio verificar se a fun\u00e7\u00e3o continua usando %eax (\u00e9 int mesmo) ou se ela magicamente passa a usar %rax (o tipo era long ). Pr\u00e1tica \u00b6 Vamos agora exercitar. Cada exerc\u00edcio faz um c\u00e1lculo diferente. Se houver alguma instru\u00e7\u00e3o desconhecida, pesquise-a no google para encontrar seu significado. Normalmente algo como \"asm x64 instruction\" + a instru\u00e7\u00e3o desconhecida d\u00e1 respostas corretas. Warning Usaremos o gdb para abrir os arquivos .o nesta aula. Este tipo de arquivo cont\u00e9m fun\u00e7\u00f5es compiladas, mas n\u00e3o \u00e9 um execut\u00e1vel completo por n\u00e3o ter uma fun\u00e7\u00e3o main . Arquivo ex1.o \u00b6 Exercise O c\u00f3digo abaixo foi retirado do arquivo ex1.o . Fa\u00e7a sua tradu\u00e7\u00e3o para C . 0000000000000000 <ex1>: 0: 89 f8 mov %edi,%eax 2: 29 f0 sub %esi,%eax 4: c3 retq Arquivo ex2.o \u00b6 Exercise Use o gdb para listar as fun\u00e7\u00f5es definidas em ex2.o e escreva-as abaixo. Exercise Fa\u00e7a a tradu\u00e7\u00e3o das fun\u00e7\u00f5es acima para C Arquivo ex3.o \u00b6 A fun\u00e7\u00e3o abaixo foi obtida de ex3.o . 0000000000000000 <ex3>: 0: 8b 06 mov (%rsi),%eax 2: 0f af c0 imul %eax,%eax 5: 89 07 mov %eax,(%rdi) 7: c3 retq Exercise O qu\u00ea faz a instru\u00e7\u00e3o imul ? Exercise Traduza esta fun\u00e7\u00e3o para C . Fique atento ao tamanho dos registradores usados para identificar o tamanho dos vari\u00e1veis inteiras. Antes de prosseguir, valide suas solu\u00e7\u00f5es da se\u00e7\u00e3o anterior com o professor. Vamos agora trabalhar com execut\u00e1veis \"completos\". Vamos analisar n\u00e3o somente o c\u00f3digo das fun\u00e7\u00f5es mas tamb\u00e9m sua chamada. Arquivo ex4 \u00b6 Para come\u00e7ar! Use o gdb para obter o conte\u00fado das fun\u00e7\u00f5es main e ex4 . Dica : lembre-se do comando disas Localize a chamada da fun\u00e7\u00e3o ex4 no main. As intru\u00e7\u00f5es acima do call colocam os argumentos nos lugares corretos para ex4 rodar. Exercise Quantos argumentos a fun\u00e7\u00e3o recebe? Quais s\u00e3o seus valores? Exercise Traduza a fun\u00e7\u00e3o ex4 para C . Arquivo ex5 (desafio) \u00b6 Warning Este exerc\u00edcio \u00e9 avan\u00e7ado e necessita de pesquisa para ser realizado. Fa\u00e7a-o somente ap\u00f3s validar suas solu\u00e7\u00f5es dos anteriores com os professores. Neste exerc\u00edcio vamos nos aprofundar no uso de ponteiros. Vimos no ex3.o um exemplo de fun\u00e7\u00e3o que armazenava um valor calculado em um ponteiro. Agora veremos um exemplo completo que inclui a chamada de uma fun\u00e7\u00e3o recebendo um endere\u00e7o. O trecho abaixo copia os argumentos para os registradores corretos e chama a fun\u00e7\u00e3o. 60b: 48 8d 4c 24 08 lea 0x8(%rsp),%rcx 610: 48 8d 54 24 0c lea 0xc(%rsp),%rdx 615: be 03 00 00 00 mov $0x3,%esi 61a: bf 0a 00 00 00 mov $0xa,%edi 61f: e8 d6 ff ff ff callq 5fa <ex5> Exercise Identifique a partir dos tipos de dados colocados nos registradores qual o tipo dos argumentos da fun\u00e7\u00e3o. Exercise Qual s\u00e3o os endere\u00e7os passados para a fun\u00e7\u00e3o ex5 ? Escreva-os em fun\u00e7\u00e3o do registrador %rsp . Exercise Os endere\u00e7os acima s\u00e3o passados em quais registradores? Vamos agora ao c\u00f3digo de ex5 : 00000000000005fa <ex5>: 5fa: 89 f8 mov %edi,%eax 5fc: 48 89 d7 mov %rdx,%rdi 5ff: 99 cltd 600: f7 fe idiv %esi 602: 89 07 mov %eax,(%rdi) 604: 89 11 mov %edx,(%rcx) 606: c3 retq Exercise Como a instru\u00e7\u00e3o idiv funciona? Em quais registradores ela posiciona seu resultado? Em quais registradores ela espera a entrada? Exercise O qu\u00ea faz a instru\u00e7\u00e3o cltd ? Por qu\u00ea ela \u00e9 necess\u00e1ria? Exercise Fa\u00e7a a tradu\u00e7\u00e3o de ex5 para C . Conferindo tudo! Agora que terminou todos os exerc\u00edcios, confira suas tradu\u00e7\u00f5es com os gabaritos dispon\u00edveis no arquivo fontes.zip . Atividade para entrega! \u00b6 Aula com atividade para entrega . Confira seu reposit\u00f3rio de entregas do classroom! Aten\u00e7\u00e3o! Fa\u00e7a git pull no seu reposit\u00f3rio de entregas que ir\u00e1 aparecer uma nova pasta dentro de atv . Como come\u00e7ar? Leia o README.md dispon\u00edvel na pasta da atividade para descobrir como resolver e entregar. Prazo! Confira o prazo de entrega no menu Entregas e Prazos Hackerlab \u00b6 Nesse final de semana ser\u00e1 liberado o enunciado do primeiro lab! Confira em Hackerlab no menu Labs ! Aten\u00e7\u00e3o! Fa\u00e7a git pull no seu reposit\u00f3rio de entregas que ir\u00e1 aparecer uma nova pasta dentro de lab .","title":"04 - Fun\u00e7\u00f5es"},{"location":"aulas/04-funcoes-mov/#04-funcoes","text":"Neste handout vamos trabalhar pela primeira vez na tradu\u00e7\u00e3o reversa de programas em Assembly para C . Nas \u00faltimas aulas vimos as instru\u00e7\u00f5es mov e add e na aula de hoje vimos uma tabela grande com as instru\u00e7\u00f5es aritm\u00e9ticas ( add , sub , mul , imul , div , etc). Como em todas as aulas, veremos hoje um detalhe a mais sobre arquitetura x64 : chamadas de fun\u00e7\u00f5es e argumentos.","title":"04 - Fun\u00e7\u00f5es"},{"location":"aulas/04-funcoes-mov/#funcoes-e-seus-argumentos","text":"Em x64 os argumentos das fun\u00e7\u00f5es s\u00e3o passados nos registradores e o valor de retorno \u00e9 colocado tamb\u00e9m em um registrador. Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores ( nesta ordem ): %rdi %rsi %rdx %rcx %r8 %r9 Argumentos ponto flutuante s\u00e3o passados nos registradores %xmm0 at\u00e9 %xmm7 . Valores de retorno inteiros ou ponteiros s\u00e3o colocados no registrador %rax . Valores de retorno ponto flutuante s\u00e3o colocados no registrador %xmm0 . Para chamar fun\u00e7\u00f5es usamos a instru\u00e7\u00e3o call seguido do endere\u00e7o de mem\u00f3ria da fun\u00e7\u00e3o. O gdb cria um \"apelido\" para estes endere\u00e7os de mem\u00f3ria usando o nome original da fun\u00e7\u00e3o no arquivo .c . Assim, estas instru\u00e7\u00f5es s\u00e3o mostradas, normalmente, como call func1 , por exemplo. Note que antes de cada call devemos preencher os argumentos nos registradores corretos. Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax (ou %xmm0 para ponto flutuante). N\u00e3o se esque\u00e7a da equival\u00eancia entre o tamanhos dos registradores e os tipos inteiros em C . Um resumo gr\u00e1fico pode ser visto nas figuras acima. 64 bits ( %rax , %rdi e outros que come\u00e7am com r ): long , unsigned long ou ponteiro; 32 bits ( %eax , %edi e outros que come\u00e7a com e e os que terminam em d como r10d ): int ou unsigned int ; 16 bits ( %ax , %di e outros com duas letras somente terminando em x ): short ou unsigned short 8 bits ( %al , %ah e outros com duas letras terminando em h ou l ): char ou unsigned char . Vamos agora praticar fazendo a tradu\u00e7\u00e3o de fun\u00e7\u00f5es que fazem aritm\u00e9tica simples entre inteiros (usando ou n\u00e3o ponteiros). O exemplo abaixo mostra todas as etapas que precisamos seguir para fazer a tradu\u00e7\u00e3o Assembly -> C.","title":"Fun\u00e7\u00f5es e seus argumentos"},{"location":"aulas/04-funcoes-mov/#exemplo-guiado","text":"Dado o c\u00f3digo Assembly abaixo, fa\u00e7a sua tradu\u00e7\u00e3o para C 0000000000000000 <misterio1>: 0: 48 01 f7 add %rsi,%rdi 3: 48 8d 04 57 lea (%rdi,%rdx,2),%rax 7: c3 retq","title":"Exemplo guiado"},{"location":"aulas/04-funcoes-mov/#assinatura-da-funcao","text":"Vamos come\u00e7ar pela assinatura da fun\u00e7\u00e3o. \u00c9 sempre \u00fatil identificar quais registradores s\u00e3o lidos antes de serem escritos. Isso nos ajuda a entender se um registrador \u00e9 um argumento da fun\u00e7\u00e3o ou se ele \u00e9 apenas usado como vari\u00e1vel local. Faremos isso escrevendo todos os registradores que podem ser argumentos em ordem e vendo se s\u00e3o lidos ou escritos primeiro: %rdi - lido primeiro ( add faz a opera\u00e7\u00e3o += ) %rsi - lido primeiro (no lado esquerdo do add ) %rdx - lido primeiro (no lado esquerdo do lea ) %rcx - n\u00e3o usado %r8 - n\u00e3o usado %r9 - n\u00e3o usado Logo, os registradores %rdi , %rsi e %rdx s\u00e3o argumentos da fun\u00e7\u00e3o. Consultando o box de arquitetura de computadores, vemos que a fun\u00e7\u00e3o recebe tr\u00eas argumentos do tipo long (pois usa os registradores de 64 bits). Note que o resultado das computa\u00e7\u00f5es \u00e9 guardado em %rax , que guarda sempre o retorno da fun\u00e7\u00e3o. Por usar a por\u00e7\u00e3o de 64 bits do registrador, o tipo de retorno tamb\u00e9m \u00e9 long . A assinatura da fun\u00e7\u00e3o \u00e9, portanto long misterio1(long a, long b, long c); Tip Ponteiros tamb\u00e9m usam os registradores de 64 bits. Por\u00e9m, olhando rapidamente o c\u00f3digo notamos que n\u00e3o h\u00e1 nenhum acesso a mem\u00f3ria. Logo, se trata realmente de long .","title":"Assinatura da fun\u00e7\u00e3o"},{"location":"aulas/04-funcoes-mov/#o-codigo","text":"Vamos agora para o c\u00f3digo. Nossa primeira estrat\u00e9gia \u00e9 atribuir um nome para cada registrador. Os tr\u00eas registradores de argumentos j\u00e1 receberam os nomes a , b e c . Para deixar expl\u00edcito o papel do %rax vamos nome\u00e1-lo de retval . A primeira instru\u00e7\u00e3o add %rsi, %rdi realiza a adi\u00e7\u00e3o dos dois registradores e armazena em %rdi . Logo, sua tradu\u00e7\u00e3o direta seria: a += b ; A instru\u00e7\u00e3o lea (%rdi, %rdx, 2), %rax \u00e9 usada tanto para calcular endere\u00e7os de mem\u00f3ria quanto para aritm\u00e9tica simples. Vemos que \u00e9 o segundo caso pois, no c\u00f3digo seguinte, n\u00e3o acessamos a mem\u00f3ria com o valor calculado. Logo, podemos traduzir este trecho como retval = a + 2 * c ; Logo ap\u00f3s temos o ret , que \u00e9 traduzido como return retval ; Logo, nossa fun\u00e7\u00e3o \u00e9 traduzida como long misterio1 ( long a , long b , long c ){ long retval ; a += b ; retval = a + 2 * c ; return retval ; } Finalmente, podemos deixar nosso c\u00f3digo leg\u00edvel e escrev\u00ea-lo como long misterio1 ( long a , long b , long c ){ return a + b + 2 * c ; } Voc\u00ea pode verificar o c\u00f3digo original no arquivo exemplo1.c . O processo acima pode ser formalizado no seguinte algoritmo: Identifique quantos argumentos a fun\u00e7\u00e3o recebe Identifique os tipos de cada argumento (pode ser necess\u00e1rio olhar o c\u00f3digo assembly da fun\u00e7\u00e3o) D\u00ea um nome para cada registrador. Se um mesmo registrador \u00e9 usado com tamanhos diferentes ( %rdi e %edi s\u00e3o usados no c\u00f3digo), d\u00ea um nome diferente para cada tamanho. Fa\u00e7a a tradu\u00e7\u00e3o de cada instru\u00e7\u00e3o separadamente. Fique atento aos valores colocados em %rax e %eax perto do fim do c\u00f3digo. Esses valores ser\u00e3o retornados pela fun\u00e7\u00e3o. O c\u00f3digo gerado costuma ser ileg\u00edvel. Refatore-o para melhorar sua legibilidade. Tip A instru\u00e7\u00e3o lea pode ser usada tanto para aritm\u00e9tica quanto para c\u00e1lculo de endere\u00e7os. Para tirar a d\u00favida basta olhar se as pr\u00f3ximas instru\u00e7\u00f5es fazem acesso \u00e0 mem\u00f3ria com o endere\u00e7o calculado ou apenas usam o valor diretamente (aritm\u00e9tica). Os registradores de tamanhos menores s\u00e3o virtuais. Quanto escrevo em %ax estou escrevendo nos 16 bits menos significativos de %rax e de %eax tamb\u00e9m. Muitas instru\u00e7\u00f5es com operadores de 32bits zeram os 32bits superiores. Assim, vemos por exemplo a instru\u00e7\u00e3o mov $0, %eax sendo usada para zerar um long . Nesses casos \u00e9 necess\u00e1rio verificar se a fun\u00e7\u00e3o continua usando %eax (\u00e9 int mesmo) ou se ela magicamente passa a usar %rax (o tipo era long ).","title":"O c\u00f3digo"},{"location":"aulas/04-funcoes-mov/#pratica","text":"Vamos agora exercitar. Cada exerc\u00edcio faz um c\u00e1lculo diferente. Se houver alguma instru\u00e7\u00e3o desconhecida, pesquise-a no google para encontrar seu significado. Normalmente algo como \"asm x64 instruction\" + a instru\u00e7\u00e3o desconhecida d\u00e1 respostas corretas. Warning Usaremos o gdb para abrir os arquivos .o nesta aula. Este tipo de arquivo cont\u00e9m fun\u00e7\u00f5es compiladas, mas n\u00e3o \u00e9 um execut\u00e1vel completo por n\u00e3o ter uma fun\u00e7\u00e3o main .","title":"Pr\u00e1tica"},{"location":"aulas/04-funcoes-mov/#arquivo-ex1o","text":"Exercise O c\u00f3digo abaixo foi retirado do arquivo ex1.o . Fa\u00e7a sua tradu\u00e7\u00e3o para C . 0000000000000000 <ex1>: 0: 89 f8 mov %edi,%eax 2: 29 f0 sub %esi,%eax 4: c3 retq","title":"Arquivo ex1.o"},{"location":"aulas/04-funcoes-mov/#arquivo-ex2o","text":"Exercise Use o gdb para listar as fun\u00e7\u00f5es definidas em ex2.o e escreva-as abaixo. Exercise Fa\u00e7a a tradu\u00e7\u00e3o das fun\u00e7\u00f5es acima para C","title":"Arquivo ex2.o"},{"location":"aulas/04-funcoes-mov/#arquivo-ex3o","text":"A fun\u00e7\u00e3o abaixo foi obtida de ex3.o . 0000000000000000 <ex3>: 0: 8b 06 mov (%rsi),%eax 2: 0f af c0 imul %eax,%eax 5: 89 07 mov %eax,(%rdi) 7: c3 retq Exercise O qu\u00ea faz a instru\u00e7\u00e3o imul ? Exercise Traduza esta fun\u00e7\u00e3o para C . Fique atento ao tamanho dos registradores usados para identificar o tamanho dos vari\u00e1veis inteiras. Antes de prosseguir, valide suas solu\u00e7\u00f5es da se\u00e7\u00e3o anterior com o professor. Vamos agora trabalhar com execut\u00e1veis \"completos\". Vamos analisar n\u00e3o somente o c\u00f3digo das fun\u00e7\u00f5es mas tamb\u00e9m sua chamada.","title":"Arquivo ex3.o"},{"location":"aulas/04-funcoes-mov/#arquivo-ex4","text":"Para come\u00e7ar! Use o gdb para obter o conte\u00fado das fun\u00e7\u00f5es main e ex4 . Dica : lembre-se do comando disas Localize a chamada da fun\u00e7\u00e3o ex4 no main. As intru\u00e7\u00f5es acima do call colocam os argumentos nos lugares corretos para ex4 rodar. Exercise Quantos argumentos a fun\u00e7\u00e3o recebe? Quais s\u00e3o seus valores? Exercise Traduza a fun\u00e7\u00e3o ex4 para C .","title":"Arquivo ex4"},{"location":"aulas/04-funcoes-mov/#arquivo-ex5-desafio","text":"Warning Este exerc\u00edcio \u00e9 avan\u00e7ado e necessita de pesquisa para ser realizado. Fa\u00e7a-o somente ap\u00f3s validar suas solu\u00e7\u00f5es dos anteriores com os professores. Neste exerc\u00edcio vamos nos aprofundar no uso de ponteiros. Vimos no ex3.o um exemplo de fun\u00e7\u00e3o que armazenava um valor calculado em um ponteiro. Agora veremos um exemplo completo que inclui a chamada de uma fun\u00e7\u00e3o recebendo um endere\u00e7o. O trecho abaixo copia os argumentos para os registradores corretos e chama a fun\u00e7\u00e3o. 60b: 48 8d 4c 24 08 lea 0x8(%rsp),%rcx 610: 48 8d 54 24 0c lea 0xc(%rsp),%rdx 615: be 03 00 00 00 mov $0x3,%esi 61a: bf 0a 00 00 00 mov $0xa,%edi 61f: e8 d6 ff ff ff callq 5fa <ex5> Exercise Identifique a partir dos tipos de dados colocados nos registradores qual o tipo dos argumentos da fun\u00e7\u00e3o. Exercise Qual s\u00e3o os endere\u00e7os passados para a fun\u00e7\u00e3o ex5 ? Escreva-os em fun\u00e7\u00e3o do registrador %rsp . Exercise Os endere\u00e7os acima s\u00e3o passados em quais registradores? Vamos agora ao c\u00f3digo de ex5 : 00000000000005fa <ex5>: 5fa: 89 f8 mov %edi,%eax 5fc: 48 89 d7 mov %rdx,%rdi 5ff: 99 cltd 600: f7 fe idiv %esi 602: 89 07 mov %eax,(%rdi) 604: 89 11 mov %edx,(%rcx) 606: c3 retq Exercise Como a instru\u00e7\u00e3o idiv funciona? Em quais registradores ela posiciona seu resultado? Em quais registradores ela espera a entrada? Exercise O qu\u00ea faz a instru\u00e7\u00e3o cltd ? Por qu\u00ea ela \u00e9 necess\u00e1ria? Exercise Fa\u00e7a a tradu\u00e7\u00e3o de ex5 para C . Conferindo tudo! Agora que terminou todos os exerc\u00edcios, confira suas tradu\u00e7\u00f5es com os gabaritos dispon\u00edveis no arquivo fontes.zip .","title":"Arquivo ex5 (desafio)"},{"location":"aulas/04-funcoes-mov/#atividade-para-entrega","text":"Aula com atividade para entrega . Confira seu reposit\u00f3rio de entregas do classroom! Aten\u00e7\u00e3o! Fa\u00e7a git pull no seu reposit\u00f3rio de entregas que ir\u00e1 aparecer uma nova pasta dentro de atv . Como come\u00e7ar? Leia o README.md dispon\u00edvel na pasta da atividade para descobrir como resolver e entregar. Prazo! Confira o prazo de entrega no menu Entregas e Prazos","title":"Atividade para entrega!"},{"location":"aulas/04-funcoes-mov/#hackerlab","text":"Nesse final de semana ser\u00e1 liberado o enunciado do primeiro lab! Confira em Hackerlab no menu Labs ! Aten\u00e7\u00e3o! Fa\u00e7a git pull no seu reposit\u00f3rio de entregas que ir\u00e1 aparecer uma nova pasta dentro de lab .","title":"Hackerlab"},{"location":"aulas/05-condicionais/","text":"05 - Condicionais \u00b6 Express\u00f5es booleanas \u00b6 Vimos na expositiva que toda opera\u00e7\u00e3o aritm\u00e9tica preenche as flags CF , ZF , SF e OF e que podemos usar estas flags para montar express\u00f5es booleanas com as instru\u00e7\u00f5es set* . A tabela abaixo mostra as instru\u00e7\u00f5es respons\u00e1veis cada tipo de express\u00e3o booleana. Tamb\u00e9m vimos que podemos preencher estas flags usando as instru\u00e7\u00f5es cmp e test , que executam opera\u00e7\u00f5es aritm\u00e9ticas (subtra\u00e7\u00e3o e E bit a bit) mas n\u00e3o guardam o resultado. Vamos analisar o c\u00f3digo assembly da fun\u00e7\u00e3o igual . Por enquanto n\u00e3o precisa abrir o gdb nem c\u00f3digo algum, apenas fa\u00e7a a an\u00e1lise direto neste material! int igual ( int a , int b ) { return a == b ; } 0000000000000000 < igual > : 0: 39 f7 cmp %esi , %edi 2: 0 f 94 c0 sete %al 5: 0 f b6 c0 movzbl %al , %eax 8: c3 retq A compara\u00e7\u00e3o a == b \u00e9 feita primeiro executando cmp entre os argumentos %edi e %esi e depois usando sete ( set equal ) para atribuir 1 em %al se %edi == %esi e 0 caso contr\u00e1rio. Por fim, temos a instru\u00e7\u00e3o movzbl , que faz o cast de char ( %al ) para int ( %eax ). Lembre-se que as instru\u00e7\u00f5es set* s\u00f3 modificam os primeiros 8 bits de %eax . O restante continua com o valor antigo. Usamos movzbl para extender o n\u00famero em %al para ocupar todo %eax . Tip As instru\u00e7\u00f5es de convers\u00e3o de tipos s\u00e3o bastante frequentes em Assembly, principalmente para expandir valores colocados em registradores menores para registradores maiores. Elas seguem a seguinte regra: MOVtsd t pode ser z para tipos unsigned (completando com **z**eros) e s para tipos signed (completando com o bit de **s**inal). s \u00e9 o tamanho do registrador fonte seguindo a nota\u00e7\u00e3o b para 1 byte, w para 2 bytes, l para 4 bytes e q para 8 bytes. d \u00e9 o tamanho do registrador destino, seguinto a mesma nota\u00e7\u00e3o acima. Por exemplo, a instru\u00e7\u00e3o MOVZWQ converte um unsigned short para um unsigned long . Convers\u00f5es de 4 para 8 bytes muitas vezes s\u00e3o feitas com a instru\u00e7\u00e3o cltq , que extende (com sinal) %eax para %rax . Uma boa refer\u00eancia \u00e9 este site da Oracle . Vamos agora praticar. Mas antes, relembre da aula anterior a os registradores e a ordem em que os par\u00e2metros da fun\u00e7\u00e3o s\u00e3o passados: Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores ( nesta ordem ): %rdi %rsi %rdx %rcx %r8 %r9 Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax . Registradores: Pronto! Nos 3 exerc\u00edcios abaixo temos fun\u00e7\u00f5es que avaliam uma (ou mais) express\u00f5es booleanas entre seus argumentos e retornam o resultado. Arquivo ex1.o \u00b6 Reconstrua a fun\u00e7\u00e3o ex1 a partir do c\u00f3digo assembly abaixo. Dump of assembler code for function ex1 : 0 x0000000000000000 <+ 0 > : cmp $0xa , %edi 0 x0000000000000003 <+ 3 > : setg %al 0 x0000000000000006 <+ 6 > : movzbl %al , %eax 0 x0000000000000009 <+ 9 > : retq End of assembler dump. Exercise Qual \u00e9 o tamanho do argumento de ex1 ? Ele \u00e9 signed ou unsigned ? Exercise Coloque sua tradu\u00e7\u00e3o em um arquivo .c . Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o, ou utilize o gdb, conforme a pr\u00f3xima dica! Tip Uma outra maneira de conferir se sua solu\u00e7\u00e3o est\u00e1 correta \u00e9 compilar e conferir no gdb se a sua solu\u00e7\u00e3o produz o mesmo ASM que o compilado disponibilizado pelo professor. Caso seu c\u00f3digo n\u00e3o possua fun\u00e7\u00e3o main, gere um .o utilizando a flag -c . Veja o Exemplo de compila\u00e7\u00e3o sem fun\u00e7\u00e3o main: $ gcc -Og -g -Wall -std = c99 -c ex_resposta.c -o ex1_resp.o Ent\u00e3o, abra o gdb e confira se o ASM gerado confere com o disponibilizado pelo professor! Arquivo ex2.o \u00b6 Reconstrua a fun\u00e7\u00e3o ex2 a partir do c\u00f3digo assembly abaixo Dump of assembler code for function ex2 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : setbe %al 0 x0000000000000006 <+ 6 > : movzbl %al , %eax 0 x0000000000000009 <+ 9 > : retq End of assembler dump. Exercise Qual \u00e9 o tamanho dos argumentos de ex2 ? Ele \u00e9 signed ou unsigned ? Exercise Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o utilizando compara\u00e7\u00e3o do ASM (dica nesta aula), com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o. Arquivo ex3.o \u00b6 Reconstrua a fun\u00e7\u00e3o ex3 a partir do c\u00f3digo assembly abaixo. Dump of assembler code for function ex3 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : setg %al 0 x0000000000000006 <+ 6 > : test %rsi , %rsi 0 x0000000000000009 <+ 9 > : setg %dl 0 x000000000000000c <+ 12 > : and %edx , %eax 0 x000000000000000e <+ 14 > : movzbl %al , %eax 0 x0000000000000011 <+ 17 > : retq End of assembler dump. Exercise Qual \u00e9 o tamanho dos argumentos de ex3 ? Ele \u00e9 signed ou unsigned ? Exercise Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega. Condicionais \u00b6 Vimos na segunda parte expositiva que Assembly possui apenas instru\u00e7\u00f5es de pulos condicionais ( j* onde * representa uma compara\u00e7\u00e3o usando as mesmas abrevia\u00e7\u00f5es de set* ) e n\u00e3o condicionais ( jmp ). Vimos tamb\u00e9m que a combina\u00e7\u00e3o destas instru\u00e7\u00f5es com cmp e test \u00e9 equivalente \u00e0 dupla de comandos if ( cond - booleana ) { goto label ; } A tabela abaixo mostra as opera\u00e7\u00f5es de saltos condicionais. Exemplo guiado \u00b6 Vamos agora fazer um exemplo guiado. Analisaremos o seguinte c\u00f3digo: 0000000000000000 < eh_par >: 0 : 40 f6 c7 01 test $0x1 , % dil 4 : 74 06 je c < eh_par + 0xc > 6 : b8 00 00 00 00 mov $0x0 , % eax b : c3 retq c : b8 01 00 00 00 mov $0x1 , % eax 11 : c3 retq Pares de instru\u00e7\u00f5es test-j* ou cmp-j* s\u00e3o comumente usadas para representar a constru\u00e7\u00e3o if-goto . Exercise O nome da fun\u00e7\u00e3o d\u00e1 uma dica de seu valor de retorno. Voc\u00ea consegue entender o porqu\u00ea test $1, %dil faz isto? Dica: Escreva o teste exato que a fun\u00e7\u00e3o faz. Vamos agora traduzir a fun\u00e7\u00e3o eh_par para gotoC . As linhas 0-4 s\u00e3o transformadas em um par if-goto . O restante s\u00e3o instru\u00e7\u00f5es que j\u00e1 conhecemos. int eh_par ( long a ) { if (( a & 1 ) == 0 ) goto if1 ; return 0 ; if1 : return 1 ; } Tiramos ent\u00e3o o goto e levando em conta sua resposta no item anterior, ficamos com o seguinte c\u00f3digo. Note que precisamos negar a compara\u00e7\u00e3o feita no c\u00f3digo anterior! int eh_par ( long a ) { if ( a % 2 != 0 ) return 0 ; else return 1 ; } Podemos observar duas coisas no c\u00f3digo assembly gerado: O c\u00f3digo que estava dentro do if foi colocado ap\u00f3s o c\u00f3digo que estava fora do if! O compilador pode mudar a ordem dos nossos blocos de c\u00f3digo se for conveniente (para ele, n\u00e3o para n\u00f3s). A constru\u00e7\u00e3o test-j* e cmp-j* pode ser mapeada diretamente para if-goto . Por\u00e9m, reconstruir um c\u00f3digo leg\u00edvel requer, muitas vezes, mudar c\u00f3digo de lugar. Vamos agora praticar com alguns exerc\u00edcios simples: Arquivo ex4.o \u00b6 Veja o c\u00f3digo abaixo Dump of assembler code for function fun4 : 0 x0000000000000000 <+ 0 > : test %rdi , %rdi 0 x0000000000000003 <+ 3 > : jle 0xf < fun4 + 15 > 0 x0000000000000005 <+ 5 > : mov $0x2 , %eax 0 x000000000000000a <+ 10 > : imul %rsi , %rax 0 x000000000000000e <+ 14 > : retq 0 x000000000000000f <+ 15 > : mov $0x1 , %eax 0 x0000000000000014 <+ 20 > : jmp 0xa < fun4 + 10 > End of assembler dump. Exercise Qual express\u00e3o booleana \u00e9 testada? Exercise Fa\u00e7a a tradu\u00e7\u00e3o desta fun\u00e7\u00e3o para gotoC . Exercise Transforme o c\u00f3digo acima em C leg\u00edvel. Arquivo ex5.o \u00b6 Veja o c\u00f3digo da fun\u00e7\u00e3o abaixo. Dump of assembler code for function ex5 : 0 x0000000000000000 <+ 0 > : test %rdi , %rdi 0 x0000000000000003 <+ 3 > : setg %dl 0 x0000000000000006 <+ 6 > : test %rsi , %rsi 0 x0000000000000009 <+ 9 > : setle %al 0 x000000000000000c <+ 12 > : test %al , %dl 0 x000000000000000e <+ 14 > : jne 0x15 < ex5 + 21 > 0 x0000000000000010 <+ 16 > : lea -0 x2 ( %rsi ), %rax 0 x0000000000000014 <+ 20 > : retq 0 x0000000000000015 <+ 21 > : lea 0x5 ( %rdi ), %rax 0 x0000000000000019 <+ 25 > : retq End of assembler dump. Exercise Qual s\u00e3o as express\u00f5es booleanas testadas? (Dica: s\u00e3o 3, assim como no exerc\u00edcio 3). Exercise Fa\u00e7a uma tradu\u00e7\u00e3o para gotoC . Exercise Transforme seu c\u00f3digo acima para C leg\u00edvel. Exemplo guiado II \u00b6 Veremos agora um exemplo if/else : int exemplo2 ( long a , long b ) { long c ; if ( a >= 5 && b <= 0 ) { c = a + b ; } else { c = a - b ; } return c ; } Seu assembly correspondente, quando compilado com gcc -Og -c \u00e9 0000000000000000 < exemplo2 > : 0: 48 83 ff 04 cmp $0x4 , %rdi 4: 0 f 9 f c2 setg %dl 7: 48 85 f6 test %rsi , %rsi a: 0 f 9 e c0 setle %al d: 84 c2 test %al , %dl f: 75 07 jne 18 < exemplo2 + 0x18 > 11: 48 89 f8 mov %rdi , %rax 14: 48 29 f0 sub %rsi , %rax 17: c3 retq 18: 48 8 d 04 37 lea ( %rdi , %rsi , 1 ), %rax 1 c: c3 retq Primeiramente, notamos que a fun\u00e7\u00e3o recebe dois argumentos (pois s\u00f3 utiliza %rdi e %rsi ) e que ambos s\u00e3o tratados como long . Vamos ent\u00e3o \u00e0s express\u00f5es booleanas. Existem tr\u00eas express\u00f5es boolenas: cmp - setg (linhas 0-4 ) compara %rdi com 4 e seta %dl=1 se %rdi>4 (**g**reater) test-setle (linhas 7-a ) compara %rsi com 0 e seta %al=1 se %rsi<=0 (**l**ess or **e**qual). test (linha d ) entre %dl e %al . O resultado n\u00e3o \u00e9 armazenado. Logo abaixo do \u00faltimo test temos um jne (linha f ), acr\u00f4nimo para **j**ump if **n**ot **e**qual. Ou seja, fazemos o jump se %dl && %al for verdadeiro. Logo em seguida temos instru\u00e7\u00f5es aritm\u00e9ticas, que j\u00e1 estudamos nos \u00faltimos handouts. Assim como vimos nos slides, vamos converter este c\u00f3digo para gotoC primeiro. Assim como fizemos nos exerc\u00edcios de 1 a 3, criaremos uma vari\u00e1vel para as express\u00f5es booleanas 1 e 2 e substituiremos as instru\u00e7\u00f5es test-jne (linhas d-f ) por um par if-goto . Veja abaixo: int exemplo2 ( long a , long b ) { long retval ; int expr1 = a > 4 ; int expr2 = b <= 0 ; if ( expr1 && expr2 ) goto if1 ; retval = a ; retval -= b ; return retval ; if1 : retval = a + b ; return retval ; } Podemos ent\u00e3o melhorar tornar este c\u00f3digo mais leg\u00edvel, resultando no seguinte: int exemplo2 ( long a , long b ) { if ( a > 4 && b <= 0 ) { return a + b ; } else { return a - b ; } } Duas coisas importantes podem ser vistas neste c\u00f3digo As compara\u00e7\u00f5es n\u00e3o s\u00e3o exatamente iguais ( a>4 e a>=5 ), mas s\u00e3o equivalentes. O compilador pode trocar a ordem do if/else e colocar o else primeiro no Assembly gerado. Isto n\u00e3o altera o resultado da fun\u00e7\u00e3o, mas pode ser confuso de in\u00edcio. Arquivo ex6.o \u00b6 O exerc\u00edcio abaixo usa if-else . Dump of assembler code for function ex6 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : jle 0x8 < ex6 + 8 > 0 x0000000000000005 <+ 5 > : mov %rdi , %rsi 0 x0000000000000008 <+ 8 > : test %rdi , %rdi 0 x000000000000000b <+ 11 > : jle 0x10 < ex6 + 16 > 0 x000000000000000d <+ 13 > : neg %rsi 0 x0000000000000010 <+ 16 > : mov %esi , %eax 0 x0000000000000012 <+ 18 > : retq End of assembler dump. Exercise Traduza o c\u00f3digo acima para gotoC . Exercise Fa\u00e7a uma vers\u00e3o leg\u00edvel do c\u00f3digo acima.","title":"05 - Condicionais"},{"location":"aulas/05-condicionais/#05-condicionais","text":"","title":"05 - Condicionais"},{"location":"aulas/05-condicionais/#expressoes-booleanas","text":"Vimos na expositiva que toda opera\u00e7\u00e3o aritm\u00e9tica preenche as flags CF , ZF , SF e OF e que podemos usar estas flags para montar express\u00f5es booleanas com as instru\u00e7\u00f5es set* . A tabela abaixo mostra as instru\u00e7\u00f5es respons\u00e1veis cada tipo de express\u00e3o booleana. Tamb\u00e9m vimos que podemos preencher estas flags usando as instru\u00e7\u00f5es cmp e test , que executam opera\u00e7\u00f5es aritm\u00e9ticas (subtra\u00e7\u00e3o e E bit a bit) mas n\u00e3o guardam o resultado. Vamos analisar o c\u00f3digo assembly da fun\u00e7\u00e3o igual . Por enquanto n\u00e3o precisa abrir o gdb nem c\u00f3digo algum, apenas fa\u00e7a a an\u00e1lise direto neste material! int igual ( int a , int b ) { return a == b ; } 0000000000000000 < igual > : 0: 39 f7 cmp %esi , %edi 2: 0 f 94 c0 sete %al 5: 0 f b6 c0 movzbl %al , %eax 8: c3 retq A compara\u00e7\u00e3o a == b \u00e9 feita primeiro executando cmp entre os argumentos %edi e %esi e depois usando sete ( set equal ) para atribuir 1 em %al se %edi == %esi e 0 caso contr\u00e1rio. Por fim, temos a instru\u00e7\u00e3o movzbl , que faz o cast de char ( %al ) para int ( %eax ). Lembre-se que as instru\u00e7\u00f5es set* s\u00f3 modificam os primeiros 8 bits de %eax . O restante continua com o valor antigo. Usamos movzbl para extender o n\u00famero em %al para ocupar todo %eax . Tip As instru\u00e7\u00f5es de convers\u00e3o de tipos s\u00e3o bastante frequentes em Assembly, principalmente para expandir valores colocados em registradores menores para registradores maiores. Elas seguem a seguinte regra: MOVtsd t pode ser z para tipos unsigned (completando com **z**eros) e s para tipos signed (completando com o bit de **s**inal). s \u00e9 o tamanho do registrador fonte seguindo a nota\u00e7\u00e3o b para 1 byte, w para 2 bytes, l para 4 bytes e q para 8 bytes. d \u00e9 o tamanho do registrador destino, seguinto a mesma nota\u00e7\u00e3o acima. Por exemplo, a instru\u00e7\u00e3o MOVZWQ converte um unsigned short para um unsigned long . Convers\u00f5es de 4 para 8 bytes muitas vezes s\u00e3o feitas com a instru\u00e7\u00e3o cltq , que extende (com sinal) %eax para %rax . Uma boa refer\u00eancia \u00e9 este site da Oracle . Vamos agora praticar. Mas antes, relembre da aula anterior a os registradores e a ordem em que os par\u00e2metros da fun\u00e7\u00e3o s\u00e3o passados: Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores ( nesta ordem ): %rdi %rsi %rdx %rcx %r8 %r9 Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax . Registradores: Pronto! Nos 3 exerc\u00edcios abaixo temos fun\u00e7\u00f5es que avaliam uma (ou mais) express\u00f5es booleanas entre seus argumentos e retornam o resultado.","title":"Express\u00f5es booleanas"},{"location":"aulas/05-condicionais/#arquivo-ex1o","text":"Reconstrua a fun\u00e7\u00e3o ex1 a partir do c\u00f3digo assembly abaixo. Dump of assembler code for function ex1 : 0 x0000000000000000 <+ 0 > : cmp $0xa , %edi 0 x0000000000000003 <+ 3 > : setg %al 0 x0000000000000006 <+ 6 > : movzbl %al , %eax 0 x0000000000000009 <+ 9 > : retq End of assembler dump. Exercise Qual \u00e9 o tamanho do argumento de ex1 ? Ele \u00e9 signed ou unsigned ? Exercise Coloque sua tradu\u00e7\u00e3o em um arquivo .c . Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o, ou utilize o gdb, conforme a pr\u00f3xima dica! Tip Uma outra maneira de conferir se sua solu\u00e7\u00e3o est\u00e1 correta \u00e9 compilar e conferir no gdb se a sua solu\u00e7\u00e3o produz o mesmo ASM que o compilado disponibilizado pelo professor. Caso seu c\u00f3digo n\u00e3o possua fun\u00e7\u00e3o main, gere um .o utilizando a flag -c . Veja o Exemplo de compila\u00e7\u00e3o sem fun\u00e7\u00e3o main: $ gcc -Og -g -Wall -std = c99 -c ex_resposta.c -o ex1_resp.o Ent\u00e3o, abra o gdb e confira se o ASM gerado confere com o disponibilizado pelo professor!","title":"Arquivo ex1.o"},{"location":"aulas/05-condicionais/#arquivo-ex2o","text":"Reconstrua a fun\u00e7\u00e3o ex2 a partir do c\u00f3digo assembly abaixo Dump of assembler code for function ex2 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : setbe %al 0 x0000000000000006 <+ 6 > : movzbl %al , %eax 0 x0000000000000009 <+ 9 > : retq End of assembler dump. Exercise Qual \u00e9 o tamanho dos argumentos de ex2 ? Ele \u00e9 signed ou unsigned ? Exercise Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o utilizando compara\u00e7\u00e3o do ASM (dica nesta aula), com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o.","title":"Arquivo ex2.o"},{"location":"aulas/05-condicionais/#arquivo-ex3o","text":"Reconstrua a fun\u00e7\u00e3o ex3 a partir do c\u00f3digo assembly abaixo. Dump of assembler code for function ex3 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : setg %al 0 x0000000000000006 <+ 6 > : test %rsi , %rsi 0 x0000000000000009 <+ 9 > : setg %dl 0 x000000000000000c <+ 12 > : and %edx , %eax 0 x000000000000000e <+ 14 > : movzbl %al , %eax 0 x0000000000000011 <+ 17 > : retq End of assembler dump. Exercise Qual \u00e9 o tamanho dos argumentos de ex3 ? Ele \u00e9 signed ou unsigned ? Exercise Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega.","title":"Arquivo ex3.o"},{"location":"aulas/05-condicionais/#condicionais","text":"Vimos na segunda parte expositiva que Assembly possui apenas instru\u00e7\u00f5es de pulos condicionais ( j* onde * representa uma compara\u00e7\u00e3o usando as mesmas abrevia\u00e7\u00f5es de set* ) e n\u00e3o condicionais ( jmp ). Vimos tamb\u00e9m que a combina\u00e7\u00e3o destas instru\u00e7\u00f5es com cmp e test \u00e9 equivalente \u00e0 dupla de comandos if ( cond - booleana ) { goto label ; } A tabela abaixo mostra as opera\u00e7\u00f5es de saltos condicionais.","title":"Condicionais"},{"location":"aulas/05-condicionais/#exemplo-guiado","text":"Vamos agora fazer um exemplo guiado. Analisaremos o seguinte c\u00f3digo: 0000000000000000 < eh_par >: 0 : 40 f6 c7 01 test $0x1 , % dil 4 : 74 06 je c < eh_par + 0xc > 6 : b8 00 00 00 00 mov $0x0 , % eax b : c3 retq c : b8 01 00 00 00 mov $0x1 , % eax 11 : c3 retq Pares de instru\u00e7\u00f5es test-j* ou cmp-j* s\u00e3o comumente usadas para representar a constru\u00e7\u00e3o if-goto . Exercise O nome da fun\u00e7\u00e3o d\u00e1 uma dica de seu valor de retorno. Voc\u00ea consegue entender o porqu\u00ea test $1, %dil faz isto? Dica: Escreva o teste exato que a fun\u00e7\u00e3o faz. Vamos agora traduzir a fun\u00e7\u00e3o eh_par para gotoC . As linhas 0-4 s\u00e3o transformadas em um par if-goto . O restante s\u00e3o instru\u00e7\u00f5es que j\u00e1 conhecemos. int eh_par ( long a ) { if (( a & 1 ) == 0 ) goto if1 ; return 0 ; if1 : return 1 ; } Tiramos ent\u00e3o o goto e levando em conta sua resposta no item anterior, ficamos com o seguinte c\u00f3digo. Note que precisamos negar a compara\u00e7\u00e3o feita no c\u00f3digo anterior! int eh_par ( long a ) { if ( a % 2 != 0 ) return 0 ; else return 1 ; } Podemos observar duas coisas no c\u00f3digo assembly gerado: O c\u00f3digo que estava dentro do if foi colocado ap\u00f3s o c\u00f3digo que estava fora do if! O compilador pode mudar a ordem dos nossos blocos de c\u00f3digo se for conveniente (para ele, n\u00e3o para n\u00f3s). A constru\u00e7\u00e3o test-j* e cmp-j* pode ser mapeada diretamente para if-goto . Por\u00e9m, reconstruir um c\u00f3digo leg\u00edvel requer, muitas vezes, mudar c\u00f3digo de lugar. Vamos agora praticar com alguns exerc\u00edcios simples:","title":"Exemplo guiado"},{"location":"aulas/05-condicionais/#arquivo-ex4o","text":"Veja o c\u00f3digo abaixo Dump of assembler code for function fun4 : 0 x0000000000000000 <+ 0 > : test %rdi , %rdi 0 x0000000000000003 <+ 3 > : jle 0xf < fun4 + 15 > 0 x0000000000000005 <+ 5 > : mov $0x2 , %eax 0 x000000000000000a <+ 10 > : imul %rsi , %rax 0 x000000000000000e <+ 14 > : retq 0 x000000000000000f <+ 15 > : mov $0x1 , %eax 0 x0000000000000014 <+ 20 > : jmp 0xa < fun4 + 10 > End of assembler dump. Exercise Qual express\u00e3o booleana \u00e9 testada? Exercise Fa\u00e7a a tradu\u00e7\u00e3o desta fun\u00e7\u00e3o para gotoC . Exercise Transforme o c\u00f3digo acima em C leg\u00edvel.","title":"Arquivo ex4.o"},{"location":"aulas/05-condicionais/#arquivo-ex5o","text":"Veja o c\u00f3digo da fun\u00e7\u00e3o abaixo. Dump of assembler code for function ex5 : 0 x0000000000000000 <+ 0 > : test %rdi , %rdi 0 x0000000000000003 <+ 3 > : setg %dl 0 x0000000000000006 <+ 6 > : test %rsi , %rsi 0 x0000000000000009 <+ 9 > : setle %al 0 x000000000000000c <+ 12 > : test %al , %dl 0 x000000000000000e <+ 14 > : jne 0x15 < ex5 + 21 > 0 x0000000000000010 <+ 16 > : lea -0 x2 ( %rsi ), %rax 0 x0000000000000014 <+ 20 > : retq 0 x0000000000000015 <+ 21 > : lea 0x5 ( %rdi ), %rax 0 x0000000000000019 <+ 25 > : retq End of assembler dump. Exercise Qual s\u00e3o as express\u00f5es booleanas testadas? (Dica: s\u00e3o 3, assim como no exerc\u00edcio 3). Exercise Fa\u00e7a uma tradu\u00e7\u00e3o para gotoC . Exercise Transforme seu c\u00f3digo acima para C leg\u00edvel.","title":"Arquivo ex5.o"},{"location":"aulas/05-condicionais/#exemplo-guiado-ii","text":"Veremos agora um exemplo if/else : int exemplo2 ( long a , long b ) { long c ; if ( a >= 5 && b <= 0 ) { c = a + b ; } else { c = a - b ; } return c ; } Seu assembly correspondente, quando compilado com gcc -Og -c \u00e9 0000000000000000 < exemplo2 > : 0: 48 83 ff 04 cmp $0x4 , %rdi 4: 0 f 9 f c2 setg %dl 7: 48 85 f6 test %rsi , %rsi a: 0 f 9 e c0 setle %al d: 84 c2 test %al , %dl f: 75 07 jne 18 < exemplo2 + 0x18 > 11: 48 89 f8 mov %rdi , %rax 14: 48 29 f0 sub %rsi , %rax 17: c3 retq 18: 48 8 d 04 37 lea ( %rdi , %rsi , 1 ), %rax 1 c: c3 retq Primeiramente, notamos que a fun\u00e7\u00e3o recebe dois argumentos (pois s\u00f3 utiliza %rdi e %rsi ) e que ambos s\u00e3o tratados como long . Vamos ent\u00e3o \u00e0s express\u00f5es booleanas. Existem tr\u00eas express\u00f5es boolenas: cmp - setg (linhas 0-4 ) compara %rdi com 4 e seta %dl=1 se %rdi>4 (**g**reater) test-setle (linhas 7-a ) compara %rsi com 0 e seta %al=1 se %rsi<=0 (**l**ess or **e**qual). test (linha d ) entre %dl e %al . O resultado n\u00e3o \u00e9 armazenado. Logo abaixo do \u00faltimo test temos um jne (linha f ), acr\u00f4nimo para **j**ump if **n**ot **e**qual. Ou seja, fazemos o jump se %dl && %al for verdadeiro. Logo em seguida temos instru\u00e7\u00f5es aritm\u00e9ticas, que j\u00e1 estudamos nos \u00faltimos handouts. Assim como vimos nos slides, vamos converter este c\u00f3digo para gotoC primeiro. Assim como fizemos nos exerc\u00edcios de 1 a 3, criaremos uma vari\u00e1vel para as express\u00f5es booleanas 1 e 2 e substituiremos as instru\u00e7\u00f5es test-jne (linhas d-f ) por um par if-goto . Veja abaixo: int exemplo2 ( long a , long b ) { long retval ; int expr1 = a > 4 ; int expr2 = b <= 0 ; if ( expr1 && expr2 ) goto if1 ; retval = a ; retval -= b ; return retval ; if1 : retval = a + b ; return retval ; } Podemos ent\u00e3o melhorar tornar este c\u00f3digo mais leg\u00edvel, resultando no seguinte: int exemplo2 ( long a , long b ) { if ( a > 4 && b <= 0 ) { return a + b ; } else { return a - b ; } } Duas coisas importantes podem ser vistas neste c\u00f3digo As compara\u00e7\u00f5es n\u00e3o s\u00e3o exatamente iguais ( a>4 e a>=5 ), mas s\u00e3o equivalentes. O compilador pode trocar a ordem do if/else e colocar o else primeiro no Assembly gerado. Isto n\u00e3o altera o resultado da fun\u00e7\u00e3o, mas pode ser confuso de in\u00edcio.","title":"Exemplo guiado II"},{"location":"aulas/05-condicionais/#arquivo-ex6o","text":"O exerc\u00edcio abaixo usa if-else . Dump of assembler code for function ex6 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : jle 0x8 < ex6 + 8 > 0 x0000000000000005 <+ 5 > : mov %rdi , %rsi 0 x0000000000000008 <+ 8 > : test %rdi , %rdi 0 x000000000000000b <+ 11 > : jle 0x10 < ex6 + 16 > 0 x000000000000000d <+ 13 > : neg %rsi 0 x0000000000000010 <+ 16 > : mov %esi , %eax 0 x0000000000000012 <+ 18 > : retq End of assembler dump. Exercise Traduza o c\u00f3digo acima para gotoC . Exercise Fa\u00e7a uma vers\u00e3o leg\u00edvel do c\u00f3digo acima.","title":"Arquivo ex6.o"},{"location":"aulas/06-condicionais-funcoes/","text":"06 - Condicionais e fun\u00e7\u00f5es \u00b6 Na aula de hoje vamos revisar e praticar os conceitos de fun\u00e7\u00f5es e condicionais em Assembly. Teremos exerc\u00edcios simples de cada assunto e no fim alguns exerc\u00edcios para entrega que juntam coisas diferentes. Fun\u00e7\u00f5es e aritm\u00e9tica com LEA \u00b6 Todos os exerc\u00edcios da revis\u00e3o ser\u00e3o feitos com o arquivo exemplo1 (compilado a partir de exemplo1.c ). Vamos examinar tanto a fun\u00e7\u00e3o main quanto a fun\u00e7\u00e3o exemplo1 . Compile com: $ gcc -Og -Wall -std = c99 exemplo1.c -o exemplo1 Chamadas de fun\u00e7\u00f5es \u00b6 As chamadas de fun\u00e7\u00e3o s\u00e3o feitas usando a seguinte ordem para os argumentos inteiros: %rdi %rsi %rdx %rcx %r8 %r9 Esta ordem nunca muda . Veja abaixo um exemplo de chamada de fun\u00e7\u00e3o tirado do main de exemplo1 . 0 x01163 <+ 8 > : mov $0x6 , %r9d 0 x01169 <+ 14 > : mov $0x5 , %r8d 0 x0116f <+ 20 > : mov $0x4 , %ecx 0 x01174 <+ 25 > : mov $0x3 , %edx 0 x01179 <+ 30 > : mov $0x2 , %esi 0 x0117e <+ 35 > : mov $0x1 , %edi 0 x01183 <+ 40 > : call 0x1149 < exemplo1 > 0 x01188 <+ 45 > : lea 0xa ( %rax ), %esi Pergunta O valor do primeiro argumento da fun\u00e7\u00e3o \u00e9 6 1 Answer A ordem dos par\u00e2metros segue \u00e9 sempre a mesma vista na aula 04 . Mesmo que as instru\u00e7\u00f5es estejam em ordem diferente, %edi (ou uma de suas partes) \u00e9 sempre o primeiro par\u00e2metro. Exercise A instru\u00e7\u00e3o call realiza chamadas de fun\u00e7\u00e3o. Traduza a chamada de fun\u00e7\u00e3o acima para C . Answer exemplo1(1, 2, 3, 4, 5, 6) Vamos agora analisar o c\u00f3digo de exemplo1 : Dump of assembler code for function exemplo1 : 0 x01149 <+ 0 > : endbr64 0x0114d <+ 4 > : add %esi , %edi 0 x0114f <+ 6 > : add %edx , %edi 0 x01151 <+ 8 > : add %ecx , %edi 0 x01153 <+ 10 > : add %r8d , %edi 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax 0 x0115a <+ 17 > : ret Exercise Quantos par\u00e2metros a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Ela retorna algum valor? Se sim, qual seu tipo? Answer Pelos registradores utilizados, percebemos que a fun\u00e7\u00e3o tem seis par\u00e2metros, todos int . O retorno tamb\u00e9m \u00e9 int . Exercise Declare a fun\u00e7\u00e3o acima com base na sua resposta anterior. Answer int exemplo1(int a, int b, int c, int d, int e, int f); Exercise O que faz o conjunto de instru\u00e7\u00f5es add nas linhas +4 at\u00e9 +10 ? Escreva uma express\u00e3o em C equivalente. Answer Ela soma os primeiros 5 argumentos: a + b + c + e . Vemos na linha exemplo1+13 que colocamos um valor no registrador %eax e depois finalizamos a fun\u00e7\u00e3o usando ret . Este \u00e9 o segundo ponto que nunca muda: o valor de retorno de toda fun\u00e7\u00e3o \u00e9 colocado no registrador %rax (ou uma de suas partes menores). Neste exemplo, a instru\u00e7\u00e3o usada foi o LEA que relembraremos na se\u00e7\u00e3o a seguir. Opera\u00e7\u00f5es aritm\u00e9ticas usando LEA \u00b6 Se usada de maneira literal, a instru\u00e7\u00e3o LEA (Load Effective Address) serve para calcular o endere\u00e7o de uma vari\u00e1vel local e \u00e9 equivalente ao operador & em C . Por\u00e9m, ela \u00e9 frequentemente \"abusada\" para fazer aritm\u00e9tica. Um ponto importante quando usamos LEA \u00e9 que todos os operandos s\u00e3o registradores de 64 bits. Regra geral Se LEA for usada com o registrador %rsp ent\u00e3o ela sempre representa o operador & Se os registradores envolvidos foram usados como n\u00fameros inteiros em instru\u00e7\u00f5es anteriores, ent\u00e3o ela representa uma conta com os valores dos registradores. Vejamos o exemplo da fun\u00e7\u00e3o exemplo1 acima: lea ( %rdi , %r9 , 1 ), %eax 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax No exemplo acima LEA \u00e9 usada para fazer aritm\u00e9tica. Sabemos disso pois, na chamada traduzida na parte anterior, elas recebem n\u00fameros inteiros ( %r9d = 6 e %edi = 1 mais o resultado de sucessivas somas). Seu primeiro argumento segue a seguinte l\u00f3gica C ( %R1 , %R2 , S ) C \u00e9 uma constante %R1 \u00e9 um registrador %R2 \u00e9 um registrador (pode ser igual a %R1 ) S \u00e9 1, 2, 4 ou 8 (todos os tamanhos poss\u00edveis de registradores inteiros) A opera\u00e7\u00e3o acima calcula C + %R1 + (%R2 * S) . A opera\u00e7\u00e3o LEA nunca acessa a mem\u00f3ria , apenas move o resultado deste c\u00e1lculo para o registrador destino. Qualquer outra opera\u00e7\u00e3o que use a sintaxe acima est\u00e1 fazendo um acesso a mem\u00f3ria. LEA \u00e9 a \u00fanica exce\u00e7\u00e3o! Exercise Traduza a opera\u00e7\u00e3o abaixo para C 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax Answer Supondo que aux = a+b+c+d+e j\u00e1 foi calculado com o uso das instru\u00e7\u00f5es ADD , ent\u00e3o o LEA calcula aux + f*1 . Exercise Com estas informa\u00e7\u00f5es em m\u00e3os, traduza exemplo1 para C Dump of assembler code for function exemplo1 : 0 x01149 <+ 0 > : endbr64 0x0114d <+ 4 > : add %esi , %edi 0 x0114f <+ 6 > : add %edx , %edi 0 x01151 <+ 8 > : add %ecx , %edi 0 x01153 <+ 10 > : add %r8d , %edi 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax 0 x0115a <+ 17 > : ret Answer Confira no arquivo exemplo1.c Retorno de fun\u00e7\u00f5es \u00b6 Vamos terminar nossa revis\u00e3o analisando novamente a chamada de exemplo1 no main : 0 x01163 <+ 8 > : mov $0x6 , %r9d 0 x01169 <+ 14 > : mov $0x5 , %r8d 0 x0116f <+ 20 > : mov $0x4 , %ecx 0 x01174 <+ 25 > : mov $0x3 , %edx 0 x01179 <+ 30 > : mov $0x2 , %esi 0 x0117e <+ 35 > : mov $0x1 , %edi 0 x01183 <+ 40 > : call 0x1149 < exemplo1 > 0 x01188 <+ 45 > : lea 0xa ( %rax ), %esi Anteriormente j\u00e1 vimos que o call e os mov s acima fazem a chamada exemplo1(1,2,3,4,5,6) em C . A linha de baixo realiza uma opera\u00e7\u00e3o aritm\u00e9tica com %rax . Exercise Considerando que %rax armazena o valor de retorno de uma fun\u00e7\u00e3o, qual seria a tradu\u00e7\u00e3o para C do bloco de c\u00f3digo acima? Answer int esi = exemplo1(1, 2, 3, 4, 5, 6) + 10; Exerc\u00edcios combinados \u00b6 Warning Todos os exerc\u00edcios desta se\u00e7\u00e3o s\u00e3o para entrega. Voc\u00eas podem se conversar para faz\u00ea-los, mas cada um deve criar sua pr\u00f3pria solu\u00e7\u00e3o do zero. Todos os exerc\u00edcios j\u00e1 est\u00e3o dispon\u00edveis no seu reposit\u00f3rio de entregas da disciplina em atv/04-condicionais-funcoes . Leia o README dentro da pasta para mais informa\u00e7\u00f5es. Fun\u00e7\u00e3o ex1 : Aritm\u00e9tica e Express\u00f5es booleanas . \u00b6 Dump of assembler code for function ex1 : 0 x000 <+ 0 > : endbr64 0 x004 <+ 4 > : lea ( %rdi , %rsi , 1 ), %rax 0 x008 <+ 8 > : lea ( %rax , %rdx , 4 ), %rcx 0 x00c <+ 12 > : imul %rdi , %rdi 0 x010 <+ 16 > : lea ( %rdi , %rsi , 2 ), %rax 0 x014 <+ 20 > : add %rax , %rdx 0 x017 <+ 23 > : cmp %rdx , %rcx 0 x01a <+ 26 > : setge %al 0 x01d <+ 29 > : movzbl %al , %eax 0 x020 <+ 32 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Declare a fun\u00e7\u00e3o abaixo. Exercise As instru\u00e7\u00f5es LEA acima representam opera\u00e7\u00f5es aritm\u00e9ticas ou a opera\u00e7\u00e3o endere\u00e7o de & ? Como voc\u00ea fez esta identifica\u00e7\u00e3o? . Exercise Traduza as opera\u00e7\u00f5es das linhas ex1+0 at\u00e9 ex1+16 para C Exercise Nas linhas ex1+23 e ex1+26 \u00e9 feita uma compara\u00e7\u00e3o. Qual e entre quais registradores? Onde \u00e9 armazenado este resultado? Exercise O qu\u00ea faz a instru\u00e7\u00e3o movzbl em ex1+29 ? Juntando com a resposta da pergunta acima, traduza as instru\u00e7\u00f5es ex1+23 at\u00e9 ex1+32 para C . Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes. Fun\u00e7\u00e3o ex2 : Chamadas de fun\u00e7\u00f5es e Condicionais . \u00b6 Quando analisar o c\u00f3digo do ex2 no gdb, utilize o arquivo ex2_ref para visualizar corretamente as chamadas de fun\u00e7\u00f5es. Seria uma boa tamb\u00e9m consultar as relocation entries no terminal com objdump -r ex2.o . Dump of assembler code for function ex2 : 0 x01132 <+ 0 > : endbr64 0 x01136 <+ 4 > : push %rbx 0 x01137 <+ 5 > : mov %rdi , %rbx 0 x0113a <+ 8 > : mov %rsi , %rdi 0 x0113d <+ 11 > : call 0x1129 < vezes2 > 0 x01142 <+ 16 > : cmp %rbx , %rax 0 x01145 <+ 19 > : jle 0x114a < ex2 + 24 > 0 x01147 <+ 21 > : add %rbx , %rbx 0 x0114a <+ 24 > : add %rbx , %rax 0 x0114d <+ 27 > : pop %rbx 0 x0114e <+ 28 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais s\u00e3o seus tipos? Declare-a abaixo. Vamos come\u00e7ar trabalhando na linha ex2+11 , na instru\u00e7\u00e3o call vezes2 . A chamada necessita usar o registrador %rdi , mas ele cont\u00e9m o primeiro argumento de ex2 . Exercise Em qual registrador \u00e9 guardado o primeiro argumento de ex2 ? Isso \u00e9 feito antes da chamada call . Exercise Qual vari\u00e1vel \u00e9 passada como argumento para a fun\u00e7\u00e3o vezes2 ? Exercise Escreva abaixo a invoca\u00e7\u00e3o de vezes2 . Voc\u00ea deve ter notado as instru\u00e7\u00f5es push/pop %rbx no come\u00e7o/fim da fun\u00e7\u00e3o. Toda fun\u00e7\u00e3o pode usar os registradores de argumentos (vistos na parte 1) e o de valor de retorno como quiserem. Se precisarem mexer nos outros registradores a pr\u00e1tica \u00e9 salv\u00e1-los na pilha no come\u00e7o da fun\u00e7\u00e3o e restaur\u00e1-los no fim. Assim n\u00e3o importa o que a fun\u00e7\u00e3o fa\u00e7a, para a fun\u00e7\u00e3o chamadora \u00e9 como se n\u00e3o houvesse havido nenhuma modifica\u00e7\u00e3o nos outros registradores. Vamos agora olhar a condicional na linha ex2+16 . Exercise Ap\u00f3s a chamada call , qual o conte\u00fado de %rax ? Exercise Juntando suas respostas nas quest\u00f5es de cima, qual \u00e9 a compara\u00e7\u00e3o feita nas linhas ex2+16, ex2+19 ? Exercise Com essas informa\u00e7\u00f5es em m\u00e3os, fa\u00e7a uma tradu\u00e7\u00e3o do c\u00f3digo acima para C usando somente if+goto . Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes. Fun\u00e7\u00e3o ex3 : Ponteiros e Express\u00f5es booleanas . \u00b6 Dump of assembler code for function ex3 : 0 x000 <+ 0 > : endbr64 0 x004 <+ 4 > : cmp %rsi , %rdi 0 x007 <+ 7 > : setl %al 0 x00a <+ 10 > : movzbl %al , %eax 0 x00d <+ 13 > : mov %eax ,( %rdx ) 0 x00f <+ 15 > : sete %al 0 x012 <+ 18 > : movzbl %al , %eax 0 x015 <+ 21 > : mov %eax ,( %rcx ) 0 x017 <+ 23 > : setg %al 0 x01a <+ 26 > : movzbl %al , %eax 0 x01d <+ 29 > : mov %eax ,( %r8 ) 0 x020 <+ 32 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? De quais tipos? Declare-a abaixo. Exercise A fun\u00e7\u00e3o acima faz v\u00e1rias compara\u00e7\u00f5es. Liste quais e entre quais argumentos. Exercise Onde \u00e9 armazenado o resultado de cada compara\u00e7\u00e3o? Exercise Com base em suas respostas acima, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha da fun\u00e7\u00e3o acima. Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes. Fun\u00e7\u00e3o ex4 : Ponteiros e Express\u00f5es booleanas . \u00b6 Dump of assembler code for function ex4 : 0 x00a <+ 0 > : endbr64 0x00e <+ 4 > : cmp $0x11 , %di 0 x012 <+ 8 > : jle 0x21 < ex4 + 23 > 0 x014 <+ 10 > : sub $0x41 , %esi 0 x017 <+ 13 > : cmp $0x1 , %sil 0 x01b <+ 17 > : ja 0x29 < ex4 + 31 > 0 x01d <+ 19 > : lea -0 x11 ( %rdi ), %eax 0 x020 <+ 22 > : ret 0x021 <+ 23 > : mov $0x12 , %eax 0 x026 <+ 28 > : sub %edi , %eax 0 x028 <+ 30 > : ret 0x029 <+ 31 > : mov $0xffffffff , %eax 0 x02e <+ 36 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? De quais tipos? Declare-a abaixo. Exercise A fun\u00e7\u00e3o acima faz v\u00e1rias compara\u00e7\u00f5es. Liste quais e entre quais argumentos. Exercise Onde \u00e9 armazenado o resultado de cada compara\u00e7\u00e3o? Exercise Com base em suas respostas acima, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha da fun\u00e7\u00e3o acima. Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes.","title":"06 - Condicionais e fun\u00e7\u00f5es"},{"location":"aulas/06-condicionais-funcoes/#06-condicionais-e-funcoes","text":"Na aula de hoje vamos revisar e praticar os conceitos de fun\u00e7\u00f5es e condicionais em Assembly. Teremos exerc\u00edcios simples de cada assunto e no fim alguns exerc\u00edcios para entrega que juntam coisas diferentes.","title":"06 - Condicionais e fun\u00e7\u00f5es"},{"location":"aulas/06-condicionais-funcoes/#funcoes-e-aritmetica-com-lea","text":"Todos os exerc\u00edcios da revis\u00e3o ser\u00e3o feitos com o arquivo exemplo1 (compilado a partir de exemplo1.c ). Vamos examinar tanto a fun\u00e7\u00e3o main quanto a fun\u00e7\u00e3o exemplo1 . Compile com: $ gcc -Og -Wall -std = c99 exemplo1.c -o exemplo1","title":"Fun\u00e7\u00f5es e aritm\u00e9tica com LEA"},{"location":"aulas/06-condicionais-funcoes/#chamadas-de-funcoes","text":"As chamadas de fun\u00e7\u00e3o s\u00e3o feitas usando a seguinte ordem para os argumentos inteiros: %rdi %rsi %rdx %rcx %r8 %r9 Esta ordem nunca muda . Veja abaixo um exemplo de chamada de fun\u00e7\u00e3o tirado do main de exemplo1 . 0 x01163 <+ 8 > : mov $0x6 , %r9d 0 x01169 <+ 14 > : mov $0x5 , %r8d 0 x0116f <+ 20 > : mov $0x4 , %ecx 0 x01174 <+ 25 > : mov $0x3 , %edx 0 x01179 <+ 30 > : mov $0x2 , %esi 0 x0117e <+ 35 > : mov $0x1 , %edi 0 x01183 <+ 40 > : call 0x1149 < exemplo1 > 0 x01188 <+ 45 > : lea 0xa ( %rax ), %esi Pergunta O valor do primeiro argumento da fun\u00e7\u00e3o \u00e9 6 1 Answer A ordem dos par\u00e2metros segue \u00e9 sempre a mesma vista na aula 04 . Mesmo que as instru\u00e7\u00f5es estejam em ordem diferente, %edi (ou uma de suas partes) \u00e9 sempre o primeiro par\u00e2metro. Exercise A instru\u00e7\u00e3o call realiza chamadas de fun\u00e7\u00e3o. Traduza a chamada de fun\u00e7\u00e3o acima para C . Answer exemplo1(1, 2, 3, 4, 5, 6) Vamos agora analisar o c\u00f3digo de exemplo1 : Dump of assembler code for function exemplo1 : 0 x01149 <+ 0 > : endbr64 0x0114d <+ 4 > : add %esi , %edi 0 x0114f <+ 6 > : add %edx , %edi 0 x01151 <+ 8 > : add %ecx , %edi 0 x01153 <+ 10 > : add %r8d , %edi 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax 0 x0115a <+ 17 > : ret Exercise Quantos par\u00e2metros a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Ela retorna algum valor? Se sim, qual seu tipo? Answer Pelos registradores utilizados, percebemos que a fun\u00e7\u00e3o tem seis par\u00e2metros, todos int . O retorno tamb\u00e9m \u00e9 int . Exercise Declare a fun\u00e7\u00e3o acima com base na sua resposta anterior. Answer int exemplo1(int a, int b, int c, int d, int e, int f); Exercise O que faz o conjunto de instru\u00e7\u00f5es add nas linhas +4 at\u00e9 +10 ? Escreva uma express\u00e3o em C equivalente. Answer Ela soma os primeiros 5 argumentos: a + b + c + e . Vemos na linha exemplo1+13 que colocamos um valor no registrador %eax e depois finalizamos a fun\u00e7\u00e3o usando ret . Este \u00e9 o segundo ponto que nunca muda: o valor de retorno de toda fun\u00e7\u00e3o \u00e9 colocado no registrador %rax (ou uma de suas partes menores). Neste exemplo, a instru\u00e7\u00e3o usada foi o LEA que relembraremos na se\u00e7\u00e3o a seguir.","title":"Chamadas de fun\u00e7\u00f5es"},{"location":"aulas/06-condicionais-funcoes/#operacoes-aritmeticas-usando-lea","text":"Se usada de maneira literal, a instru\u00e7\u00e3o LEA (Load Effective Address) serve para calcular o endere\u00e7o de uma vari\u00e1vel local e \u00e9 equivalente ao operador & em C . Por\u00e9m, ela \u00e9 frequentemente \"abusada\" para fazer aritm\u00e9tica. Um ponto importante quando usamos LEA \u00e9 que todos os operandos s\u00e3o registradores de 64 bits. Regra geral Se LEA for usada com o registrador %rsp ent\u00e3o ela sempre representa o operador & Se os registradores envolvidos foram usados como n\u00fameros inteiros em instru\u00e7\u00f5es anteriores, ent\u00e3o ela representa uma conta com os valores dos registradores. Vejamos o exemplo da fun\u00e7\u00e3o exemplo1 acima: lea ( %rdi , %r9 , 1 ), %eax 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax No exemplo acima LEA \u00e9 usada para fazer aritm\u00e9tica. Sabemos disso pois, na chamada traduzida na parte anterior, elas recebem n\u00fameros inteiros ( %r9d = 6 e %edi = 1 mais o resultado de sucessivas somas). Seu primeiro argumento segue a seguinte l\u00f3gica C ( %R1 , %R2 , S ) C \u00e9 uma constante %R1 \u00e9 um registrador %R2 \u00e9 um registrador (pode ser igual a %R1 ) S \u00e9 1, 2, 4 ou 8 (todos os tamanhos poss\u00edveis de registradores inteiros) A opera\u00e7\u00e3o acima calcula C + %R1 + (%R2 * S) . A opera\u00e7\u00e3o LEA nunca acessa a mem\u00f3ria , apenas move o resultado deste c\u00e1lculo para o registrador destino. Qualquer outra opera\u00e7\u00e3o que use a sintaxe acima est\u00e1 fazendo um acesso a mem\u00f3ria. LEA \u00e9 a \u00fanica exce\u00e7\u00e3o! Exercise Traduza a opera\u00e7\u00e3o abaixo para C 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax Answer Supondo que aux = a+b+c+d+e j\u00e1 foi calculado com o uso das instru\u00e7\u00f5es ADD , ent\u00e3o o LEA calcula aux + f*1 . Exercise Com estas informa\u00e7\u00f5es em m\u00e3os, traduza exemplo1 para C Dump of assembler code for function exemplo1 : 0 x01149 <+ 0 > : endbr64 0x0114d <+ 4 > : add %esi , %edi 0 x0114f <+ 6 > : add %edx , %edi 0 x01151 <+ 8 > : add %ecx , %edi 0 x01153 <+ 10 > : add %r8d , %edi 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax 0 x0115a <+ 17 > : ret Answer Confira no arquivo exemplo1.c","title":"Opera\u00e7\u00f5es aritm\u00e9ticas usando LEA"},{"location":"aulas/06-condicionais-funcoes/#retorno-de-funcoes","text":"Vamos terminar nossa revis\u00e3o analisando novamente a chamada de exemplo1 no main : 0 x01163 <+ 8 > : mov $0x6 , %r9d 0 x01169 <+ 14 > : mov $0x5 , %r8d 0 x0116f <+ 20 > : mov $0x4 , %ecx 0 x01174 <+ 25 > : mov $0x3 , %edx 0 x01179 <+ 30 > : mov $0x2 , %esi 0 x0117e <+ 35 > : mov $0x1 , %edi 0 x01183 <+ 40 > : call 0x1149 < exemplo1 > 0 x01188 <+ 45 > : lea 0xa ( %rax ), %esi Anteriormente j\u00e1 vimos que o call e os mov s acima fazem a chamada exemplo1(1,2,3,4,5,6) em C . A linha de baixo realiza uma opera\u00e7\u00e3o aritm\u00e9tica com %rax . Exercise Considerando que %rax armazena o valor de retorno de uma fun\u00e7\u00e3o, qual seria a tradu\u00e7\u00e3o para C do bloco de c\u00f3digo acima? Answer int esi = exemplo1(1, 2, 3, 4, 5, 6) + 10;","title":"Retorno de fun\u00e7\u00f5es"},{"location":"aulas/06-condicionais-funcoes/#exercicios-combinados","text":"Warning Todos os exerc\u00edcios desta se\u00e7\u00e3o s\u00e3o para entrega. Voc\u00eas podem se conversar para faz\u00ea-los, mas cada um deve criar sua pr\u00f3pria solu\u00e7\u00e3o do zero. Todos os exerc\u00edcios j\u00e1 est\u00e3o dispon\u00edveis no seu reposit\u00f3rio de entregas da disciplina em atv/04-condicionais-funcoes . Leia o README dentro da pasta para mais informa\u00e7\u00f5es.","title":"Exerc\u00edcios combinados"},{"location":"aulas/06-condicionais-funcoes/#funcao-ex1-aritmetica-e-expressoes-booleanas","text":"Dump of assembler code for function ex1 : 0 x000 <+ 0 > : endbr64 0 x004 <+ 4 > : lea ( %rdi , %rsi , 1 ), %rax 0 x008 <+ 8 > : lea ( %rax , %rdx , 4 ), %rcx 0 x00c <+ 12 > : imul %rdi , %rdi 0 x010 <+ 16 > : lea ( %rdi , %rsi , 2 ), %rax 0 x014 <+ 20 > : add %rax , %rdx 0 x017 <+ 23 > : cmp %rdx , %rcx 0 x01a <+ 26 > : setge %al 0 x01d <+ 29 > : movzbl %al , %eax 0 x020 <+ 32 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Declare a fun\u00e7\u00e3o abaixo. Exercise As instru\u00e7\u00f5es LEA acima representam opera\u00e7\u00f5es aritm\u00e9ticas ou a opera\u00e7\u00e3o endere\u00e7o de & ? Como voc\u00ea fez esta identifica\u00e7\u00e3o? . Exercise Traduza as opera\u00e7\u00f5es das linhas ex1+0 at\u00e9 ex1+16 para C Exercise Nas linhas ex1+23 e ex1+26 \u00e9 feita uma compara\u00e7\u00e3o. Qual e entre quais registradores? Onde \u00e9 armazenado este resultado? Exercise O qu\u00ea faz a instru\u00e7\u00e3o movzbl em ex1+29 ? Juntando com a resposta da pergunta acima, traduza as instru\u00e7\u00f5es ex1+23 at\u00e9 ex1+32 para C . Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes.","title":"Fun\u00e7\u00e3o ex1: Aritm\u00e9tica e Express\u00f5es booleanas."},{"location":"aulas/06-condicionais-funcoes/#funcao-ex2-chamadas-de-funcoes-e-condicionais","text":"Quando analisar o c\u00f3digo do ex2 no gdb, utilize o arquivo ex2_ref para visualizar corretamente as chamadas de fun\u00e7\u00f5es. Seria uma boa tamb\u00e9m consultar as relocation entries no terminal com objdump -r ex2.o . Dump of assembler code for function ex2 : 0 x01132 <+ 0 > : endbr64 0 x01136 <+ 4 > : push %rbx 0 x01137 <+ 5 > : mov %rdi , %rbx 0 x0113a <+ 8 > : mov %rsi , %rdi 0 x0113d <+ 11 > : call 0x1129 < vezes2 > 0 x01142 <+ 16 > : cmp %rbx , %rax 0 x01145 <+ 19 > : jle 0x114a < ex2 + 24 > 0 x01147 <+ 21 > : add %rbx , %rbx 0 x0114a <+ 24 > : add %rbx , %rax 0 x0114d <+ 27 > : pop %rbx 0 x0114e <+ 28 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais s\u00e3o seus tipos? Declare-a abaixo. Vamos come\u00e7ar trabalhando na linha ex2+11 , na instru\u00e7\u00e3o call vezes2 . A chamada necessita usar o registrador %rdi , mas ele cont\u00e9m o primeiro argumento de ex2 . Exercise Em qual registrador \u00e9 guardado o primeiro argumento de ex2 ? Isso \u00e9 feito antes da chamada call . Exercise Qual vari\u00e1vel \u00e9 passada como argumento para a fun\u00e7\u00e3o vezes2 ? Exercise Escreva abaixo a invoca\u00e7\u00e3o de vezes2 . Voc\u00ea deve ter notado as instru\u00e7\u00f5es push/pop %rbx no come\u00e7o/fim da fun\u00e7\u00e3o. Toda fun\u00e7\u00e3o pode usar os registradores de argumentos (vistos na parte 1) e o de valor de retorno como quiserem. Se precisarem mexer nos outros registradores a pr\u00e1tica \u00e9 salv\u00e1-los na pilha no come\u00e7o da fun\u00e7\u00e3o e restaur\u00e1-los no fim. Assim n\u00e3o importa o que a fun\u00e7\u00e3o fa\u00e7a, para a fun\u00e7\u00e3o chamadora \u00e9 como se n\u00e3o houvesse havido nenhuma modifica\u00e7\u00e3o nos outros registradores. Vamos agora olhar a condicional na linha ex2+16 . Exercise Ap\u00f3s a chamada call , qual o conte\u00fado de %rax ? Exercise Juntando suas respostas nas quest\u00f5es de cima, qual \u00e9 a compara\u00e7\u00e3o feita nas linhas ex2+16, ex2+19 ? Exercise Com essas informa\u00e7\u00f5es em m\u00e3os, fa\u00e7a uma tradu\u00e7\u00e3o do c\u00f3digo acima para C usando somente if+goto . Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes.","title":"Fun\u00e7\u00e3o ex2: Chamadas de fun\u00e7\u00f5es e Condicionais."},{"location":"aulas/06-condicionais-funcoes/#funcao-ex3-ponteiros-e-expressoes-booleanas","text":"Dump of assembler code for function ex3 : 0 x000 <+ 0 > : endbr64 0 x004 <+ 4 > : cmp %rsi , %rdi 0 x007 <+ 7 > : setl %al 0 x00a <+ 10 > : movzbl %al , %eax 0 x00d <+ 13 > : mov %eax ,( %rdx ) 0 x00f <+ 15 > : sete %al 0 x012 <+ 18 > : movzbl %al , %eax 0 x015 <+ 21 > : mov %eax ,( %rcx ) 0 x017 <+ 23 > : setg %al 0 x01a <+ 26 > : movzbl %al , %eax 0 x01d <+ 29 > : mov %eax ,( %r8 ) 0 x020 <+ 32 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? De quais tipos? Declare-a abaixo. Exercise A fun\u00e7\u00e3o acima faz v\u00e1rias compara\u00e7\u00f5es. Liste quais e entre quais argumentos. Exercise Onde \u00e9 armazenado o resultado de cada compara\u00e7\u00e3o? Exercise Com base em suas respostas acima, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha da fun\u00e7\u00e3o acima. Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes.","title":"Fun\u00e7\u00e3o ex3: Ponteiros e Express\u00f5es booleanas."},{"location":"aulas/06-condicionais-funcoes/#funcao-ex4-ponteiros-e-expressoes-booleanas","text":"Dump of assembler code for function ex4 : 0 x00a <+ 0 > : endbr64 0x00e <+ 4 > : cmp $0x11 , %di 0 x012 <+ 8 > : jle 0x21 < ex4 + 23 > 0 x014 <+ 10 > : sub $0x41 , %esi 0 x017 <+ 13 > : cmp $0x1 , %sil 0 x01b <+ 17 > : ja 0x29 < ex4 + 31 > 0 x01d <+ 19 > : lea -0 x11 ( %rdi ), %eax 0 x020 <+ 22 > : ret 0x021 <+ 23 > : mov $0x12 , %eax 0 x026 <+ 28 > : sub %edi , %eax 0 x028 <+ 30 > : ret 0x029 <+ 31 > : mov $0xffffffff , %eax 0 x02e <+ 36 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? De quais tipos? Declare-a abaixo. Exercise A fun\u00e7\u00e3o acima faz v\u00e1rias compara\u00e7\u00f5es. Liste quais e entre quais argumentos. Exercise Onde \u00e9 armazenado o resultado de cada compara\u00e7\u00e3o? Exercise Com base em suas respostas acima, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha da fun\u00e7\u00e3o acima. Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes.","title":"Fun\u00e7\u00e3o ex4: Ponteiros e Express\u00f5es booleanas."},{"location":"aulas/07-loops/","text":"07 - Loops \u00b6 Arquivo ex1 \u00b6 Utilize como base o c\u00f3digo assembly abaixo (arquivo ex1 ) e responda os itens. Dump of assembler code for function soma_2n : 0 x066a <+ 0 > : mov $0x1 , %eax 0 x066f <+ 5 > : jmp 0x676 < soma_2n + 12 > 0 x0671 <+ 7 > : shr %edi 0 x0673 <+ 9 > : add $0x1 , %eax 0 x0676 <+ 12 > : cmp $0x1 , %edi 0 x0679 <+ 15 > : ja 0x671 < soma_2n + 7 > 0 x067b <+ 17 > : repz retq Exercise Localize no c\u00f3digo acima as instru\u00e7\u00f5es de saltos ( jmp ou condicionais j* ). Desenhe setas indicando para qual linha do c\u00f3digo elas pulam. Answer H\u00e1 um salto de soma_2n <+5> para soma_2n <+12> e outro de soma_2n <+15> para soma_2n <+7> Exercise Analise o fluxo de saltos do seu c\u00f3digo. Existe um loop? Entre quais linhas? Answer O loop ocorre entre as linhas +5 e +15 . Exercise Qual \u00e9 a condi\u00e7\u00e3o do loop acima? Ou seja, qual condi\u00e7\u00e3o precisa ser verdade para que o loop continue rodando ? %edi > 1 %edi < 1 %edi > 0 %eax > 1 Answer Sempre comparamos o segundo em rela\u00e7\u00e3o ao primeiro. Logo, fazemos %edi > 1 . A instru\u00e7\u00e3o ja representa a compara\u00e7\u00e3o jump above , que \u00e9 uma compara\u00e7\u00e3o de > feita entre vari\u00e1veis unsigned Exercise Com base na sua resposta acima, como voc\u00ea escreveria esse loop como um while ? Answer Considerando que o primeiro argumento da fun\u00e7\u00e3o se chama int arg1 , seria while(arg1 > 1) . Exercise Comece fazendo uma vers\u00e3o C usando somente if-goto Answer int soma_2n ( unsigned int a ) { int res = 1 ; goto verifica ; faz_algo : a = a >> 1 ; res += 1 ; verifica : if ( a > 1 ) { goto faz_algo ; } return res ; } Exercise Transforme a constru\u00e7\u00e3o que voc\u00ea fez acima em um c\u00f3digo usando while . Answer int soma_2n ( unsigned int a ) { int res = 1 ; while ( a > 1 ) { a = a / 2 ; res ++ ; } return res ; } Exerc\u00edcios para entrega \u00b6 Vamos agora exercitar o que vimos na aula expositiva. Os exerc\u00edcios abaixo est\u00e3o no reposit\u00f3rio de atividades e as perguntas no handout tem o objetivo de ajudar a compreender c\u00f3digos cada vez mais complexos. Aten\u00e7\u00e3o! Antes de continuar, d\u00ea um git pull em seu reposit\u00f3rio de atividades e leia o README dispon\u00edvel dentro da pasta da atividade! Dicas! Antes de fazer disas , sempre d\u00ea um info functions e info variables para conhecer o que temos em cada arquivo. Nem sempre encontrar\u00e1 algo muito valioso, mas \u00e9 bom verificar! Arquivo ex2.o \u00b6 Leia o c\u00f3digo assembly abaixo e responda. Dump of assembler code for function soma_n : 0 x000 <+ 0 > : endbr64 0x004 <+ 4 > : mov $0x0 , %eax 0 x009 <+ 9 > : mov $0x0 , %edx 0 x00e <+ 14 > : cmp %edi , %eax 0 x010 <+ 16 > : jge 0x1d < soma_n + 29 > 0 x012 <+ 18 > : movslq %eax , %rcx 0 x015 <+ 21 > : add %rcx , %rdx 0 x018 <+ 24 > : add $0x1 , %eax 0 x01b <+ 27 > : jmp 0xe < soma_n + 14 > 0 x01d <+ 29 > : mov %rdx , %rax 0 x020 <+ 32 > : ret Exercise Desenhe as flechas indicando o destino de cada instru\u00e7\u00e3o de pulo ( jmp ou j* ). Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Escreva abaixo o cabe\u00e7alho da fun\u00e7\u00e3o soma_n . Dica : procure por registradores que s\u00e3o lidos antes de serem escritos. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Fa\u00e7a a tradu\u00e7\u00e3o do c\u00f3digo acima para C usando somente if-goto Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Converta o c\u00f3digo acima para uma vers\u00e3o leg\u00edvel em C . Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Arquivo ex3.o \u00b6 Dump of assembler code for function ex3 : 0 x000 <+ 0 > : endbr64 0x004 <+ 4 > : mov $0x0 , %ecx 0 x009 <+ 9 > : mov $0x0 , %r8d 0 x00f <+ 15 > : jmp 0x15 < ex3 + 21 > 0 x011 <+ 17 > : add $0x1 , %rcx 0 x015 <+ 21 > : cmp %rdi , %rcx 0 x018 <+ 24 > : jge 0x2c < ex3 + 44 > 0 x01a <+ 26 > : mov %rcx , %rax 0 x01d <+ 29 > : cqto 0x01f <+ 31 > : idiv %rsi 0 x022 <+ 34 > : test %rdx , %rdx 0 x025 <+ 37 > : jne 0x11 < ex3 + 17 > 0 x027 <+ 39 > : add %rcx , %r8 0 x02a <+ 42 > : jmp 0x11 < ex3 + 17 > 0 x02c <+ 44 > : mov %r8 , %rax 0 x02f <+ 47 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Dica : n\u00e3o se esque\u00e7a de buscar por registradores que s\u00e3o lidos antes de serem escritos. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise A fun\u00e7\u00e3o retorna algum valor? Se sim, qual seu tipo? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise A fun\u00e7\u00e3o acima combina loops e condicionais. Desenhe setas para onde as instru\u00e7\u00f5es de jmp apontam. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Com base no exerc\u00edcio anterior, entre quais linhas o loop ocorre? E a condicional? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise O loop acima tem uma vari\u00e1vel contadora. Ela est\u00e1 em qual registrador? Qual seu tipo? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Revise o funcionamento da instru\u00e7\u00e3o idiv . Em qual registrador \u00e9 armazenado o resultado da divis\u00e3o? E o resto? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Qual a condi\u00e7\u00e3o testada na condicional? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Escreva uma vers\u00e3o do c\u00f3digo acima usando somente if-goto . Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Escreva uma vers\u00e3o leg\u00edvel do c\u00f3digo acima. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores!","title":"07 - Loops"},{"location":"aulas/07-loops/#07-loops","text":"","title":"07 - Loops"},{"location":"aulas/07-loops/#arquivo-ex1","text":"Utilize como base o c\u00f3digo assembly abaixo (arquivo ex1 ) e responda os itens. Dump of assembler code for function soma_2n : 0 x066a <+ 0 > : mov $0x1 , %eax 0 x066f <+ 5 > : jmp 0x676 < soma_2n + 12 > 0 x0671 <+ 7 > : shr %edi 0 x0673 <+ 9 > : add $0x1 , %eax 0 x0676 <+ 12 > : cmp $0x1 , %edi 0 x0679 <+ 15 > : ja 0x671 < soma_2n + 7 > 0 x067b <+ 17 > : repz retq Exercise Localize no c\u00f3digo acima as instru\u00e7\u00f5es de saltos ( jmp ou condicionais j* ). Desenhe setas indicando para qual linha do c\u00f3digo elas pulam. Answer H\u00e1 um salto de soma_2n <+5> para soma_2n <+12> e outro de soma_2n <+15> para soma_2n <+7> Exercise Analise o fluxo de saltos do seu c\u00f3digo. Existe um loop? Entre quais linhas? Answer O loop ocorre entre as linhas +5 e +15 . Exercise Qual \u00e9 a condi\u00e7\u00e3o do loop acima? Ou seja, qual condi\u00e7\u00e3o precisa ser verdade para que o loop continue rodando ? %edi > 1 %edi < 1 %edi > 0 %eax > 1 Answer Sempre comparamos o segundo em rela\u00e7\u00e3o ao primeiro. Logo, fazemos %edi > 1 . A instru\u00e7\u00e3o ja representa a compara\u00e7\u00e3o jump above , que \u00e9 uma compara\u00e7\u00e3o de > feita entre vari\u00e1veis unsigned Exercise Com base na sua resposta acima, como voc\u00ea escreveria esse loop como um while ? Answer Considerando que o primeiro argumento da fun\u00e7\u00e3o se chama int arg1 , seria while(arg1 > 1) . Exercise Comece fazendo uma vers\u00e3o C usando somente if-goto Answer int soma_2n ( unsigned int a ) { int res = 1 ; goto verifica ; faz_algo : a = a >> 1 ; res += 1 ; verifica : if ( a > 1 ) { goto faz_algo ; } return res ; } Exercise Transforme a constru\u00e7\u00e3o que voc\u00ea fez acima em um c\u00f3digo usando while . Answer int soma_2n ( unsigned int a ) { int res = 1 ; while ( a > 1 ) { a = a / 2 ; res ++ ; } return res ; }","title":"Arquivo ex1"},{"location":"aulas/07-loops/#exercicios-para-entrega","text":"Vamos agora exercitar o que vimos na aula expositiva. Os exerc\u00edcios abaixo est\u00e3o no reposit\u00f3rio de atividades e as perguntas no handout tem o objetivo de ajudar a compreender c\u00f3digos cada vez mais complexos. Aten\u00e7\u00e3o! Antes de continuar, d\u00ea um git pull em seu reposit\u00f3rio de atividades e leia o README dispon\u00edvel dentro da pasta da atividade! Dicas! Antes de fazer disas , sempre d\u00ea um info functions e info variables para conhecer o que temos em cada arquivo. Nem sempre encontrar\u00e1 algo muito valioso, mas \u00e9 bom verificar!","title":"Exerc\u00edcios para entrega"},{"location":"aulas/07-loops/#arquivo-ex2o","text":"Leia o c\u00f3digo assembly abaixo e responda. Dump of assembler code for function soma_n : 0 x000 <+ 0 > : endbr64 0x004 <+ 4 > : mov $0x0 , %eax 0 x009 <+ 9 > : mov $0x0 , %edx 0 x00e <+ 14 > : cmp %edi , %eax 0 x010 <+ 16 > : jge 0x1d < soma_n + 29 > 0 x012 <+ 18 > : movslq %eax , %rcx 0 x015 <+ 21 > : add %rcx , %rdx 0 x018 <+ 24 > : add $0x1 , %eax 0 x01b <+ 27 > : jmp 0xe < soma_n + 14 > 0 x01d <+ 29 > : mov %rdx , %rax 0 x020 <+ 32 > : ret Exercise Desenhe as flechas indicando o destino de cada instru\u00e7\u00e3o de pulo ( jmp ou j* ). Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Escreva abaixo o cabe\u00e7alho da fun\u00e7\u00e3o soma_n . Dica : procure por registradores que s\u00e3o lidos antes de serem escritos. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Fa\u00e7a a tradu\u00e7\u00e3o do c\u00f3digo acima para C usando somente if-goto Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Converta o c\u00f3digo acima para uma vers\u00e3o leg\u00edvel em C . Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores!","title":"Arquivo ex2.o"},{"location":"aulas/07-loops/#arquivo-ex3o","text":"Dump of assembler code for function ex3 : 0 x000 <+ 0 > : endbr64 0x004 <+ 4 > : mov $0x0 , %ecx 0 x009 <+ 9 > : mov $0x0 , %r8d 0 x00f <+ 15 > : jmp 0x15 < ex3 + 21 > 0 x011 <+ 17 > : add $0x1 , %rcx 0 x015 <+ 21 > : cmp %rdi , %rcx 0 x018 <+ 24 > : jge 0x2c < ex3 + 44 > 0 x01a <+ 26 > : mov %rcx , %rax 0 x01d <+ 29 > : cqto 0x01f <+ 31 > : idiv %rsi 0 x022 <+ 34 > : test %rdx , %rdx 0 x025 <+ 37 > : jne 0x11 < ex3 + 17 > 0 x027 <+ 39 > : add %rcx , %r8 0 x02a <+ 42 > : jmp 0x11 < ex3 + 17 > 0 x02c <+ 44 > : mov %r8 , %rax 0 x02f <+ 47 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Dica : n\u00e3o se esque\u00e7a de buscar por registradores que s\u00e3o lidos antes de serem escritos. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise A fun\u00e7\u00e3o retorna algum valor? Se sim, qual seu tipo? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise A fun\u00e7\u00e3o acima combina loops e condicionais. Desenhe setas para onde as instru\u00e7\u00f5es de jmp apontam. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Com base no exerc\u00edcio anterior, entre quais linhas o loop ocorre? E a condicional? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise O loop acima tem uma vari\u00e1vel contadora. Ela est\u00e1 em qual registrador? Qual seu tipo? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Revise o funcionamento da instru\u00e7\u00e3o idiv . Em qual registrador \u00e9 armazenado o resultado da divis\u00e3o? E o resto? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Qual a condi\u00e7\u00e3o testada na condicional? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Escreva uma vers\u00e3o do c\u00f3digo acima usando somente if-goto . Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Escreva uma vers\u00e3o leg\u00edvel do c\u00f3digo acima. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores!","title":"Arquivo ex3.o"},{"location":"aulas/08-variaveis-locais/","text":"08 - Vari\u00e1veis locais \u00b6 Como visto na expositiva, vari\u00e1veis locais s\u00e3o armazenadas na pilha. O topo da pilha \u00e9 armazenado em %rsp e ela cresce para baixo, ou seja, ao empilhar um dado o valor de %rsp diminui e ao desempilhar seu valor aumenta. O compilador faz todo o poss\u00edvel para usar somente os registradores, por\u00e9m em alguns casos \u00e9 necess\u00e1rio guardar a vari\u00e1vel na mem\u00f3ria. Isso ocorre, em geral, quando usamos & para computar o endere\u00e7o de uma vari\u00e1vel. O exemplo mais comum nos c\u00f3digos que j\u00e1 escrevemos \u00e9 na leitura de valores usando scanf . Exemplo guiado \u00b6 Fun\u00e7\u00f5es que guardam vari\u00e1veis na pilha seguem um padr\u00e3o facilmente identific\u00e1vel. Primeiro elas subtraem um valor da pilha ( 0x10 no exemplo abaixo) correspondente ao tamanho total de todas as vari\u00e1veis usadas. Depois temos v\u00e1rias instru\u00e7\u00f5es usando endere\u00e7os relativos a %rsp e por fim devolvemos o espa\u00e7o usado somando 0x10 de volta a %rsp . sub $0x10 , %rsp . . . // c\u00f3digo da fun\u00e7\u00e3o aqui! movl 0x8 ( %rsp ), %eax mov %eax , %edx addl 0xc ( %rsp ), %edx . . . // fun\u00e7\u00e3o continua add $0x10 , %rsp ret No exemplo acima, temos duas vari\u00e1veis locais: 0x8(%rsp) e 0xc(rsp) . Cada uma \u00e9 identificada no c\u00f3digo Assembly pelo endere\u00e7o em que est\u00e1 posicionada na pilha. Logo, todo deslocamento em rela\u00e7\u00e3o a %rsp indica um acesso a vari\u00e1vel local , sendo que pode ser um acesso de leitura e escrita (usando MOV , por exemplo) ou da opera\u00e7\u00e3o endere\u00e7o de & (usando LEA ). Conseguimos identificar que seus tamanhos s\u00e3o int por duas raz\u00f5es: elas aparecem em instru\u00e7\u00f5es junto com registradores de 4 bytes ( %eax e %edx ) as instru\u00e7\u00f5es movl e addl tem o sufixo l , que indica que os dados tratados tem tamanho 4 bytes. Os sufixos suportados s\u00e3o: b - 1 byte w - 2 bytes l - 4 bytes q - 8 bytes Qualquer raz\u00e3o acima \u00e9 suficiente para identificar os tipos das vari\u00e1veis locais. Importante Novamente, nem toda instru\u00e7\u00e3o em Assembly pode ser representada em C . As instru\u00e7\u00f5es sub 0x10, %rsp e add 0x10, %rsp representam a cria\u00e7\u00e3o de vari\u00e1veis locais na pilha e n\u00e3o tem equivalente em C . Simplesmente ignoramos elas e usamos as vari\u00e1veis locais no c\u00f3digo. Revis\u00e3o de vari\u00e1veis globais e strings constantes \u00b6 Antes de iniciar o pr\u00f3ximo exerc\u00edcio vamos revisar como vari\u00e1veis locais, globais e strings constantes s\u00e3o acessadas em c\u00f3digo assembly. A imagem abaixo exemplifica os tr\u00eas casos: Vari\u00e1veis locais : s\u00e3o acessadas com lea (para & - endere\u00e7o de) ou mov (para leituras e escritas) relativos a %rsp Globais e strings constantes : s\u00e3o acessadas usando a nota\u00e7\u00e3o 0xYY(%rip) , sendo que o valor 0xYY muda a cada acesso. No caso das strings, o acesso a estes endere\u00e7os \u00e9 somente leitura. O endere\u00e7amento relativo a %rip leva em conta a posi\u00e7\u00e3o relativa entre a instru\u00e7\u00e3o atual e o endere\u00e7o de mem\u00f3ria do dado. Na imagem acima est\u00e3o destacadas duas instru\u00e7\u00f5es lea que acessam o mesmo dado. Como o %rip (ponteiro para a pr\u00f3xima instru\u00e7\u00e3o) \u00e9 diferente precisamos de deslocamentos diferentes para acessar o mesmo dado. Dica : o gdb coloca o endere\u00e7o calculado ao lado das instru\u00e7\u00f5es deste tipo. Exercise \u00c9 poss\u00edvel que o lea abaixo seja aritm\u00e9tico? Por que? lea 0x8 ( %rsp ), %rdx Answer N\u00e3o! O registrador %rsp \u00e9 especial e sempre guarda o endere\u00e7o do topo da pilha de chamadas. Nesse espa\u00e7o de mem\u00f3ria guardamos todas vari\u00e1veis que n\u00e3o podem ser alocadas em um registrador. Arquivo ex2 \u00b6 O c\u00f3digo abaixo ( ex2 ) utiliza vari\u00e1veis locais. Dump of assembler code for function func1 : 0 x05fe <+ 0 > : sub $0x10 , %rsp 0 x0602 <+ 4 > : movl $0xa , 0xc ( %rsp ) 0 x060a <+ 12 > : movl $0xb , 0x8 ( %rsp ) 0 x0612 <+ 20 > : lea 0xc ( %rsp ), %rdi 0 x0617 <+ 25 > : callq 0x5fa < func2 > 0 x061c <+ 30 > : addl $0x1 , 0x8 ( %rsp ) 0 x0621 <+ 35 > : lea 0x8 ( %rsp ), %rdi 0 x0626 <+ 40 > : callq 0x5fa < func2 > 0 x062b <+ 45 > : add $0x10 , %rsp 0 x062f <+ 49 > : retq Vamos come\u00e7ar analisando as tr\u00eas primeiras linhas do programa. Exercise Quanto espa\u00e7o (em bytes) \u00e9 reservado na pilha? 10 16 20 8 Answer Ao executar sub $0x10,%rsp criamos um espa\u00e7o de 16 bytes ( 0x10 ) na pilha. Note que as constantes sempre aparecem em hexadecimal. Existem v\u00e1rios momentos no c\u00f3digo que lemos/escrevemos em endere\u00e7os relativos a %rsp . Cada deslocamento representa uma vari\u00e1vel local que est\u00e1 armazenada na mem\u00f3ria. Exercise Quantas vari\u00e1veis s\u00e3o inicializadas e quais seus tamanhos? 2 - int 2 - long 1 - int 1 - long Answer S\u00e3o duas vari\u00e1veis int : uma em 0xc(%rsp) e outra em 0x8(%rsp) . Exercise Identifique onde as vari\u00e1veis locais encontradas s\u00e3o usadas. D\u00ea um nome para cada uma delas. Answer Vou utilizar os identificadores e tipos int a e int b . Exercise Os lea das linhas +20 e +35 podem ser aritm\u00e9ticos? SIM N\u00c3O Answer N\u00e3o s\u00e3o aritm\u00e9ticos, portanto representam a opera\u00e7\u00e3o endere\u00e7o de & . Exercise Com base em sua resposta acima, traduza as chamadas de fun\u00e7\u00e3o que ocorrem nas linhas +25 e +40 . Answer Na linha +25 ocorre a chamada func2(&a) . J\u00e1 na linha +40 a chamada \u00e9 func2(&b) Exercise Traduza o programa acima para C Answer void func2 ( int * a ) { * a += 1 ; } void func1 () { int a = 10 ; int b = 11 ; func2 ( & a ); b ++ ; func2 ( & b ); } Arquivo ex3 \u00b6 No exerc\u00edcio anterior vimos como passar vari\u00e1veis por refer\u00eancia para outras fun\u00e7\u00f5es. Agora veremos como trabalhar com scanf . Veja abaixo a fun\u00e7\u00e3o main do execut\u00e1vel ex3 . Abra este arquivo usando o gdb e siga os exerc\u00edcios. Dump of assembler code for function main : 0 x1149 <+ 0 > : sub $0x18 , %rsp 0 x114d <+ 4 > : lea 0xc ( %rsp ), %rsi 0 x1152 <+ 9 > : lea 0xeab ( %rip ), %rdi # 0x2004 0 x1159 <+ 16 > : mov $0x0 , %eax 0 x115e <+ 21 > : callq 0x1040 < __isoc99_scanf@plt > 0 x1163 <+ 26 > : cmpl $0x0 , 0xc ( %rsp ) 0 x1168 <+ 31 > : js 0x1180 < main + 55 > 0 x116a <+ 33 > : lea 0xe9f ( %rip ), %rdi # 0x2010 0 x1171 <+ 40 > : callq 0x1030 < puts@plt > 0 x1176 <+ 45 > : mov $0x0 , %eax 0 x117b <+ 50 > : add $0x18 , %rsp 0 x117f <+ 54 > : retq 0 x1180 <+ 55 > : lea 0xe80 ( %rip ), %rdi # 0x2007 0 x1187 <+ 62 > : callq 0x1030 < puts@plt > 0 x118c <+ 67 > : jmp 0x1176 < main + 45 > Exercise Vamos come\u00e7ar procurando por vari\u00e1veis locais que estejam na pilha. Quanto espa\u00e7o \u00e9 reservado para elas? Liste abaixo as que voc\u00ea encontrou e d\u00ea um nome para cada uma. Dica : todo acesso relativo a %rsp representa um acesso a vari\u00e1vel local. Answer Est\u00e3o sendo reservados 24 bytes na pilha. Temos uma vari\u00e1vel local int n . Exercise A instru\u00e7\u00e3o call em main+21 \u00e9 um scanf . O primeiro argumento \u00e9 a string de formata\u00e7\u00e3o. Use o comando x do gdb para encontrar ela na mem\u00f3ria. Dica : usamos este comando nas aulas 02 e 03. Answer A string de formata\u00e7\u00e3o \u00e9 \"%d\". Exercise O segundo argumento do scanf \u00e9 o endere\u00e7o da vari\u00e1vel a ser preenchida. O endere\u00e7o de qual vari\u00e1vel local \u00e9 passado? Answer \u00c9 o endere\u00e7o da vari\u00e1vel correspondente a 0xc(%rsp) Exercise Reconstrua a chamada do scanf acima. Answer int a; // demos esse nome para todas ocorr\u00eancias de 0x(%rsp) scanf(\"%d\", &a); Com a chamada do scanf pronta, vamos analisar o restante do c\u00f3digo. Exercise Agora examinaremos as chamadas em main+40 e main+62 . Elas s\u00e3o para a fun\u00e7\u00e3o puts . Veja sua documenta\u00e7\u00e3o (procure por C puts .) e explique abaixo o qu\u00ea ela faz e quais s\u00e3o seus argumentos. Answer Escreve os m\u00faltiplos caracteres de uma string, seguido de \\n , na sa\u00edda padr\u00e3o Exercise Com base na explica\u00e7\u00e3o acima, escreva abaixo os argumentos passados para cada chamada. Answer S\u00e3o feitas duas chamadas: a primeira \u00e9 puts(\"Positivo\") e a segunda \u00e9 puts(\"Negativo\") . Exercise Traduza o c\u00f3digo acima para um vers\u00e3o em C . Answer #include <stdio.h> int main () { int n ; scanf ( \"%d\" , & n ); if ( n < 0 ) { printf ( \"Negativo \\n \" ); } else { printf ( \"Positivo! \\n \" ); } return 0 ; } Entrega \u00b6 Exerc\u00edcios 4 e 5 da atv6 dispon\u00edveis no seu reposit\u00f3rio de atividades privado. Aten\u00e7\u00e3o! Antes de continuar, d\u00ea um git pull em seu reposit\u00f3rio de atividades! Importante Sempre leia o README.md dispon\u00edvel na pasta da atividade. Ele tem informa\u00e7\u00f5es importantes para a execu\u00e7\u00e3o da atividade.","title":"08 - Vari\u00e1veis locais"},{"location":"aulas/08-variaveis-locais/#08-variaveis-locais","text":"Como visto na expositiva, vari\u00e1veis locais s\u00e3o armazenadas na pilha. O topo da pilha \u00e9 armazenado em %rsp e ela cresce para baixo, ou seja, ao empilhar um dado o valor de %rsp diminui e ao desempilhar seu valor aumenta. O compilador faz todo o poss\u00edvel para usar somente os registradores, por\u00e9m em alguns casos \u00e9 necess\u00e1rio guardar a vari\u00e1vel na mem\u00f3ria. Isso ocorre, em geral, quando usamos & para computar o endere\u00e7o de uma vari\u00e1vel. O exemplo mais comum nos c\u00f3digos que j\u00e1 escrevemos \u00e9 na leitura de valores usando scanf .","title":"08 - Vari\u00e1veis locais"},{"location":"aulas/08-variaveis-locais/#exemplo-guiado","text":"Fun\u00e7\u00f5es que guardam vari\u00e1veis na pilha seguem um padr\u00e3o facilmente identific\u00e1vel. Primeiro elas subtraem um valor da pilha ( 0x10 no exemplo abaixo) correspondente ao tamanho total de todas as vari\u00e1veis usadas. Depois temos v\u00e1rias instru\u00e7\u00f5es usando endere\u00e7os relativos a %rsp e por fim devolvemos o espa\u00e7o usado somando 0x10 de volta a %rsp . sub $0x10 , %rsp . . . // c\u00f3digo da fun\u00e7\u00e3o aqui! movl 0x8 ( %rsp ), %eax mov %eax , %edx addl 0xc ( %rsp ), %edx . . . // fun\u00e7\u00e3o continua add $0x10 , %rsp ret No exemplo acima, temos duas vari\u00e1veis locais: 0x8(%rsp) e 0xc(rsp) . Cada uma \u00e9 identificada no c\u00f3digo Assembly pelo endere\u00e7o em que est\u00e1 posicionada na pilha. Logo, todo deslocamento em rela\u00e7\u00e3o a %rsp indica um acesso a vari\u00e1vel local , sendo que pode ser um acesso de leitura e escrita (usando MOV , por exemplo) ou da opera\u00e7\u00e3o endere\u00e7o de & (usando LEA ). Conseguimos identificar que seus tamanhos s\u00e3o int por duas raz\u00f5es: elas aparecem em instru\u00e7\u00f5es junto com registradores de 4 bytes ( %eax e %edx ) as instru\u00e7\u00f5es movl e addl tem o sufixo l , que indica que os dados tratados tem tamanho 4 bytes. Os sufixos suportados s\u00e3o: b - 1 byte w - 2 bytes l - 4 bytes q - 8 bytes Qualquer raz\u00e3o acima \u00e9 suficiente para identificar os tipos das vari\u00e1veis locais. Importante Novamente, nem toda instru\u00e7\u00e3o em Assembly pode ser representada em C . As instru\u00e7\u00f5es sub 0x10, %rsp e add 0x10, %rsp representam a cria\u00e7\u00e3o de vari\u00e1veis locais na pilha e n\u00e3o tem equivalente em C . Simplesmente ignoramos elas e usamos as vari\u00e1veis locais no c\u00f3digo.","title":"Exemplo guiado"},{"location":"aulas/08-variaveis-locais/#revisao-de-variaveis-globais-e-strings-constantes","text":"Antes de iniciar o pr\u00f3ximo exerc\u00edcio vamos revisar como vari\u00e1veis locais, globais e strings constantes s\u00e3o acessadas em c\u00f3digo assembly. A imagem abaixo exemplifica os tr\u00eas casos: Vari\u00e1veis locais : s\u00e3o acessadas com lea (para & - endere\u00e7o de) ou mov (para leituras e escritas) relativos a %rsp Globais e strings constantes : s\u00e3o acessadas usando a nota\u00e7\u00e3o 0xYY(%rip) , sendo que o valor 0xYY muda a cada acesso. No caso das strings, o acesso a estes endere\u00e7os \u00e9 somente leitura. O endere\u00e7amento relativo a %rip leva em conta a posi\u00e7\u00e3o relativa entre a instru\u00e7\u00e3o atual e o endere\u00e7o de mem\u00f3ria do dado. Na imagem acima est\u00e3o destacadas duas instru\u00e7\u00f5es lea que acessam o mesmo dado. Como o %rip (ponteiro para a pr\u00f3xima instru\u00e7\u00e3o) \u00e9 diferente precisamos de deslocamentos diferentes para acessar o mesmo dado. Dica : o gdb coloca o endere\u00e7o calculado ao lado das instru\u00e7\u00f5es deste tipo. Exercise \u00c9 poss\u00edvel que o lea abaixo seja aritm\u00e9tico? Por que? lea 0x8 ( %rsp ), %rdx Answer N\u00e3o! O registrador %rsp \u00e9 especial e sempre guarda o endere\u00e7o do topo da pilha de chamadas. Nesse espa\u00e7o de mem\u00f3ria guardamos todas vari\u00e1veis que n\u00e3o podem ser alocadas em um registrador.","title":"Revis\u00e3o de vari\u00e1veis globais e strings constantes"},{"location":"aulas/08-variaveis-locais/#arquivo-ex2","text":"O c\u00f3digo abaixo ( ex2 ) utiliza vari\u00e1veis locais. Dump of assembler code for function func1 : 0 x05fe <+ 0 > : sub $0x10 , %rsp 0 x0602 <+ 4 > : movl $0xa , 0xc ( %rsp ) 0 x060a <+ 12 > : movl $0xb , 0x8 ( %rsp ) 0 x0612 <+ 20 > : lea 0xc ( %rsp ), %rdi 0 x0617 <+ 25 > : callq 0x5fa < func2 > 0 x061c <+ 30 > : addl $0x1 , 0x8 ( %rsp ) 0 x0621 <+ 35 > : lea 0x8 ( %rsp ), %rdi 0 x0626 <+ 40 > : callq 0x5fa < func2 > 0 x062b <+ 45 > : add $0x10 , %rsp 0 x062f <+ 49 > : retq Vamos come\u00e7ar analisando as tr\u00eas primeiras linhas do programa. Exercise Quanto espa\u00e7o (em bytes) \u00e9 reservado na pilha? 10 16 20 8 Answer Ao executar sub $0x10,%rsp criamos um espa\u00e7o de 16 bytes ( 0x10 ) na pilha. Note que as constantes sempre aparecem em hexadecimal. Existem v\u00e1rios momentos no c\u00f3digo que lemos/escrevemos em endere\u00e7os relativos a %rsp . Cada deslocamento representa uma vari\u00e1vel local que est\u00e1 armazenada na mem\u00f3ria. Exercise Quantas vari\u00e1veis s\u00e3o inicializadas e quais seus tamanhos? 2 - int 2 - long 1 - int 1 - long Answer S\u00e3o duas vari\u00e1veis int : uma em 0xc(%rsp) e outra em 0x8(%rsp) . Exercise Identifique onde as vari\u00e1veis locais encontradas s\u00e3o usadas. D\u00ea um nome para cada uma delas. Answer Vou utilizar os identificadores e tipos int a e int b . Exercise Os lea das linhas +20 e +35 podem ser aritm\u00e9ticos? SIM N\u00c3O Answer N\u00e3o s\u00e3o aritm\u00e9ticos, portanto representam a opera\u00e7\u00e3o endere\u00e7o de & . Exercise Com base em sua resposta acima, traduza as chamadas de fun\u00e7\u00e3o que ocorrem nas linhas +25 e +40 . Answer Na linha +25 ocorre a chamada func2(&a) . J\u00e1 na linha +40 a chamada \u00e9 func2(&b) Exercise Traduza o programa acima para C Answer void func2 ( int * a ) { * a += 1 ; } void func1 () { int a = 10 ; int b = 11 ; func2 ( & a ); b ++ ; func2 ( & b ); }","title":"Arquivo ex2"},{"location":"aulas/08-variaveis-locais/#arquivo-ex3","text":"No exerc\u00edcio anterior vimos como passar vari\u00e1veis por refer\u00eancia para outras fun\u00e7\u00f5es. Agora veremos como trabalhar com scanf . Veja abaixo a fun\u00e7\u00e3o main do execut\u00e1vel ex3 . Abra este arquivo usando o gdb e siga os exerc\u00edcios. Dump of assembler code for function main : 0 x1149 <+ 0 > : sub $0x18 , %rsp 0 x114d <+ 4 > : lea 0xc ( %rsp ), %rsi 0 x1152 <+ 9 > : lea 0xeab ( %rip ), %rdi # 0x2004 0 x1159 <+ 16 > : mov $0x0 , %eax 0 x115e <+ 21 > : callq 0x1040 < __isoc99_scanf@plt > 0 x1163 <+ 26 > : cmpl $0x0 , 0xc ( %rsp ) 0 x1168 <+ 31 > : js 0x1180 < main + 55 > 0 x116a <+ 33 > : lea 0xe9f ( %rip ), %rdi # 0x2010 0 x1171 <+ 40 > : callq 0x1030 < puts@plt > 0 x1176 <+ 45 > : mov $0x0 , %eax 0 x117b <+ 50 > : add $0x18 , %rsp 0 x117f <+ 54 > : retq 0 x1180 <+ 55 > : lea 0xe80 ( %rip ), %rdi # 0x2007 0 x1187 <+ 62 > : callq 0x1030 < puts@plt > 0 x118c <+ 67 > : jmp 0x1176 < main + 45 > Exercise Vamos come\u00e7ar procurando por vari\u00e1veis locais que estejam na pilha. Quanto espa\u00e7o \u00e9 reservado para elas? Liste abaixo as que voc\u00ea encontrou e d\u00ea um nome para cada uma. Dica : todo acesso relativo a %rsp representa um acesso a vari\u00e1vel local. Answer Est\u00e3o sendo reservados 24 bytes na pilha. Temos uma vari\u00e1vel local int n . Exercise A instru\u00e7\u00e3o call em main+21 \u00e9 um scanf . O primeiro argumento \u00e9 a string de formata\u00e7\u00e3o. Use o comando x do gdb para encontrar ela na mem\u00f3ria. Dica : usamos este comando nas aulas 02 e 03. Answer A string de formata\u00e7\u00e3o \u00e9 \"%d\". Exercise O segundo argumento do scanf \u00e9 o endere\u00e7o da vari\u00e1vel a ser preenchida. O endere\u00e7o de qual vari\u00e1vel local \u00e9 passado? Answer \u00c9 o endere\u00e7o da vari\u00e1vel correspondente a 0xc(%rsp) Exercise Reconstrua a chamada do scanf acima. Answer int a; // demos esse nome para todas ocorr\u00eancias de 0x(%rsp) scanf(\"%d\", &a); Com a chamada do scanf pronta, vamos analisar o restante do c\u00f3digo. Exercise Agora examinaremos as chamadas em main+40 e main+62 . Elas s\u00e3o para a fun\u00e7\u00e3o puts . Veja sua documenta\u00e7\u00e3o (procure por C puts .) e explique abaixo o qu\u00ea ela faz e quais s\u00e3o seus argumentos. Answer Escreve os m\u00faltiplos caracteres de uma string, seguido de \\n , na sa\u00edda padr\u00e3o Exercise Com base na explica\u00e7\u00e3o acima, escreva abaixo os argumentos passados para cada chamada. Answer S\u00e3o feitas duas chamadas: a primeira \u00e9 puts(\"Positivo\") e a segunda \u00e9 puts(\"Negativo\") . Exercise Traduza o c\u00f3digo acima para um vers\u00e3o em C . Answer #include <stdio.h> int main () { int n ; scanf ( \"%d\" , & n ); if ( n < 0 ) { printf ( \"Negativo \\n \" ); } else { printf ( \"Positivo! \\n \" ); } return 0 ; }","title":"Arquivo ex3"},{"location":"aulas/08-variaveis-locais/#entrega","text":"Exerc\u00edcios 4 e 5 da atv6 dispon\u00edveis no seu reposit\u00f3rio de atividades privado. Aten\u00e7\u00e3o! Antes de continuar, d\u00ea um git pull em seu reposit\u00f3rio de atividades! Importante Sempre leia o README.md dispon\u00edvel na pasta da atividade. Ele tem informa\u00e7\u00f5es importantes para a execu\u00e7\u00e3o da atividade.","title":"Entrega"},{"location":"aulas/09-arrays/","text":"09 - Array em Assembly \u00b6 A parte final de nossas atividades com Assembly \u00e9 entender Arrays . J\u00e1 estudamos todo o necess\u00e1rio para lidar com eles: um array \u00e9 representado por um apontador para seu primeiro elemento. J\u00e1 estudamos ponteiros e a escrita em mem\u00f3ria com MOV . ao acessar o elemento i de long *vec estamos acessando o endere\u00e7o &vec[0] + sizeof(long) * i . A nota\u00e7\u00e3o de c\u00e1lculos de endere\u00e7o de mem\u00f3ria faz exatamente isso. Para iniciar vamos revisar a nota\u00e7\u00e3o de c\u00e1lculo de endere\u00e7os de mem\u00f3ria: D(%reg1, %reg2, S) , onde D \u00e9 um n\u00famero inteiro que representa um deslocamento constante a partir do endere\u00e7o guardado em %reg1 %reg1 cont\u00e9m o endere\u00e7o do primeiro elemento do vetor %reg2 cont\u00e9m o \u00edndice do elemento a ser acessado S cont\u00e9m o tamanho de cada elemento do vetor e pode ser 1, 2, 4 ou 8 . O acesso \u00e9 feito ao endere\u00e7o D + %reg1 + %reg2 * S . Ou seja, primeiro computamos o endere\u00e7o e depois acessamos a mem\u00f3ria no endere\u00e7o computado . Exercise Supondo que %rsi=0x24, %rdi=0x8 , o valor final da express\u00e3o (%rsi, %rdi, 4) \u00e9 0x32 0x48 0x56 0x44 Answer Tudo est\u00e1 em hexa. A conta \u00e9 36 + 4 * 8 = 68 . Exercise Supondo que %rdx=0x44 , o valor da express\u00e3o 0x12(%rdx) \u00e9 0x56 0x44 0x52 Answer Tudo est\u00e1 em hexa. A conta \u00e9 18 + 68 = 86 = 0x56 . Exemplo guiado \u00b6 Dado o array int *vec (guardado em %rdx ). A atribui\u00e7\u00e3o de 5 ao elemento i (guardado em %ecx ) seria traduzida como MOVL $0x5 , ( %rdx , %rcx , 4 ) Importante Lembre-se de que apontadores s\u00e3o tipos de dados com tamanho 8 bytes . Considerando um vetor short *vec e que o endere\u00e7o do primeiro elemento de vec esteja em %rdi , Exercise Qual a instru\u00e7\u00e3o usada para mover o conte\u00fado de vec[i] para o registrador %eax ? (supondo que o valor de i esteja em %esi ) Answer mov (%rdi, %rsi, 2), %eax Exercise Qual a instru\u00e7\u00e3o usada para mover &vec[i] para o registrador %eax ? Dica : como voc\u00ea implementava o operador & com vari\u00e1veis locais? Answer lea (%rdi, %rsi, 2), %rax Aten\u00e7\u00e3o: instru\u00e7\u00e3o utilizada apenas de forma pedag\u00f3gica para diferenciar MOV e LEA . Exerc\u00edcio 1 - fun\u00e7\u00e3o soma \u00b6 Veja o c\u00f3digo abaixo e responda as perguntas. Dump of assembler code for function soma : 0 x0000 <+ 0 > : mov $0x0 , %edx 0 x0005 <+ 5 > : mov $0x0 , %eax 0 x000a <+ 10 > : jmp 0x15 < soma + 21 > 0 x000c <+ 12 > : movslq %edx , %rcx 0 x000f <+ 15 > : add ( %rdi , %rcx , 4 ), %eax 0 x0012 <+ 18 > : add $0x1 , %edx 0 x0015 <+ 21 > : cmp %esi , %edx 0 x0017 <+ 23 > : jl 0xc < soma + 12 > 0 x0019 <+ 25 > : repz retq Exercise A fun\u00e7\u00e3o acima usa v\u00e1rios registradores. Para facilitar a descoberta de quais s\u00e3o par\u00e2metros da fun\u00e7\u00e3o anote abaixo cada registrador usado e, ao lado, a linha do primeiro uso e se esse uso foi leitura ou escrita. Answer Em <soma+0> , usa-se %edx para escrita . Em <soma+5> , usa-se %eax para escrita . Em <soma+12> , usa-se %rcx para escrita . Em <soma+15> , usa-se %rdi para leitura . Em <soma+21> , usa-se %esi para leitura . Exercise Se o primeiro acesso ao registrador \u00e9 de escrita ent\u00e3o ele provavelmente n\u00e3o \u00e9 um par\u00e2metro. Com base nisto, escreva abaixo a declara\u00e7\u00e3o da fun\u00e7\u00e3o acima. Answer int soma ( int * vec , int n ) Exercise Sempre que escrevemos a nota\u00e7\u00e3o de acesso \u00e0 mem\u00f3ria D(%reg1, %reg2, S) precisamos usar registradores de 64 bits nos lugares de reg1 e reg2 . Com base nisto, explique qual o uso feito do registrador %edx e porqu\u00ea usamos a instru\u00e7\u00e3o movslq na linha c (ou <soma+12> ). Answer Faz o casting com sinal de 4 bytes para 8 bytes. Ent\u00e3o o c\u00f3digo-fonte original deve utilizar uma vari\u00e1vel int i (4 bytes) para controlar o \u00edndice do vetor. Para que a instru\u00e7\u00e3o seja realizada, faz-se um casting para long . Exercise Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer \\\\ confira com os professores Acesso a elementos constantes \u00b6 O acesso a elementos \"constantes\", como long v[10]; v[5] = 0; , n\u00e3o \u00e9 feito usando a nota\u00e7\u00e3o acima, pois o compilador j\u00e1 sabe em tempo de compila\u00e7\u00e3o , qual \u00e9 o deslocamento necess\u00e1rio para encontrar a posi\u00e7\u00e3o 6 de v . Considerando o exemplo acima, responda. Exercise Supondo que v=0x100 , qual o \u00e9 o endere\u00e7o de v[5] ? Answer Cada long ocupa 8 bytes, logo o elemento v[5] est\u00e1 40 bytes ap\u00f3s o in\u00edcio do vetor. Logo, o endere\u00e7o de v[5] \u00e9 0x100 + 0x028 = 0x128 . Exercise Escreva a instru\u00e7\u00e3o usada para mover o valor 0 para v[5] (supondo que o endere\u00e7o do primeiro elemento esteja em %rdi ). Answer mov $0, 0x28(%rdi) = In\u00edcio de %rdi + 40 bytes. Importante O compilador pode (e vai) aplicar diversas otimiza\u00e7\u00f5es para economizar o m\u00e1ximo poss\u00edvel. Por essa raz\u00e3o, \u00e9 importante saber calcular os endere\u00e7os de mem\u00f3ria na m\u00e3o. Assim conseguimos \"refazer\" o processo que gerou a otimiza\u00e7\u00e3o e entender melhor o c\u00f3digo C original. Exerc\u00edcio 2 - fun\u00e7\u00e3o func_que_recebe_array \u00b6 Dump of assembler code for function func_que_recebe_array : 0 x0000 <+ 0 > : mov 0x4 ( %rdi ), %eax 0 x0003 <+ 3 > : add ( %rdi ), %eax 0 x0005 <+ 5 > : cmp 0x8 ( %rdi ), %eax 0 x0008 <+ 8 > : setl %al 0 x000b <+ 11 > : movzbl %al , %eax 0 x000e <+ 14 > : retq Exercise Temos acessos \u00e0 mem\u00f3ria relativos ao endere\u00e7o passado em %rdi nas linhas 0, 3 e 5 . Isto significa que %rdi \u00e9 um ponteiro. Pelos tipos de acessos feitos, voc\u00ea consegue identificar para qual tipo de vari\u00e1vel ele aponta? Answer Como em na linha <+0> o vetor est\u00e1 sendo lido em um registrador de 4 bytes, identificamos como int Exercise Traduza os acessos de mem\u00f3ria feitos nas linhas citadas acima para a nota\u00e7\u00e3o de acesso a arrays em C . Answer Em <+0> faz-se aux = vec[1] . Em <+03> o acesso \u00e9 aux = vec[0] + aux . Exercise Com base no respondido acima, fa\u00e7a uma vers\u00e3o em C leg\u00edvel do c\u00f3digo assembly acima. Se ajudar, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha do Assembly e depois torne-a leg\u00edvel. Answer int func_que_recebe_array ( int * arr ) { long c = arr [ 0 ] + arr [ 1 ]; return c < arr [ 2 ]; } Exerc\u00edcio 3 - fun\u00e7\u00e3o first_neg \u00b6 Veja agora o c\u00f3digo abaixo e responda. Dump of assembler code for function first_neg : 0 x0000 <+ 0 > : mov $0x0 , %eax 0 x0005 <+ 5 > : cmp %esi , %eax 0 x0007 <+ 7 > : jge 0x17 < first_neg + 23 > 0 x0009 <+ 9 > : movslq %eax , %rdx 0 x000c <+ 12 > : cmpl $0x0 ,( %rdi , %rdx , 4 ) 0 x0010 <+ 16 > : js 0x17 < first_neg + 23 > 0 x0012 <+ 18 > : add $0x1 , %eax 0 x0015 <+ 21 > : jmp 0x5 < first_neg + 5 > 0 x0017 <+ 23 > : repz retq Exercise A fun\u00e7\u00e3o acima usa v\u00e1rios registradores. Para facilitar a descoberta de quais s\u00e3o par\u00e2metros da fun\u00e7\u00e3o anote abaixo cada registrador usado e, ao lado, a linha do primeiro uso e se esse uso foi leitura ou escrita. Answer Em <first_neg+0> , usa-se %eax para escrita . Em <first_neg+5> , usa-se %esi para leitura . Em <first_neg+12> , usa-se %rdi para leitura . Exercise Desenhe setas indicando o destino dos pulos no c\u00f3digo acima. Voc\u00ea consegue idenfiticar quais estruturas de controle? Entre quais linhas? Answer Confira com os professores Exercise Fa\u00e7a uma vers\u00e3o em C usando if-goto do c\u00f3digo acima. Answer int first_neg ( int * vec , int n ) { res = 0 ; loop : if ( res >= n ) { goto retorno ; } if ( vec [ res ] < 0 ) { goto retorno ; } res = res + 1 ; goto loop : retorno : return res ; } Exercise Transforme seu c\u00f3digo em uma vers\u00e3o leg\u00edvel. Answer int first_neg ( int * vec , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( vec [ i ] < 0 ) { return i ; } } }","title":"09 - Array em Assembly"},{"location":"aulas/09-arrays/#09-array-em-assembly","text":"A parte final de nossas atividades com Assembly \u00e9 entender Arrays . J\u00e1 estudamos todo o necess\u00e1rio para lidar com eles: um array \u00e9 representado por um apontador para seu primeiro elemento. J\u00e1 estudamos ponteiros e a escrita em mem\u00f3ria com MOV . ao acessar o elemento i de long *vec estamos acessando o endere\u00e7o &vec[0] + sizeof(long) * i . A nota\u00e7\u00e3o de c\u00e1lculos de endere\u00e7o de mem\u00f3ria faz exatamente isso. Para iniciar vamos revisar a nota\u00e7\u00e3o de c\u00e1lculo de endere\u00e7os de mem\u00f3ria: D(%reg1, %reg2, S) , onde D \u00e9 um n\u00famero inteiro que representa um deslocamento constante a partir do endere\u00e7o guardado em %reg1 %reg1 cont\u00e9m o endere\u00e7o do primeiro elemento do vetor %reg2 cont\u00e9m o \u00edndice do elemento a ser acessado S cont\u00e9m o tamanho de cada elemento do vetor e pode ser 1, 2, 4 ou 8 . O acesso \u00e9 feito ao endere\u00e7o D + %reg1 + %reg2 * S . Ou seja, primeiro computamos o endere\u00e7o e depois acessamos a mem\u00f3ria no endere\u00e7o computado . Exercise Supondo que %rsi=0x24, %rdi=0x8 , o valor final da express\u00e3o (%rsi, %rdi, 4) \u00e9 0x32 0x48 0x56 0x44 Answer Tudo est\u00e1 em hexa. A conta \u00e9 36 + 4 * 8 = 68 . Exercise Supondo que %rdx=0x44 , o valor da express\u00e3o 0x12(%rdx) \u00e9 0x56 0x44 0x52 Answer Tudo est\u00e1 em hexa. A conta \u00e9 18 + 68 = 86 = 0x56 .","title":"09 - Array em Assembly"},{"location":"aulas/09-arrays/#exemplo-guiado","text":"Dado o array int *vec (guardado em %rdx ). A atribui\u00e7\u00e3o de 5 ao elemento i (guardado em %ecx ) seria traduzida como MOVL $0x5 , ( %rdx , %rcx , 4 ) Importante Lembre-se de que apontadores s\u00e3o tipos de dados com tamanho 8 bytes . Considerando um vetor short *vec e que o endere\u00e7o do primeiro elemento de vec esteja em %rdi , Exercise Qual a instru\u00e7\u00e3o usada para mover o conte\u00fado de vec[i] para o registrador %eax ? (supondo que o valor de i esteja em %esi ) Answer mov (%rdi, %rsi, 2), %eax Exercise Qual a instru\u00e7\u00e3o usada para mover &vec[i] para o registrador %eax ? Dica : como voc\u00ea implementava o operador & com vari\u00e1veis locais? Answer lea (%rdi, %rsi, 2), %rax Aten\u00e7\u00e3o: instru\u00e7\u00e3o utilizada apenas de forma pedag\u00f3gica para diferenciar MOV e LEA .","title":"Exemplo guiado"},{"location":"aulas/09-arrays/#exercicio-1-funcao-soma","text":"Veja o c\u00f3digo abaixo e responda as perguntas. Dump of assembler code for function soma : 0 x0000 <+ 0 > : mov $0x0 , %edx 0 x0005 <+ 5 > : mov $0x0 , %eax 0 x000a <+ 10 > : jmp 0x15 < soma + 21 > 0 x000c <+ 12 > : movslq %edx , %rcx 0 x000f <+ 15 > : add ( %rdi , %rcx , 4 ), %eax 0 x0012 <+ 18 > : add $0x1 , %edx 0 x0015 <+ 21 > : cmp %esi , %edx 0 x0017 <+ 23 > : jl 0xc < soma + 12 > 0 x0019 <+ 25 > : repz retq Exercise A fun\u00e7\u00e3o acima usa v\u00e1rios registradores. Para facilitar a descoberta de quais s\u00e3o par\u00e2metros da fun\u00e7\u00e3o anote abaixo cada registrador usado e, ao lado, a linha do primeiro uso e se esse uso foi leitura ou escrita. Answer Em <soma+0> , usa-se %edx para escrita . Em <soma+5> , usa-se %eax para escrita . Em <soma+12> , usa-se %rcx para escrita . Em <soma+15> , usa-se %rdi para leitura . Em <soma+21> , usa-se %esi para leitura . Exercise Se o primeiro acesso ao registrador \u00e9 de escrita ent\u00e3o ele provavelmente n\u00e3o \u00e9 um par\u00e2metro. Com base nisto, escreva abaixo a declara\u00e7\u00e3o da fun\u00e7\u00e3o acima. Answer int soma ( int * vec , int n ) Exercise Sempre que escrevemos a nota\u00e7\u00e3o de acesso \u00e0 mem\u00f3ria D(%reg1, %reg2, S) precisamos usar registradores de 64 bits nos lugares de reg1 e reg2 . Com base nisto, explique qual o uso feito do registrador %edx e porqu\u00ea usamos a instru\u00e7\u00e3o movslq na linha c (ou <soma+12> ). Answer Faz o casting com sinal de 4 bytes para 8 bytes. Ent\u00e3o o c\u00f3digo-fonte original deve utilizar uma vari\u00e1vel int i (4 bytes) para controlar o \u00edndice do vetor. Para que a instru\u00e7\u00e3o seja realizada, faz-se um casting para long . Exercise Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer \\\\ confira com os professores","title":"Exerc\u00edcio 1 - fun\u00e7\u00e3o soma"},{"location":"aulas/09-arrays/#acesso-a-elementos-constantes","text":"O acesso a elementos \"constantes\", como long v[10]; v[5] = 0; , n\u00e3o \u00e9 feito usando a nota\u00e7\u00e3o acima, pois o compilador j\u00e1 sabe em tempo de compila\u00e7\u00e3o , qual \u00e9 o deslocamento necess\u00e1rio para encontrar a posi\u00e7\u00e3o 6 de v . Considerando o exemplo acima, responda. Exercise Supondo que v=0x100 , qual o \u00e9 o endere\u00e7o de v[5] ? Answer Cada long ocupa 8 bytes, logo o elemento v[5] est\u00e1 40 bytes ap\u00f3s o in\u00edcio do vetor. Logo, o endere\u00e7o de v[5] \u00e9 0x100 + 0x028 = 0x128 . Exercise Escreva a instru\u00e7\u00e3o usada para mover o valor 0 para v[5] (supondo que o endere\u00e7o do primeiro elemento esteja em %rdi ). Answer mov $0, 0x28(%rdi) = In\u00edcio de %rdi + 40 bytes. Importante O compilador pode (e vai) aplicar diversas otimiza\u00e7\u00f5es para economizar o m\u00e1ximo poss\u00edvel. Por essa raz\u00e3o, \u00e9 importante saber calcular os endere\u00e7os de mem\u00f3ria na m\u00e3o. Assim conseguimos \"refazer\" o processo que gerou a otimiza\u00e7\u00e3o e entender melhor o c\u00f3digo C original.","title":"Acesso a elementos constantes"},{"location":"aulas/09-arrays/#exercicio-2-funcao-func_que_recebe_array","text":"Dump of assembler code for function func_que_recebe_array : 0 x0000 <+ 0 > : mov 0x4 ( %rdi ), %eax 0 x0003 <+ 3 > : add ( %rdi ), %eax 0 x0005 <+ 5 > : cmp 0x8 ( %rdi ), %eax 0 x0008 <+ 8 > : setl %al 0 x000b <+ 11 > : movzbl %al , %eax 0 x000e <+ 14 > : retq Exercise Temos acessos \u00e0 mem\u00f3ria relativos ao endere\u00e7o passado em %rdi nas linhas 0, 3 e 5 . Isto significa que %rdi \u00e9 um ponteiro. Pelos tipos de acessos feitos, voc\u00ea consegue identificar para qual tipo de vari\u00e1vel ele aponta? Answer Como em na linha <+0> o vetor est\u00e1 sendo lido em um registrador de 4 bytes, identificamos como int Exercise Traduza os acessos de mem\u00f3ria feitos nas linhas citadas acima para a nota\u00e7\u00e3o de acesso a arrays em C . Answer Em <+0> faz-se aux = vec[1] . Em <+03> o acesso \u00e9 aux = vec[0] + aux . Exercise Com base no respondido acima, fa\u00e7a uma vers\u00e3o em C leg\u00edvel do c\u00f3digo assembly acima. Se ajudar, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha do Assembly e depois torne-a leg\u00edvel. Answer int func_que_recebe_array ( int * arr ) { long c = arr [ 0 ] + arr [ 1 ]; return c < arr [ 2 ]; }","title":"Exerc\u00edcio 2 - fun\u00e7\u00e3o func_que_recebe_array"},{"location":"aulas/09-arrays/#exercicio-3-funcao-first_neg","text":"Veja agora o c\u00f3digo abaixo e responda. Dump of assembler code for function first_neg : 0 x0000 <+ 0 > : mov $0x0 , %eax 0 x0005 <+ 5 > : cmp %esi , %eax 0 x0007 <+ 7 > : jge 0x17 < first_neg + 23 > 0 x0009 <+ 9 > : movslq %eax , %rdx 0 x000c <+ 12 > : cmpl $0x0 ,( %rdi , %rdx , 4 ) 0 x0010 <+ 16 > : js 0x17 < first_neg + 23 > 0 x0012 <+ 18 > : add $0x1 , %eax 0 x0015 <+ 21 > : jmp 0x5 < first_neg + 5 > 0 x0017 <+ 23 > : repz retq Exercise A fun\u00e7\u00e3o acima usa v\u00e1rios registradores. Para facilitar a descoberta de quais s\u00e3o par\u00e2metros da fun\u00e7\u00e3o anote abaixo cada registrador usado e, ao lado, a linha do primeiro uso e se esse uso foi leitura ou escrita. Answer Em <first_neg+0> , usa-se %eax para escrita . Em <first_neg+5> , usa-se %esi para leitura . Em <first_neg+12> , usa-se %rdi para leitura . Exercise Desenhe setas indicando o destino dos pulos no c\u00f3digo acima. Voc\u00ea consegue idenfiticar quais estruturas de controle? Entre quais linhas? Answer Confira com os professores Exercise Fa\u00e7a uma vers\u00e3o em C usando if-goto do c\u00f3digo acima. Answer int first_neg ( int * vec , int n ) { res = 0 ; loop : if ( res >= n ) { goto retorno ; } if ( vec [ res ] < 0 ) { goto retorno ; } res = res + 1 ; goto loop : retorno : return res ; } Exercise Transforme seu c\u00f3digo em uma vers\u00e3o leg\u00edvel. Answer int first_neg ( int * vec , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( vec [ i ] < 0 ) { return i ; } } }","title":"Exerc\u00edcio 3 - fun\u00e7\u00e3o first_neg"},{"location":"aulas/10-malloc/","text":"10 - Aloca\u00e7\u00e3o Din\u00e2mica de Mem\u00f3ria \u00b6 Exerc\u00edcios b\u00e1sicos \u00b6 Hora de compilar! Abra o arquivo ex1.c em um editor e compile-o usando as flags da disciplina. $ gcc -Og -Wall -std = c99 ex1.c -o ex1 Sem rodar o programa , responda as quest\u00f5es abaixo. Exercise Analisando seu c\u00f3digo-fonte, o que este programa faz? Answer Aloca um vetor, preenche com 0,1,...,n 0,1,...,n e imprime! Exercise Na execu\u00e7\u00e3o deste programa, o que acontece se malloc falhar? Answer A fun\u00e7\u00e3o de aloca\u00e7\u00e3o ir\u00e1 retornar NULL , mas nenhuma verifica\u00e7\u00e3o est\u00e1 sendo feita. Exercise O seu programa libera toda mem\u00f3ria que aloca? Se n\u00e3o, aponte onde ele deveria fazer isto. Answer Cada valor retornado por malloc deve ser liberado usando a fun\u00e7\u00e3o free . No caso, vemos que vetor n\u00e3o foi liberado ap\u00f3s seu uso. Isto deveria ser feito na linha 26. Agora execute o programa acima e responda as quest\u00f5es abaixo. Exercise Ocorreu algum problema durante a execu\u00e7\u00e3o? Answer A resposta aqui \u00e9 provavelmente n\u00e3o. Por\u00e9m, isso n\u00e3o significa que o programa est\u00e1 correto, apenas que se ocorreu um erro ele n\u00e3o foi suficientemente grave para finalizar o programa. Exercise O comportamento de seu programa muda conforme N muda? Come\u00e7e com N=10 e v\u00e1 incrementando de um em um. Voc\u00ea consegue explicar por que? Discuta com seu grupo e valide sua resposta com o professor. Answer Ao chegar em N=14 seu programa dever\u00e1 magicamente dar problemas e deve voltar a funcionar com N=15 . Este \u00e9 um dos grandes problemas de programas com erro de mem\u00f3ria: seu comportamento \u00e9 imprevis\u00edvel. Exercise Existem tr\u00eas problemas no c\u00f3digo. O primeiro ( vetor n\u00e3o \u00e9 desalocado) j\u00e1 identificamos no exerc\u00edco anterior. Voc\u00ea consegue identificar os outros dois? Answer O loop de exibi\u00e7\u00e3o imprime at\u00e9 a posi\u00e7\u00e3o N N , por\u00e9m as N N posi\u00e7\u00f5es do array s\u00e3o 0,1,\\dots,N-1 0,1,\\dots,N-1 . O mesmo erro \u00e9 realizado na fun\u00e7\u00e3o atribui , que faz um acesso indevido vetor[N] . Vamos corrigir! Corrija os erros apontados na quest\u00e3o anterior e salve o programa em um arquivo ex1-certo.c . Ferramentas de verifica\u00e7\u00e3o de mem\u00f3ria \u00b6 Para poder identificar mais facilmente problemas relativos a mem\u00f3ria, iremos utilizar uma ferramenta chamada Valgrind . Para saber mais sobre o valgrind acesse o link: https://diveintosystems.org/book/C3-C_debug/valgrind.html O Valgrind \u00e9 um detector de m\u00e1 gest\u00e3o de mem\u00f3ria. Ele roda seu programa em cima de um ambiente modificado e aponta os seguintes erros: mem\u00f3ria alocada e n\u00e3o liberada acessos (leituras e escritas) a posi\u00e7\u00f5es de mem\u00f3ria n\u00e3o alocada ou inv\u00e1lidas O valgrind est\u00e1 dispon\u00edvel na maioria das distribui\u00e7\u00f5es Linux modernas. Instale com: $ sudo apt update $ sudo apt install valgrind Dica \u00c9 recomend\u00e1vel manter o h\u00e1bito de atualizar o Linux de tempos em tempos. Fa\u00e7a com: $ sudo apt update $ sudo apt upgrade Para que os problemas encontrados pelo Valgrind sejam mais facilmente identificados, iremos passar a compilar utilizando a flag -g . Example Compile os programas ex1 e ex1-certo criados na parte anterior incluindo tamb\u00e9m a flag -g . $ gcc -Og -g -Wall -std = c99 ex1.c -o ex1 $ gcc -Og -g -Wall -std = c99 ex1-certo.c -o ex1-certo Exercise Rode o Valgrind com valgrind --leak-check=yes ./ex1 . Quantos erros foram encontrados? Quais s\u00e3o seus tipos (escrita ou leitura de dados)? O que eles significam? Answer Iremos discutir cada um dos erros! O primeiro erro encontrado \u00e9 ==1899== Invalid write of size 4 ==1899== at 0x1086C7: main (ex1.c:11) ==1899== Address 0x522f078 is 0 bytes after a block of size 56 alloc'd ==1899== at 0x4C31B0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==1899== by 0x1086B9: main (ex1.c:7) Exercise Em qual linha o erro ocorre? O que a mensagem acima significa? Answer O erro ocorre na linha 11, ao escrever em vetor[i] quando i == N O segundo erro \u00e9 ==1899== Invalid read of size 4 ==1899== at 0x1086DD: main (ex1.c:15) ==1899== Address 0x522f078 is 0 bytes after a block of size 56 alloc'd ==1899== at 0x4C31B0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==1899== by 0x1086B9: main (ex1.c:7) Exercise Em qual linha o erro ocorre? O que a mensagem acima significa? Answer O erro ocorre na linha 15, ao ler vetor[i] quando i == N . A se\u00e7\u00e3o HEAP SUMMARY faz um resumo dos dados alocados/desalocados no seu programa. A sa\u00edda abaixo foi obtida ao rodar o valgrind para o exerc\u00edcio 1 original: ==2179== HEAP SUMMARY: ==2179== in use at exit: 56 bytes in 1 blocks ==2179== total heap usage: 2 allocs, 1 frees, 1,080 bytes allocated ==2179== ==2179== 56 bytes in 1 blocks are definitely lost in loss record 1 of 1 ==2179== at 0x4C31B0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==2179== by 0x1086B9: main (ex1.c:7) Exercise Ela mostra algum problema? Se sim, qual linha de c\u00f3digo \u00e9 apontada? Qual \u00e9 o problema diagnosticado por este aviso? Answer Ela indica que houveram 2 mallocs' e somente 1 free . Ou seja, alguma aloca\u00e7\u00e3o de mem\u00f3ria deixou de liberar dados. Abaixo, s\u00e3o indicadas em quais linhas os malloc sem free ocorreram (linha 7 na fun\u00e7\u00e3o main`) Example Verifique que seu programa corrigido ex1-certo.c roda sem erros no valgrind. Se n\u00e3o, corrija os problema e rode novamente at\u00e9 que rode sem erros. Implementa\u00e7\u00f5es de fun\u00e7\u00f5es ( Entrega ) \u00b6 Os exerc\u00edcios abaixo est\u00e3o dispon\u00edveis no reposit\u00f3rio de entregas (pasta atv/08-malloc ). Dica! Leia o README.md na pasta da atividade! To Do Abra o arquivo copia_string.c e implemente a fun\u00e7\u00e3o mystrcpy . Esta fun\u00e7\u00e3o recebe uma string, e devolve uma c\u00f3pia da string original, alocando apenas o espa\u00e7o realmente necess\u00e1rio. To Do Abra o arquivo concatena_string.c e implemente a fun\u00e7\u00e3o mystrcat . Esta fun\u00e7\u00e3o recebe duas string, e devolve uma terceira que \u00e9 a concatena\u00e7\u00e3o das duas primeiras, alocando apenas o espa\u00e7o realmente necess\u00e1rio. Aten\u00e7\u00e3o! N\u00e3o se esque\u00e7a de checar se sua implementa\u00e7\u00e3o tem erros usando o valgrind.","title":"10 - Aloca\u00e7\u00e3o Din\u00e2mica de Mem\u00f3ria"},{"location":"aulas/10-malloc/#10-alocacao-dinamica-de-memoria","text":"","title":"10 - Aloca\u00e7\u00e3o Din\u00e2mica de Mem\u00f3ria"},{"location":"aulas/10-malloc/#exercicios-basicos","text":"Hora de compilar! Abra o arquivo ex1.c em um editor e compile-o usando as flags da disciplina. $ gcc -Og -Wall -std = c99 ex1.c -o ex1 Sem rodar o programa , responda as quest\u00f5es abaixo. Exercise Analisando seu c\u00f3digo-fonte, o que este programa faz? Answer Aloca um vetor, preenche com 0,1,...,n 0,1,...,n e imprime! Exercise Na execu\u00e7\u00e3o deste programa, o que acontece se malloc falhar? Answer A fun\u00e7\u00e3o de aloca\u00e7\u00e3o ir\u00e1 retornar NULL , mas nenhuma verifica\u00e7\u00e3o est\u00e1 sendo feita. Exercise O seu programa libera toda mem\u00f3ria que aloca? Se n\u00e3o, aponte onde ele deveria fazer isto. Answer Cada valor retornado por malloc deve ser liberado usando a fun\u00e7\u00e3o free . No caso, vemos que vetor n\u00e3o foi liberado ap\u00f3s seu uso. Isto deveria ser feito na linha 26. Agora execute o programa acima e responda as quest\u00f5es abaixo. Exercise Ocorreu algum problema durante a execu\u00e7\u00e3o? Answer A resposta aqui \u00e9 provavelmente n\u00e3o. Por\u00e9m, isso n\u00e3o significa que o programa est\u00e1 correto, apenas que se ocorreu um erro ele n\u00e3o foi suficientemente grave para finalizar o programa. Exercise O comportamento de seu programa muda conforme N muda? Come\u00e7e com N=10 e v\u00e1 incrementando de um em um. Voc\u00ea consegue explicar por que? Discuta com seu grupo e valide sua resposta com o professor. Answer Ao chegar em N=14 seu programa dever\u00e1 magicamente dar problemas e deve voltar a funcionar com N=15 . Este \u00e9 um dos grandes problemas de programas com erro de mem\u00f3ria: seu comportamento \u00e9 imprevis\u00edvel. Exercise Existem tr\u00eas problemas no c\u00f3digo. O primeiro ( vetor n\u00e3o \u00e9 desalocado) j\u00e1 identificamos no exerc\u00edco anterior. Voc\u00ea consegue identificar os outros dois? Answer O loop de exibi\u00e7\u00e3o imprime at\u00e9 a posi\u00e7\u00e3o N N , por\u00e9m as N N posi\u00e7\u00f5es do array s\u00e3o 0,1,\\dots,N-1 0,1,\\dots,N-1 . O mesmo erro \u00e9 realizado na fun\u00e7\u00e3o atribui , que faz um acesso indevido vetor[N] . Vamos corrigir! Corrija os erros apontados na quest\u00e3o anterior e salve o programa em um arquivo ex1-certo.c .","title":"Exerc\u00edcios b\u00e1sicos"},{"location":"aulas/10-malloc/#ferramentas-de-verificacao-de-memoria","text":"Para poder identificar mais facilmente problemas relativos a mem\u00f3ria, iremos utilizar uma ferramenta chamada Valgrind . Para saber mais sobre o valgrind acesse o link: https://diveintosystems.org/book/C3-C_debug/valgrind.html O Valgrind \u00e9 um detector de m\u00e1 gest\u00e3o de mem\u00f3ria. Ele roda seu programa em cima de um ambiente modificado e aponta os seguintes erros: mem\u00f3ria alocada e n\u00e3o liberada acessos (leituras e escritas) a posi\u00e7\u00f5es de mem\u00f3ria n\u00e3o alocada ou inv\u00e1lidas O valgrind est\u00e1 dispon\u00edvel na maioria das distribui\u00e7\u00f5es Linux modernas. Instale com: $ sudo apt update $ sudo apt install valgrind Dica \u00c9 recomend\u00e1vel manter o h\u00e1bito de atualizar o Linux de tempos em tempos. Fa\u00e7a com: $ sudo apt update $ sudo apt upgrade Para que os problemas encontrados pelo Valgrind sejam mais facilmente identificados, iremos passar a compilar utilizando a flag -g . Example Compile os programas ex1 e ex1-certo criados na parte anterior incluindo tamb\u00e9m a flag -g . $ gcc -Og -g -Wall -std = c99 ex1.c -o ex1 $ gcc -Og -g -Wall -std = c99 ex1-certo.c -o ex1-certo Exercise Rode o Valgrind com valgrind --leak-check=yes ./ex1 . Quantos erros foram encontrados? Quais s\u00e3o seus tipos (escrita ou leitura de dados)? O que eles significam? Answer Iremos discutir cada um dos erros! O primeiro erro encontrado \u00e9 ==1899== Invalid write of size 4 ==1899== at 0x1086C7: main (ex1.c:11) ==1899== Address 0x522f078 is 0 bytes after a block of size 56 alloc'd ==1899== at 0x4C31B0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==1899== by 0x1086B9: main (ex1.c:7) Exercise Em qual linha o erro ocorre? O que a mensagem acima significa? Answer O erro ocorre na linha 11, ao escrever em vetor[i] quando i == N O segundo erro \u00e9 ==1899== Invalid read of size 4 ==1899== at 0x1086DD: main (ex1.c:15) ==1899== Address 0x522f078 is 0 bytes after a block of size 56 alloc'd ==1899== at 0x4C31B0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==1899== by 0x1086B9: main (ex1.c:7) Exercise Em qual linha o erro ocorre? O que a mensagem acima significa? Answer O erro ocorre na linha 15, ao ler vetor[i] quando i == N . A se\u00e7\u00e3o HEAP SUMMARY faz um resumo dos dados alocados/desalocados no seu programa. A sa\u00edda abaixo foi obtida ao rodar o valgrind para o exerc\u00edcio 1 original: ==2179== HEAP SUMMARY: ==2179== in use at exit: 56 bytes in 1 blocks ==2179== total heap usage: 2 allocs, 1 frees, 1,080 bytes allocated ==2179== ==2179== 56 bytes in 1 blocks are definitely lost in loss record 1 of 1 ==2179== at 0x4C31B0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==2179== by 0x1086B9: main (ex1.c:7) Exercise Ela mostra algum problema? Se sim, qual linha de c\u00f3digo \u00e9 apontada? Qual \u00e9 o problema diagnosticado por este aviso? Answer Ela indica que houveram 2 mallocs' e somente 1 free . Ou seja, alguma aloca\u00e7\u00e3o de mem\u00f3ria deixou de liberar dados. Abaixo, s\u00e3o indicadas em quais linhas os malloc sem free ocorreram (linha 7 na fun\u00e7\u00e3o main`) Example Verifique que seu programa corrigido ex1-certo.c roda sem erros no valgrind. Se n\u00e3o, corrija os problema e rode novamente at\u00e9 que rode sem erros.","title":"Ferramentas de verifica\u00e7\u00e3o de mem\u00f3ria"},{"location":"aulas/10-malloc/#implementacoes-de-funcoes-entrega","text":"Os exerc\u00edcios abaixo est\u00e3o dispon\u00edveis no reposit\u00f3rio de entregas (pasta atv/08-malloc ). Dica! Leia o README.md na pasta da atividade! To Do Abra o arquivo copia_string.c e implemente a fun\u00e7\u00e3o mystrcpy . Esta fun\u00e7\u00e3o recebe uma string, e devolve uma c\u00f3pia da string original, alocando apenas o espa\u00e7o realmente necess\u00e1rio. To Do Abra o arquivo concatena_string.c e implemente a fun\u00e7\u00e3o mystrcat . Esta fun\u00e7\u00e3o recebe duas string, e devolve uma terceira que \u00e9 a concatena\u00e7\u00e3o das duas primeiras, alocando apenas o espa\u00e7o realmente necess\u00e1rio. Aten\u00e7\u00e3o! N\u00e3o se esque\u00e7a de checar se sua implementa\u00e7\u00e3o tem erros usando o valgrind.","title":"Implementa\u00e7\u00f5es de fun\u00e7\u00f5es (Entrega)"},{"location":"aulas/11-revisao/","text":"11 - Revis\u00e3o \u00b6 Na aula de hoje iremos revisar nossas atividades com Assembly e representa\u00e7\u00e3o de inteiros. Quando tiver d\u00favidas, chame o professor ou os ninjas! Importante Esta aula tem duas partes: Exerc\u00edcios de revis\u00e3o ( ex1.c , ex2.c , ex3.c e ex4.c ) Siga o roteiro para desenvolv\u00ea-los Simulado de prova Veja mais detalhes no final do roteiro! Ex1.c \u00b6 Abra o c\u00f3digo-fonte ex1.c e confira a fun\u00e7\u00e3o main . Compile e execute o exerc\u00edcio 1. Em seguida, responda: Exercise O valor apresentado na sa\u00edda confere com o presente no c\u00f3digo? Por que isto acontece? Answer O valor -1 em complemento de 2 \u00e9 representado como uma sequ\u00eancia de 1's. Ao ser atribu\u00eddo em uma unsigned short, teremos dezesseis 1's, mas que ser\u00e3o interpretados como unsigned. Somando 2^0 + 2^1 + \\dots + 2^{15} = 65535 2^0 + 2^1 + \\dots + 2^{15} = 65535 Exercise Qual o maior valor que pode ser armazenado em uma vari\u00e1vel unsigned short ? Answer A vari\u00e1vel ser\u00e1 de 2 bytes sem sinal, assim o maior valor \u00e9 2^{16}-1 = 65535 2^{16}-1 = 65535 Exercise O que acontece quando tentamos armazenar um valor maior que o suportado pelo tipo de dados? Ex: atribuir 80000 para uma unsigned short . Answer Apenas os 16 bits menos significativos ser\u00e3o considerados. Ex2.c \u00b6 Neste exerc\u00edcio iremos fazer engenharia reversa de Assembly para C. Os c\u00f3digos-fonte est\u00e3o dispon\u00edveis no reposit\u00f3rio, mas evite abri-los antes de ter feito pelo menos uma primeira vers\u00e3o da engenharia reversa. Compile o ex2.c com $ gcc -Wall -std = c99 -Og ex2.c -c -o ex2.o Abra o arquivo ex2.o com o gdb sem abrir o c\u00f3digo-fonte e responda: Exercise Liste as vari\u00e1veis globais e fun\u00e7\u00f5es existentes. Answer Fun\u00e7\u00f5es func1 e func2 . Sem vari\u00e1veis globais. Analise a fun\u00e7\u00e3o func1 com o gdb e responda: Exercise Com base nos registradores utilizados, escreva a assinatura da fun\u00e7\u00e3o func1 . Answer void func1 ( unsigned short * vec ) A partir de um ponteiro armazenado em %rdi , s\u00e3o feitas v\u00e1rias atribui\u00e7\u00f5es espa\u00e7adas em dois bytes, indicando ser um ponteiro para short . Exercise Em movw $0x0,(%rdi) , qual a opera\u00e7\u00e3o realizada e o que significa o trecho (%rdi) ? Answer A opera\u00e7\u00e3o \u00e9 vec[0] = 0 ou *vec = 0 . Como a opera\u00e7\u00e3o \u00e9 um MOV , ent\u00e3o (%rdi) representa uma dereferencia\u00e7\u00e3o de ponteiro. Tip Veja a se\u00e7\u00e3o Acesso a elementos constantes da aula 09 - Arrays Exercise Em movw $0x14,0x4(%rdi) , qual a opera\u00e7\u00e3o realizada e o que significa o trecho 0x4(%rdi) ? Answer A opera\u00e7\u00e3o \u00e9 vec[2] = 20 . Em 0x4(%rdi) , indicamos que queremos acessar o endere\u00e7o %rdi + 4 bytes . Tip Acese na aula 05-Condicionais a explica\u00e7\u00e3o sobre as vari\u00e2ntes da instru\u00e7\u00e3o mov Exercise Fa\u00e7a uma vers\u00e3o leg\u00edvel em C da fun\u00e7\u00e3o func1 . Answer void func1 ( unsigned short * vec ) { vec [ 0 ] = 0 ; vec [ 1 ] = 10 ; vec [ 2 ] = 20 ; } Analise a fun\u00e7\u00e3o func2 com o gdb e responda: Exercise Com base nos registradores utilizados, escreva a assinatura da fun\u00e7\u00e3o func2 . Answer void func2 ( int * vec , int n ) Caso restem d\u00favidas, chame os professores. Exercise Qual a opera\u00e7\u00e3o realizada em lea (%rax,%rax,4),%edx na fun\u00e7\u00e3o func2 ? Answer \u00c9 uma opera\u00e7\u00e3o aritm\u00e9tica onde o valor armazenado em %rax \u00e9 multiplicado por 5 e armazenado em %edx . Exercise Qual a opera\u00e7\u00e3o realizada em add %edx,%edx na fun\u00e7\u00e3o func2 ? Answer \u00c9 uma opera\u00e7\u00e3o aritm\u00e9tica onde o valor armazenado em %edx \u00e9 somado consigmo mesmo e armazenado em %edx . Isto \u00e9 equivalente a fazer var = var * 2 . Exercise Voc\u00ea conseguiria agregar as opera\u00e7\u00f5es lea (%rax,%rax,4),%edx e add %edx,%edx em uma \u00fanica opera\u00e7\u00e3o aritm\u00e9tica mais simples? Answer Supondo que %eax representa a vari\u00e1vel i , ent\u00e3o a jun\u00e7\u00e3o das duas opera\u00e7\u00f5es \u00e9 equivalente a fazer i * 10 , cujo resultado \u00e9 armazenado em %edx . Exercise Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer Vers\u00e3o if-goto : void func2 ( int * vec , int n ) { int i = 0 ; int aux ; goto test ; loop : aux = i * 5 ; aux = aux + aux ; vec [ i ] = aux ; i = i + 1 ; test : if ( i < n ) { goto loop : } return ; } Vers\u00e3o C : void func2 ( int * vec , int n ) { for ( int i = 0 ; i < n ; i ++ ) { vec [ i ] = i * 10 ; } } Caso restem d\u00favidas, chame os professores. Ex3.c \u00b6 Neste exerc\u00edcio iremos fazer engenharia reversa de Assembly para C. Os c\u00f3digos-fonte est\u00e3o dispon\u00edveis no reposit\u00f3rio, mas evite abri-los antes de ter feito pelo menos uma primeira vers\u00e3o da engenharia reversa. Compile o ex3.c com: $ gcc -Wall -std = c99 -Og ex3.c -o ex3 Abra o arquivo ex3 com o gdb sem abrir o c\u00f3digo-fonte e responda: Exercise Liste as fun\u00e7\u00f5es e vari\u00e1veis globais dispon\u00edveis. Answer Vari\u00e1vel global v_global . Fun\u00e7\u00f5es func1 , func2 , func3 , func4 e main . Exercise Fa\u00e7a a tradu\u00e7\u00e3o das fun\u00e7\u00f5es func1 e func2 . Existe alguma semelhan\u00e7a? Answer Ambas fazem opera\u00e7\u00f5es com registradores. Por\u00e9m func2 faz a leitura de algum valor de mem\u00f3ria e armazenando no retorno da fun\u00e7\u00e3o, uma vari\u00e1vel global. J\u00e1 func1 apenas faz uma opera\u00e7\u00e3o aritm\u00e9tica com o par\u00e2metro recebido. int func1 ( int n ) { int x = 10 ; return x + n ; } int func2 ( int n ) { return v_global + n ; } Tip Fique atento a chamadas de vari\u00e1veis globais. Utilize o comando x para imprimir o conte\u00fado de um endere\u00e7o. Veja mais em https://sourceware.org/gdb/current/onlinedocs/gdb#Memory Exemplo: x/d 0x100 x/s 0x100 Exercise Defina a assinatura da fun\u00e7\u00e3o func3 e fa\u00e7a sua tradu\u00e7\u00e3o para C. Answer int func3 ( int n , int mult ) { return v_global + n * mult ; } Exercise Defina a assinatura da fun\u00e7\u00e3o func4 . Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer Vers\u00e3o if-goto : void func4 () { res = func1 ( 5 ); if ( res <= 20 ) { goto faz_algo ; } printf ( \"O novo valor eh maior que 20\" ); retorna : return ; faz_algo : printf ( \"O novo valor nao eh maior que 20\" ); goto retorna ; } Vers\u00e3o C : void func4 () { int aux = func1 ( 5 ); if ( aux > 20 ) { printf ( \"O novo valor eh maior que 20\" ); } else { printf ( \"O novo valor nao eh maior que 20\" ); } } Ex4.c \u00b6 Neste exerc\u00edcio iremos fazer engenharia reversa de Assembly para C. Os c\u00f3digos-fonte est\u00e3o dispon\u00edveis no reposit\u00f3rio, mas evite abri-los antes de ter feito pelo menos uma primeira vers\u00e3o da engenharia reversa. Compile o ex4.c com: $ gcc -Wall -std = c99 -fno-stack-protector -Og ex4.c -o ex4 Abra o arquivo ex4 com o gdb sem abrir o c\u00f3digo-fonte e responda: Exercise Defina a assinatura da fun\u00e7\u00e3o ex4 . Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer Vers\u00e3o if-goto : int ex4 () { unsigned short n ; // variavel na pilha int ret ; int i ; int aux ; scanf ( \"%hu\" , & n ); i = 1 ; goto test ; loop : ret = ret + i * 4 ; i = i + 1 ; test : aux = n ; if ( aux > i ) { goto loop ; } return ret ; } Vers\u00e3o C : #include <stdio.h> int ex4 () { unsigned short n ; scanf ( \"%hu\" , & n ); int res = 0 ; int i = 1 ; while ( i < n ) { res += ( i * 4 ); i ++ ; } return res ; } int main () { return 0 ; } Tip Observe sempre as chamadas de vari\u00e1veis globais e strings (relativos a %rip ) e acessos \u00e0 stack (relativos a %rsp ). Simulado de prova \u00b6 Al\u00e9m dos exerc\u00edcios de revis\u00e3o feitos na aula, no Blackboard da disciplina est\u00e1 dispon\u00edvel o arquivo simulado_ai.zip , para baixar o arquivo acesse: Conteudo / AI-Simulado / Avalia\u00e7\u00e3o Intermedi\u00e1ria Simulado Siga as orienta\u00e7\u00f5es no Blackboard para fazer o downloado do simulado, na AI, voc\u00eas receber\u00e3o um arquivo semelhante a este. No dia da prova, voc\u00ea ter\u00e1 que baixar o zip, descompactar, resolver os exerc\u00edcios, compactar novamente e anexar no Blackboard. Tip Leia o README.md ou README.html para saber o que \u00e9 esperado em cada quest\u00e3o! Tip Leia o README.md ou README.html para saber como voc\u00ea ser\u00e1 avaliado!","title":"11 - Revis\u00e3o"},{"location":"aulas/11-revisao/#11-revisao","text":"Na aula de hoje iremos revisar nossas atividades com Assembly e representa\u00e7\u00e3o de inteiros. Quando tiver d\u00favidas, chame o professor ou os ninjas! Importante Esta aula tem duas partes: Exerc\u00edcios de revis\u00e3o ( ex1.c , ex2.c , ex3.c e ex4.c ) Siga o roteiro para desenvolv\u00ea-los Simulado de prova Veja mais detalhes no final do roteiro!","title":"11 - Revis\u00e3o"},{"location":"aulas/11-revisao/#ex1c","text":"Abra o c\u00f3digo-fonte ex1.c e confira a fun\u00e7\u00e3o main . Compile e execute o exerc\u00edcio 1. Em seguida, responda: Exercise O valor apresentado na sa\u00edda confere com o presente no c\u00f3digo? Por que isto acontece? Answer O valor -1 em complemento de 2 \u00e9 representado como uma sequ\u00eancia de 1's. Ao ser atribu\u00eddo em uma unsigned short, teremos dezesseis 1's, mas que ser\u00e3o interpretados como unsigned. Somando 2^0 + 2^1 + \\dots + 2^{15} = 65535 2^0 + 2^1 + \\dots + 2^{15} = 65535 Exercise Qual o maior valor que pode ser armazenado em uma vari\u00e1vel unsigned short ? Answer A vari\u00e1vel ser\u00e1 de 2 bytes sem sinal, assim o maior valor \u00e9 2^{16}-1 = 65535 2^{16}-1 = 65535 Exercise O que acontece quando tentamos armazenar um valor maior que o suportado pelo tipo de dados? Ex: atribuir 80000 para uma unsigned short . Answer Apenas os 16 bits menos significativos ser\u00e3o considerados.","title":"Ex1.c"},{"location":"aulas/11-revisao/#ex2c","text":"Neste exerc\u00edcio iremos fazer engenharia reversa de Assembly para C. Os c\u00f3digos-fonte est\u00e3o dispon\u00edveis no reposit\u00f3rio, mas evite abri-los antes de ter feito pelo menos uma primeira vers\u00e3o da engenharia reversa. Compile o ex2.c com $ gcc -Wall -std = c99 -Og ex2.c -c -o ex2.o Abra o arquivo ex2.o com o gdb sem abrir o c\u00f3digo-fonte e responda: Exercise Liste as vari\u00e1veis globais e fun\u00e7\u00f5es existentes. Answer Fun\u00e7\u00f5es func1 e func2 . Sem vari\u00e1veis globais. Analise a fun\u00e7\u00e3o func1 com o gdb e responda: Exercise Com base nos registradores utilizados, escreva a assinatura da fun\u00e7\u00e3o func1 . Answer void func1 ( unsigned short * vec ) A partir de um ponteiro armazenado em %rdi , s\u00e3o feitas v\u00e1rias atribui\u00e7\u00f5es espa\u00e7adas em dois bytes, indicando ser um ponteiro para short . Exercise Em movw $0x0,(%rdi) , qual a opera\u00e7\u00e3o realizada e o que significa o trecho (%rdi) ? Answer A opera\u00e7\u00e3o \u00e9 vec[0] = 0 ou *vec = 0 . Como a opera\u00e7\u00e3o \u00e9 um MOV , ent\u00e3o (%rdi) representa uma dereferencia\u00e7\u00e3o de ponteiro. Tip Veja a se\u00e7\u00e3o Acesso a elementos constantes da aula 09 - Arrays Exercise Em movw $0x14,0x4(%rdi) , qual a opera\u00e7\u00e3o realizada e o que significa o trecho 0x4(%rdi) ? Answer A opera\u00e7\u00e3o \u00e9 vec[2] = 20 . Em 0x4(%rdi) , indicamos que queremos acessar o endere\u00e7o %rdi + 4 bytes . Tip Acese na aula 05-Condicionais a explica\u00e7\u00e3o sobre as vari\u00e2ntes da instru\u00e7\u00e3o mov Exercise Fa\u00e7a uma vers\u00e3o leg\u00edvel em C da fun\u00e7\u00e3o func1 . Answer void func1 ( unsigned short * vec ) { vec [ 0 ] = 0 ; vec [ 1 ] = 10 ; vec [ 2 ] = 20 ; } Analise a fun\u00e7\u00e3o func2 com o gdb e responda: Exercise Com base nos registradores utilizados, escreva a assinatura da fun\u00e7\u00e3o func2 . Answer void func2 ( int * vec , int n ) Caso restem d\u00favidas, chame os professores. Exercise Qual a opera\u00e7\u00e3o realizada em lea (%rax,%rax,4),%edx na fun\u00e7\u00e3o func2 ? Answer \u00c9 uma opera\u00e7\u00e3o aritm\u00e9tica onde o valor armazenado em %rax \u00e9 multiplicado por 5 e armazenado em %edx . Exercise Qual a opera\u00e7\u00e3o realizada em add %edx,%edx na fun\u00e7\u00e3o func2 ? Answer \u00c9 uma opera\u00e7\u00e3o aritm\u00e9tica onde o valor armazenado em %edx \u00e9 somado consigmo mesmo e armazenado em %edx . Isto \u00e9 equivalente a fazer var = var * 2 . Exercise Voc\u00ea conseguiria agregar as opera\u00e7\u00f5es lea (%rax,%rax,4),%edx e add %edx,%edx em uma \u00fanica opera\u00e7\u00e3o aritm\u00e9tica mais simples? Answer Supondo que %eax representa a vari\u00e1vel i , ent\u00e3o a jun\u00e7\u00e3o das duas opera\u00e7\u00f5es \u00e9 equivalente a fazer i * 10 , cujo resultado \u00e9 armazenado em %edx . Exercise Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer Vers\u00e3o if-goto : void func2 ( int * vec , int n ) { int i = 0 ; int aux ; goto test ; loop : aux = i * 5 ; aux = aux + aux ; vec [ i ] = aux ; i = i + 1 ; test : if ( i < n ) { goto loop : } return ; } Vers\u00e3o C : void func2 ( int * vec , int n ) { for ( int i = 0 ; i < n ; i ++ ) { vec [ i ] = i * 10 ; } } Caso restem d\u00favidas, chame os professores.","title":"Ex2.c"},{"location":"aulas/11-revisao/#ex3c","text":"Neste exerc\u00edcio iremos fazer engenharia reversa de Assembly para C. Os c\u00f3digos-fonte est\u00e3o dispon\u00edveis no reposit\u00f3rio, mas evite abri-los antes de ter feito pelo menos uma primeira vers\u00e3o da engenharia reversa. Compile o ex3.c com: $ gcc -Wall -std = c99 -Og ex3.c -o ex3 Abra o arquivo ex3 com o gdb sem abrir o c\u00f3digo-fonte e responda: Exercise Liste as fun\u00e7\u00f5es e vari\u00e1veis globais dispon\u00edveis. Answer Vari\u00e1vel global v_global . Fun\u00e7\u00f5es func1 , func2 , func3 , func4 e main . Exercise Fa\u00e7a a tradu\u00e7\u00e3o das fun\u00e7\u00f5es func1 e func2 . Existe alguma semelhan\u00e7a? Answer Ambas fazem opera\u00e7\u00f5es com registradores. Por\u00e9m func2 faz a leitura de algum valor de mem\u00f3ria e armazenando no retorno da fun\u00e7\u00e3o, uma vari\u00e1vel global. J\u00e1 func1 apenas faz uma opera\u00e7\u00e3o aritm\u00e9tica com o par\u00e2metro recebido. int func1 ( int n ) { int x = 10 ; return x + n ; } int func2 ( int n ) { return v_global + n ; } Tip Fique atento a chamadas de vari\u00e1veis globais. Utilize o comando x para imprimir o conte\u00fado de um endere\u00e7o. Veja mais em https://sourceware.org/gdb/current/onlinedocs/gdb#Memory Exemplo: x/d 0x100 x/s 0x100 Exercise Defina a assinatura da fun\u00e7\u00e3o func3 e fa\u00e7a sua tradu\u00e7\u00e3o para C. Answer int func3 ( int n , int mult ) { return v_global + n * mult ; } Exercise Defina a assinatura da fun\u00e7\u00e3o func4 . Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer Vers\u00e3o if-goto : void func4 () { res = func1 ( 5 ); if ( res <= 20 ) { goto faz_algo ; } printf ( \"O novo valor eh maior que 20\" ); retorna : return ; faz_algo : printf ( \"O novo valor nao eh maior que 20\" ); goto retorna ; } Vers\u00e3o C : void func4 () { int aux = func1 ( 5 ); if ( aux > 20 ) { printf ( \"O novo valor eh maior que 20\" ); } else { printf ( \"O novo valor nao eh maior que 20\" ); } }","title":"Ex3.c"},{"location":"aulas/11-revisao/#ex4c","text":"Neste exerc\u00edcio iremos fazer engenharia reversa de Assembly para C. Os c\u00f3digos-fonte est\u00e3o dispon\u00edveis no reposit\u00f3rio, mas evite abri-los antes de ter feito pelo menos uma primeira vers\u00e3o da engenharia reversa. Compile o ex4.c com: $ gcc -Wall -std = c99 -fno-stack-protector -Og ex4.c -o ex4 Abra o arquivo ex4 com o gdb sem abrir o c\u00f3digo-fonte e responda: Exercise Defina a assinatura da fun\u00e7\u00e3o ex4 . Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer Vers\u00e3o if-goto : int ex4 () { unsigned short n ; // variavel na pilha int ret ; int i ; int aux ; scanf ( \"%hu\" , & n ); i = 1 ; goto test ; loop : ret = ret + i * 4 ; i = i + 1 ; test : aux = n ; if ( aux > i ) { goto loop ; } return ret ; } Vers\u00e3o C : #include <stdio.h> int ex4 () { unsigned short n ; scanf ( \"%hu\" , & n ); int res = 0 ; int i = 1 ; while ( i < n ) { res += ( i * 4 ); i ++ ; } return res ; } int main () { return 0 ; } Tip Observe sempre as chamadas de vari\u00e1veis globais e strings (relativos a %rip ) e acessos \u00e0 stack (relativos a %rsp ).","title":"Ex4.c"},{"location":"aulas/11-revisao/#simulado-de-prova","text":"Al\u00e9m dos exerc\u00edcios de revis\u00e3o feitos na aula, no Blackboard da disciplina est\u00e1 dispon\u00edvel o arquivo simulado_ai.zip , para baixar o arquivo acesse: Conteudo / AI-Simulado / Avalia\u00e7\u00e3o Intermedi\u00e1ria Simulado Siga as orienta\u00e7\u00f5es no Blackboard para fazer o downloado do simulado, na AI, voc\u00eas receber\u00e3o um arquivo semelhante a este. No dia da prova, voc\u00ea ter\u00e1 que baixar o zip, descompactar, resolver os exerc\u00edcios, compactar novamente e anexar no Blackboard. Tip Leia o README.md ou README.html para saber o que \u00e9 esperado em cada quest\u00e3o! Tip Leia o README.md ou README.html para saber como voc\u00ea ser\u00e1 avaliado!","title":"Simulado de prova"},{"location":"aulas/12-tipos-de-dados/","text":"12 - Tipos abstratos de dados \u00b6 A estrutura Point2D \u00b6 Vamos considerar primeiro uma estrutura usada para guardar um ponto 2D. Este tipo de estrutura seria \u00fatil ao trabalhar com algoritmos de Geometria Computacional ou mesmo em aplica\u00e7\u00f5es de f\u00edsica. typedef struct { double x , y ; } Point2D ; Vamos listar algumas opera\u00e7\u00f5es que podem ser feitas com um ponto: Inicializa\u00e7\u00e3o e finaliza\u00e7\u00e3o - todo ponto deve ser inicializado com algum valor para x e y. Somar dois pontos (e obter um terceiro); Calcular o coeficiente angular de uma reta que passe pelos dois pontos; Multiplicar ambas as coordenadas de um ponto (recebendo um novo em troca) - esta opera\u00e7\u00e3o equivale a mudan\u00e7as de escala Retornar os valores das componentes x e y do ponto; A ideia de um Tipo Abstrato de Dados \u00e9 formalizar um \"contrato\" que lista quais opera\u00e7\u00f5es podem ser feitas com este dado. Estas opera\u00e7\u00f5es n\u00e3o dependem de nenhuma implementa\u00e7\u00e3o em particular do tipo. Por exemplo, declarar o ponto com contendo um double coords[2] n\u00e3o muda os resultados de nenhuma das opera\u00e7\u00f5es acima mas mudaria o c\u00f3digo de acesso a coordenada x ( p.x vs p.coords[0] ). Veja um exemplo concreto de como fazer isto abaixo (arquivo point2d.h ). #ifndef __POINT2D__ #define __POINT2D__ typedef struct { double x , y ; } Point2D ; Point2D * point2D_new ( double x , double y ); void point2D_destroy ( Point2D * p ); double point2D_get_x ( Point2D * p ); double point2D_get_y ( Point2D * p ); Point2D * point2D_add ( Point2D * p1 , Point2D * p2 ); double point2D_theta ( Point2D * p1 , Point2D * p2 ); Point2D * point2D_scale ( Point2D * p , double s ); #endif Tip Em C declaramos os tipos abstratos de dados e as fun\u00e7\u00f5es que podem ser usadas por outras partes do c\u00f3digo em arquivos .h e implementamos essas fun\u00e7\u00f5es em arquivos .c (de mesmo nome, muitas vezes). Assim conseguimos organizar nosso c\u00f3digo em v\u00e1rios m\u00f3dulos e depois junt\u00e1-los no momento da compila\u00e7\u00e3o. Notem que essa lista de opera\u00e7\u00f5es \"toma conta\" da aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria. Ou seja, o usu\u00e1rio de nosso Point2D n\u00e3o precisa se preocupar com malloc ou free. Basta que ele chame nossas fun\u00e7\u00f5es. Por que todas as fun\u00e7\u00f5es come\u00e7am com point2D_ ? Em C n\u00e3o existe o conceito de m\u00f3dulo, namespace ou qualquer outro tipo de mecanismo de importar c\u00f3digo. Toda fun\u00e7\u00e3o, a princ\u00edpio, \u00e9 declarada no escopo global de nomes. Isso significa que se nome\u00e1ssemos point2D_add simplesmente como add nenhuma outra fun\u00e7\u00e3o escrita, por n\u00f3s ou de nenhuma outra biblioteca usada no nosso programa, poderia ter esse nome. A estrat\u00e9gia usada nesse caso, \u00e9 usar um prefixo que indique a qual biblioteca a fun\u00e7\u00e3o pertence. No nosso caso, usamos point2D_ em todas as fun\u00e7\u00f5es para evitar colis\u00f5es de nomes. Acessando as informa\u00e7\u00f5es do Tipo Abstrato de Dados \u00b6 Note que na declara\u00e7\u00e3o das fun\u00e7\u00f5es, algumas retornam um ponteiro para o Tipo Abstrato de Dados Point2D ou recebem como par\u00e2metro um ponteiro para esse tipo, em ambos os casos o ponteiro foi alocado dinamicamente na mem\u00f3ria . Para acessar as vari\u00e1veis do tipo Point2D ( x ou y ) devemos usar o operador -> . Por exemplo se temos uma vari\u00e1vel Point2D *p , o acesso \u00e0 x deve ser da seguinte forma p->x . Example Abra o arquivo test_point2d.c . Voc\u00ea consegue entender seu conte\u00fado? Examine o c\u00f3digo e entenda como Point2D deve ser usado. Exercise Compile o arquivo test_point2d.c usando a seguinte linha de comando. Rode-o logo em seguida. O que significa sua sa\u00edda? $ gcc -Og -Wall -g test_point2d.c point2d.c -o teste_ponto Responda aqui: Answer S\u00e3o realizadas chamadas de testes autom\u00e1ticos que tentam utilizar as funcionalidade de Point2D . Os testes falham porque as implementa\u00e7\u00f5es n\u00e3o foram realizadas. Example Abra o arquivo point2d.c e complete as partes faltantes. Verifique se tudo funciona corretamente usando test_point2d.c . Voc\u00ea deve aproveitar ao m\u00e1ximo as fun\u00e7\u00f5es j\u00e1 criadas (ou seja, pode usar point2d_new nas outras fun\u00e7\u00f5es). Example Agora que sua implementa\u00e7\u00e3o do TAD Point2D est\u00e1 completa, compile o arquivo test_point2d.c e execute-o usando o Valgrind . Seu programa dever\u00e1 rodar sem erros. Vetores din\u00e2micos \u00b6 Atividade para Entrega Os arquivos est\u00e3o na pasta 09-tad do reposit\u00f3rio de entregas. Dica! N\u00e3o se esque\u00e7a de ler o README.md dentro da pasta 09-tad ! Agora que j\u00e1 vimos vetores din\u00e2micos em aula, vamos implement\u00e1-los. Nosso vetor tem a seguinte interface: #ifndef __VECINT_H__ #define __VECINT_H__ typedef struct { int * data ; int size ; int capacity ; } vec_int ; vec_int * vec_int_create (); void vec_int_destroy ( vec_int ** v ); int vec_int_size ( vec_int * v ); /* As seguinte opera\u00e7\u00f5es devolvem * 1 se pos \u00e9 uma posi\u00e7\u00e3o v\u00e1lida e a opera\u00e7\u00e3o foi bem sucedida * 0 caso contr\u00e1rio * * No caso de at, o valor \u00e9 retornado na vari\u00e1vel apontada por vi. */ int vec_int_at ( vec_int * v , int pos , int * vi ); int vec_int_insert ( vec_int * v , int pos , int val ); int vec_int_remove ( vec_int * v , int pos ); #endif Example Entrega : implemente a estrutura vetor din\u00e2mico no arquivo vec_int.c e compile o programa de forma semelhante como foi feito na parte anterior. Para sua entrega estar 100% seu programa de testes dever\u00e1 rodar sem erros no valgrind . Dica! Leia os testes para entender as opera\u00e7\u00f5es realizadas e os resultados esperados!","title":"12 - Tipos abstratos de dados"},{"location":"aulas/12-tipos-de-dados/#12-tipos-abstratos-de-dados","text":"","title":"12 - Tipos abstratos de dados"},{"location":"aulas/12-tipos-de-dados/#a-estrutura-point2d","text":"Vamos considerar primeiro uma estrutura usada para guardar um ponto 2D. Este tipo de estrutura seria \u00fatil ao trabalhar com algoritmos de Geometria Computacional ou mesmo em aplica\u00e7\u00f5es de f\u00edsica. typedef struct { double x , y ; } Point2D ; Vamos listar algumas opera\u00e7\u00f5es que podem ser feitas com um ponto: Inicializa\u00e7\u00e3o e finaliza\u00e7\u00e3o - todo ponto deve ser inicializado com algum valor para x e y. Somar dois pontos (e obter um terceiro); Calcular o coeficiente angular de uma reta que passe pelos dois pontos; Multiplicar ambas as coordenadas de um ponto (recebendo um novo em troca) - esta opera\u00e7\u00e3o equivale a mudan\u00e7as de escala Retornar os valores das componentes x e y do ponto; A ideia de um Tipo Abstrato de Dados \u00e9 formalizar um \"contrato\" que lista quais opera\u00e7\u00f5es podem ser feitas com este dado. Estas opera\u00e7\u00f5es n\u00e3o dependem de nenhuma implementa\u00e7\u00e3o em particular do tipo. Por exemplo, declarar o ponto com contendo um double coords[2] n\u00e3o muda os resultados de nenhuma das opera\u00e7\u00f5es acima mas mudaria o c\u00f3digo de acesso a coordenada x ( p.x vs p.coords[0] ). Veja um exemplo concreto de como fazer isto abaixo (arquivo point2d.h ). #ifndef __POINT2D__ #define __POINT2D__ typedef struct { double x , y ; } Point2D ; Point2D * point2D_new ( double x , double y ); void point2D_destroy ( Point2D * p ); double point2D_get_x ( Point2D * p ); double point2D_get_y ( Point2D * p ); Point2D * point2D_add ( Point2D * p1 , Point2D * p2 ); double point2D_theta ( Point2D * p1 , Point2D * p2 ); Point2D * point2D_scale ( Point2D * p , double s ); #endif Tip Em C declaramos os tipos abstratos de dados e as fun\u00e7\u00f5es que podem ser usadas por outras partes do c\u00f3digo em arquivos .h e implementamos essas fun\u00e7\u00f5es em arquivos .c (de mesmo nome, muitas vezes). Assim conseguimos organizar nosso c\u00f3digo em v\u00e1rios m\u00f3dulos e depois junt\u00e1-los no momento da compila\u00e7\u00e3o. Notem que essa lista de opera\u00e7\u00f5es \"toma conta\" da aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria. Ou seja, o usu\u00e1rio de nosso Point2D n\u00e3o precisa se preocupar com malloc ou free. Basta que ele chame nossas fun\u00e7\u00f5es. Por que todas as fun\u00e7\u00f5es come\u00e7am com point2D_ ? Em C n\u00e3o existe o conceito de m\u00f3dulo, namespace ou qualquer outro tipo de mecanismo de importar c\u00f3digo. Toda fun\u00e7\u00e3o, a princ\u00edpio, \u00e9 declarada no escopo global de nomes. Isso significa que se nome\u00e1ssemos point2D_add simplesmente como add nenhuma outra fun\u00e7\u00e3o escrita, por n\u00f3s ou de nenhuma outra biblioteca usada no nosso programa, poderia ter esse nome. A estrat\u00e9gia usada nesse caso, \u00e9 usar um prefixo que indique a qual biblioteca a fun\u00e7\u00e3o pertence. No nosso caso, usamos point2D_ em todas as fun\u00e7\u00f5es para evitar colis\u00f5es de nomes.","title":"A estrutura Point2D"},{"location":"aulas/12-tipos-de-dados/#acessando-as-informacoes-do-tipo-abstrato-de-dados","text":"Note que na declara\u00e7\u00e3o das fun\u00e7\u00f5es, algumas retornam um ponteiro para o Tipo Abstrato de Dados Point2D ou recebem como par\u00e2metro um ponteiro para esse tipo, em ambos os casos o ponteiro foi alocado dinamicamente na mem\u00f3ria . Para acessar as vari\u00e1veis do tipo Point2D ( x ou y ) devemos usar o operador -> . Por exemplo se temos uma vari\u00e1vel Point2D *p , o acesso \u00e0 x deve ser da seguinte forma p->x . Example Abra o arquivo test_point2d.c . Voc\u00ea consegue entender seu conte\u00fado? Examine o c\u00f3digo e entenda como Point2D deve ser usado. Exercise Compile o arquivo test_point2d.c usando a seguinte linha de comando. Rode-o logo em seguida. O que significa sua sa\u00edda? $ gcc -Og -Wall -g test_point2d.c point2d.c -o teste_ponto Responda aqui: Answer S\u00e3o realizadas chamadas de testes autom\u00e1ticos que tentam utilizar as funcionalidade de Point2D . Os testes falham porque as implementa\u00e7\u00f5es n\u00e3o foram realizadas. Example Abra o arquivo point2d.c e complete as partes faltantes. Verifique se tudo funciona corretamente usando test_point2d.c . Voc\u00ea deve aproveitar ao m\u00e1ximo as fun\u00e7\u00f5es j\u00e1 criadas (ou seja, pode usar point2d_new nas outras fun\u00e7\u00f5es). Example Agora que sua implementa\u00e7\u00e3o do TAD Point2D est\u00e1 completa, compile o arquivo test_point2d.c e execute-o usando o Valgrind . Seu programa dever\u00e1 rodar sem erros.","title":"Acessando as informa\u00e7\u00f5es do Tipo Abstrato de Dados"},{"location":"aulas/12-tipos-de-dados/#vetores-dinamicos","text":"Atividade para Entrega Os arquivos est\u00e3o na pasta 09-tad do reposit\u00f3rio de entregas. Dica! N\u00e3o se esque\u00e7a de ler o README.md dentro da pasta 09-tad ! Agora que j\u00e1 vimos vetores din\u00e2micos em aula, vamos implement\u00e1-los. Nosso vetor tem a seguinte interface: #ifndef __VECINT_H__ #define __VECINT_H__ typedef struct { int * data ; int size ; int capacity ; } vec_int ; vec_int * vec_int_create (); void vec_int_destroy ( vec_int ** v ); int vec_int_size ( vec_int * v ); /* As seguinte opera\u00e7\u00f5es devolvem * 1 se pos \u00e9 uma posi\u00e7\u00e3o v\u00e1lida e a opera\u00e7\u00e3o foi bem sucedida * 0 caso contr\u00e1rio * * No caso de at, o valor \u00e9 retornado na vari\u00e1vel apontada por vi. */ int vec_int_at ( vec_int * v , int pos , int * vi ); int vec_int_insert ( vec_int * v , int pos , int val ); int vec_int_remove ( vec_int * v , int pos ); #endif Example Entrega : implemente a estrutura vetor din\u00e2mico no arquivo vec_int.c e compile o programa de forma semelhante como foi feito na parte anterior. Para sua entrega estar 100% seu programa de testes dever\u00e1 rodar sem erros no valgrind . Dica! Leia os testes para entender as opera\u00e7\u00f5es realizadas e os resultados esperados!","title":"Vetores din\u00e2micos"},{"location":"aulas/13-processos/","text":"13 - Processos \u00b6 A chamada fork \u00b6 A chamada fork cria um clone do processo atual e retorna duas vezes: uma vez no processo original (pai) e uma vez no processo novo (filho). Cada processo segue executando o programa linha a linha, por\u00e9m cada um possui \u00e1reas de mem\u00f3ria separadas. Ou seja, mudar uma vari\u00e1vel no processo pai n\u00e3o muda seu valor no filho (e vice-versa). Todo processo \u00e9 identificado por um n\u00famero chamado de pid . Tip O pid \u00e9 incrementado conforme novos processos v\u00e3o sendo iniciados. Considerando o c\u00f3digo abaixo (arquivo exemplo1-fork.c ), responda. pid_t pai , filho ; int variavel = 5 ; filho = fork (); if ( filho == 0 ) { // processo filho aqui pai = getppid (); filho = getpid (); variavel *= 2 ; printf ( \"eu sou o processo filho %d, meu pai \u00e9 %d \\n variavel %d \\n \" , filho , pai , variavel ); } else { // processo pai aqui! pai = getpid (); printf ( \"eu sou o processo pai %d, meu filho \u00e9 %d \\n variavel %d \\n \" , pai , filho , variavel ); } return 0 ; Responda os primeiros dois exerc\u00edcios sem rodar o programa ! Exercise Qual seria o valor de variavel no print do pai? e do filho? Answer No pai variavel vale 5 . No filho variavel vale 10 . Exercise Esse valor mudaria conforme o pai (ou o filho) executam primeiro? Answer N\u00e3o, isto mudaria apenas a ordem dos textos na tela. Uma vez realizado o fork , passamos a ter dois processos independentes em mem\u00f3ria e execu\u00e7\u00e3o. Example Compile e execute o programa acima. As suas respostas est\u00e3o corretas? $ gcc -Og -Wall -g exemplo1-fork.c -o exemplo1-fork $ ./exemplo1-fork Example Em um arquivo novo .c criado do zero, fa\u00e7a um programa que cria 8 processos filhos (numerados de 1 a 8) e faz cada um imprimir na tela seu seu identificador. O processo pai deve imprimir 0, enquanto o primeiro filho imprime 1, o segundo 2 e assim em diante. A sa\u00edda de seu programa dever\u00e1 seguir o modelo abaixo: Eu sou o processo pai, pid=%d, meu id do programa \u00e9 %d\\n Eu sou um processo filho, pid=%d, ppid=%d, meu id do programa \u00e9 %d\\n A primeira linha s\u00f3 deve ser mostrada uma vez pelo processo pai. Para verificar que seu programa funciona corretamente n\u00e3o se esque\u00e7a de contar quantos printf foram feitos. Se houver mais que 9 houve algum problema na sua solu\u00e7\u00e3o. Exercise O programa abaixo termina? Explique sua resposta. int rodando = 1 ; pid_t filho ; filho = fork (); if ( filho == 0 ) { printf ( \"Acabei filho \\n \" ); rodando = 0 ; } else { while ( rodando ) { printf ( \"Esperando o filho acabar! \\n \" ); sleep ( 1 ); } } return 0 ; Answer N\u00e3o. Uma vez realizado o fork , passamos a ter dois processo independentes em mem\u00f3ria e execu\u00e7\u00e3o. Como o c\u00f3digo rodando = 0 \u00e9 executado apenas no processo filho, esta a\u00e7\u00e3o n\u00e3o tem efeito no processo pai, que \u00e9 onde ser\u00e1 executado o while . Se ficou com d\u00favidas por que o bloco verdadeiro do if \u00e9 executado apenas no filho e o bloco falso apenas no pai, pe\u00e7a ajuda ao professor! As chamadas wait/waitpid \u00b6 Um processo pode esperar seus filhos acabarem usando uma das chamadas wait ou waitpid . Esta chamada retorna um c\u00f3digo num\u00e9rico que representa a sa\u00edda do programa (o que foi retornado pelo main ) e um conjunto de flags que indica se houve t\u00e9rmino anormal. O c\u00f3digo errado do \u00faltimo exerc\u00edcio tentava simular estas chamadas usando uma vari\u00e1vel rodando e checando seu valor. A maneira correta de esperar um processo filho terminar \u00e9 usando wait ou waitpid . Exercise Pesquise como usar wait no manual. Escreva abaixo a assinatura da fun\u00e7\u00e3o. Qual \u00e9 o valor retornado? O que \u00e9 retornado na var\u00edavel passada como ponteiro? Answer Aqui est\u00e1 a sa\u00edda do man wait . Execute em seu terminal para ver a sa\u00edda completa! $ man 2 wait WAIT(2) Linux Programmer's Manual WAIT(2) NAME wait, waitpid, waitid - wait for process to change state SYNOPSIS # include <sys/types.h> # include <sys/wait.h> pid_t wait(int *wstatus); pid_t waitpid(pid_t pid, int *wstatus, int options); int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); /* This is the glibc and POSIX interface; see NOTES for information on the raw system call. */ Feature Test Macro Requirements for glibc (see feature_test_macros(7)): Example Modifique o programa exemplo2-errado.c para usar wait para esperar o processo filho terminar. Ap\u00f3s o filho terminar o pai deve mostrar uma mensagem na tela indicando este fato. Salve este arquivo como exemplo2-certo.c Exercise \u00c9 poss\u00edvel obter o valor retornado pelo main de um processo usando wait . Pesquise no manual como faz\u00ea-lo. Dica : procure por exit status . Answer Confira com o professor! Example Modifique o exemplo2-certo.c para que o filho retorne 2 e modifique o pai para que ele obtenha esta informa\u00e7\u00e3o a partir dos valores retornados pelo wait . Voc\u00ea precisar\u00e1 ler o manual de wait para fazer este exerc\u00edcio. Exerc\u00edcios Extras \u00b6 Estes exerc\u00edcios n\u00e3o s\u00e3o para entrega. Utilize esta lista para praticar os assuntos aprendidos na aula. Exercise Fa\u00e7a um programa que l\u00ea um n\u00famero inteiro. Em dois processos filhos, deve ser calculado e impresso o dobro e a metade desse n\u00famero. Exercise Fa\u00e7a um programa em que o processo pai l\u00ea dois valores inteiros ( n1 e n2 ). Em seguida, s\u00e3o criados 4 processos filhos. Com os valores lidos pelo pai, os filhos devem calcular e imprimir em paralelo as seguintes opera\u00e7\u00f5es. n1 \u2013 n2 n1 + n2 n1 / n2 n1 * n2 Exercise Fa\u00e7a um programa que crie um grupo de processos conforme a hierarquia apresentado abaixo, cada filho deve imprimir o seu PID e o PID do processo que o criou. Exercise Fa\u00e7a um programa que l\u00ea um n\u00famero inteiro indicando o n\u00famero de filhos que o pai ter\u00e1 que criar. Ou seja, todos os processos filhos s\u00e3o do mesmo pai. Crie o n\u00famero de processos solicitado. Cada filho deve: Esperar por 5 segundos assim que for criado Imprimir: O seu n\u00famero de ordem de cria\u00e7\u00e3o O seu PID O PID do processo pai. Sair retornando 0 . Super importante! Caso ainda n\u00e3o tenha feito, reescreva os exerc\u00edcios anteriores para que o pai s\u00f3 seja finalizado quando todos os seus filhos j\u00e1 tenham terminado sua execu\u00e7\u00e3o. Exercise Dado um vetor A de n elementos e uma vari\u00e1vel c , fa\u00e7a um programa paralelo para determinar a quantidade de elementos de A que s\u00e3o menores que c . Cada filho deve imprimir a quantidade de elementos de A que s\u00e3o menores que c . Obs : Voc\u00ea pode escolher o tipo do vetor (int, char, long, short) Leia o n , aloque o vetor dinamicamente e ent\u00e3o leia todos os elementos do vetor Suponha que n \u00e9 m\u00faltiplo do n\u00famero de filhos criados pelo processo pai Voc\u00ea pode escolher o n\u00famero de filhos criados pelo pai.","title":"13 - Processos"},{"location":"aulas/13-processos/#13-processos","text":"","title":"13 - Processos"},{"location":"aulas/13-processos/#a-chamada-fork","text":"A chamada fork cria um clone do processo atual e retorna duas vezes: uma vez no processo original (pai) e uma vez no processo novo (filho). Cada processo segue executando o programa linha a linha, por\u00e9m cada um possui \u00e1reas de mem\u00f3ria separadas. Ou seja, mudar uma vari\u00e1vel no processo pai n\u00e3o muda seu valor no filho (e vice-versa). Todo processo \u00e9 identificado por um n\u00famero chamado de pid . Tip O pid \u00e9 incrementado conforme novos processos v\u00e3o sendo iniciados. Considerando o c\u00f3digo abaixo (arquivo exemplo1-fork.c ), responda. pid_t pai , filho ; int variavel = 5 ; filho = fork (); if ( filho == 0 ) { // processo filho aqui pai = getppid (); filho = getpid (); variavel *= 2 ; printf ( \"eu sou o processo filho %d, meu pai \u00e9 %d \\n variavel %d \\n \" , filho , pai , variavel ); } else { // processo pai aqui! pai = getpid (); printf ( \"eu sou o processo pai %d, meu filho \u00e9 %d \\n variavel %d \\n \" , pai , filho , variavel ); } return 0 ; Responda os primeiros dois exerc\u00edcios sem rodar o programa ! Exercise Qual seria o valor de variavel no print do pai? e do filho? Answer No pai variavel vale 5 . No filho variavel vale 10 . Exercise Esse valor mudaria conforme o pai (ou o filho) executam primeiro? Answer N\u00e3o, isto mudaria apenas a ordem dos textos na tela. Uma vez realizado o fork , passamos a ter dois processos independentes em mem\u00f3ria e execu\u00e7\u00e3o. Example Compile e execute o programa acima. As suas respostas est\u00e3o corretas? $ gcc -Og -Wall -g exemplo1-fork.c -o exemplo1-fork $ ./exemplo1-fork Example Em um arquivo novo .c criado do zero, fa\u00e7a um programa que cria 8 processos filhos (numerados de 1 a 8) e faz cada um imprimir na tela seu seu identificador. O processo pai deve imprimir 0, enquanto o primeiro filho imprime 1, o segundo 2 e assim em diante. A sa\u00edda de seu programa dever\u00e1 seguir o modelo abaixo: Eu sou o processo pai, pid=%d, meu id do programa \u00e9 %d\\n Eu sou um processo filho, pid=%d, ppid=%d, meu id do programa \u00e9 %d\\n A primeira linha s\u00f3 deve ser mostrada uma vez pelo processo pai. Para verificar que seu programa funciona corretamente n\u00e3o se esque\u00e7a de contar quantos printf foram feitos. Se houver mais que 9 houve algum problema na sua solu\u00e7\u00e3o. Exercise O programa abaixo termina? Explique sua resposta. int rodando = 1 ; pid_t filho ; filho = fork (); if ( filho == 0 ) { printf ( \"Acabei filho \\n \" ); rodando = 0 ; } else { while ( rodando ) { printf ( \"Esperando o filho acabar! \\n \" ); sleep ( 1 ); } } return 0 ; Answer N\u00e3o. Uma vez realizado o fork , passamos a ter dois processo independentes em mem\u00f3ria e execu\u00e7\u00e3o. Como o c\u00f3digo rodando = 0 \u00e9 executado apenas no processo filho, esta a\u00e7\u00e3o n\u00e3o tem efeito no processo pai, que \u00e9 onde ser\u00e1 executado o while . Se ficou com d\u00favidas por que o bloco verdadeiro do if \u00e9 executado apenas no filho e o bloco falso apenas no pai, pe\u00e7a ajuda ao professor!","title":"A chamada fork"},{"location":"aulas/13-processos/#as-chamadas-waitwaitpid","text":"Um processo pode esperar seus filhos acabarem usando uma das chamadas wait ou waitpid . Esta chamada retorna um c\u00f3digo num\u00e9rico que representa a sa\u00edda do programa (o que foi retornado pelo main ) e um conjunto de flags que indica se houve t\u00e9rmino anormal. O c\u00f3digo errado do \u00faltimo exerc\u00edcio tentava simular estas chamadas usando uma vari\u00e1vel rodando e checando seu valor. A maneira correta de esperar um processo filho terminar \u00e9 usando wait ou waitpid . Exercise Pesquise como usar wait no manual. Escreva abaixo a assinatura da fun\u00e7\u00e3o. Qual \u00e9 o valor retornado? O que \u00e9 retornado na var\u00edavel passada como ponteiro? Answer Aqui est\u00e1 a sa\u00edda do man wait . Execute em seu terminal para ver a sa\u00edda completa! $ man 2 wait WAIT(2) Linux Programmer's Manual WAIT(2) NAME wait, waitpid, waitid - wait for process to change state SYNOPSIS # include <sys/types.h> # include <sys/wait.h> pid_t wait(int *wstatus); pid_t waitpid(pid_t pid, int *wstatus, int options); int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); /* This is the glibc and POSIX interface; see NOTES for information on the raw system call. */ Feature Test Macro Requirements for glibc (see feature_test_macros(7)): Example Modifique o programa exemplo2-errado.c para usar wait para esperar o processo filho terminar. Ap\u00f3s o filho terminar o pai deve mostrar uma mensagem na tela indicando este fato. Salve este arquivo como exemplo2-certo.c Exercise \u00c9 poss\u00edvel obter o valor retornado pelo main de um processo usando wait . Pesquise no manual como faz\u00ea-lo. Dica : procure por exit status . Answer Confira com o professor! Example Modifique o exemplo2-certo.c para que o filho retorne 2 e modifique o pai para que ele obtenha esta informa\u00e7\u00e3o a partir dos valores retornados pelo wait . Voc\u00ea precisar\u00e1 ler o manual de wait para fazer este exerc\u00edcio.","title":"As chamadas wait/waitpid"},{"location":"aulas/13-processos/#exercicios-extras","text":"Estes exerc\u00edcios n\u00e3o s\u00e3o para entrega. Utilize esta lista para praticar os assuntos aprendidos na aula. Exercise Fa\u00e7a um programa que l\u00ea um n\u00famero inteiro. Em dois processos filhos, deve ser calculado e impresso o dobro e a metade desse n\u00famero. Exercise Fa\u00e7a um programa em que o processo pai l\u00ea dois valores inteiros ( n1 e n2 ). Em seguida, s\u00e3o criados 4 processos filhos. Com os valores lidos pelo pai, os filhos devem calcular e imprimir em paralelo as seguintes opera\u00e7\u00f5es. n1 \u2013 n2 n1 + n2 n1 / n2 n1 * n2 Exercise Fa\u00e7a um programa que crie um grupo de processos conforme a hierarquia apresentado abaixo, cada filho deve imprimir o seu PID e o PID do processo que o criou. Exercise Fa\u00e7a um programa que l\u00ea um n\u00famero inteiro indicando o n\u00famero de filhos que o pai ter\u00e1 que criar. Ou seja, todos os processos filhos s\u00e3o do mesmo pai. Crie o n\u00famero de processos solicitado. Cada filho deve: Esperar por 5 segundos assim que for criado Imprimir: O seu n\u00famero de ordem de cria\u00e7\u00e3o O seu PID O PID do processo pai. Sair retornando 0 . Super importante! Caso ainda n\u00e3o tenha feito, reescreva os exerc\u00edcios anteriores para que o pai s\u00f3 seja finalizado quando todos os seus filhos j\u00e1 tenham terminado sua execu\u00e7\u00e3o. Exercise Dado um vetor A de n elementos e uma vari\u00e1vel c , fa\u00e7a um programa paralelo para determinar a quantidade de elementos de A que s\u00e3o menores que c . Cada filho deve imprimir a quantidade de elementos de A que s\u00e3o menores que c . Obs : Voc\u00ea pode escolher o tipo do vetor (int, char, long, short) Leia o n , aloque o vetor dinamicamente e ent\u00e3o leia todos os elementos do vetor Suponha que n \u00e9 m\u00faltiplo do n\u00famero de filhos criados pelo processo pai Voc\u00ea pode escolher o n\u00famero de filhos criados pelo pai.","title":"Exerc\u00edcios Extras"},{"location":"aulas/14-exec/","text":"14 - Carregamento de programas \u00b6 Argumentos de um programa \u00b6 Leia com aten\u00e7\u00e3o o c\u00f3digo antes de responder os pr\u00f3ximos exerc\u00edcios. int main ( int argc , char * argv []) { for ( int i = 0 ; i < argc ; i ++ ) { printf ( \"arg: %s \\n \" , argv [ i ]); } return 0 ; } Suponha que o c\u00f3digo exemplo-args.c acima foi compilado para o programa exemplo-args . Considerando a invoca\u00e7\u00e3o a seguir exemplo-args teste var bla foo , responda \u00e0s perguntas abaixo sem rodar o programa . Exercise Qual os valores de argc e argv ? argc=1, argv={\"exemplo-args\"} argc=5, argv={\"exemplo-args\", \"teste\", \"var\", \"bla\", \"foo\"} argc=4, argv={\"teste\", \"var\", \"bla\", \"foo\"} argc=3, argv={\"teste\", \"var\", \"bla\", \"foo\"} Resposta S\u00e3o 5 argumentos, contando com argv[0] sendo o nome do programa chamado. Exercise Qual seria a sa\u00edda do programa para a invoca\u00e7\u00e3o acima? Resposta exemplo-args teste var bla foo Exercise Qual o significado de argv[0] ? Resposta \u00c9 o nome do programa chamado. Example Crie um programa soma que tem o seguinte comportamento: Se o programa for chamado com menos de 2 argumentos mostrar mensagem de erro e sair. Se o programa for chamado com 2 ou mais argumentos, mostrar no terminal a soma deles. Se um argumento n\u00e3o for um n\u00famero consider\u00e1-lo como 0. Dica : execute man atof no terminal ;) Carregando novos programas com exec \u00b6 A chamada exec \u00e9 usada para carregar programas na mem\u00f3ria e execut\u00e1-los. O novo programa \u00e9 carregado no contexto do processo atual, substituindo-o por completo. Veja um exemplo de uso correto do execvp abaixo, o c\u00f3digo fonte est\u00e1 em exemplo-exec.c . char prog [] = \"ls\" ; // a lista de argumentos sempre come\u00e7a com o nome do // programa e termina com NULL char * args [] = { \"ls\" , \"-l\" , \"-a\" , NULL }; execvp ( prog , args ); printf ( \"Fim do exec! \\n \" ); Exercise Supondo que o execvp funcione, a linha printf(\"Fim do exec!\\n\") executa? SIM N\u00c3O Resposta A linha n\u00e3o \u00e9 executada se o execvp funcionar. O programa antigo \u00e9 completamente substitu\u00eddo pelo novo programa quando o execvp funciona. Os argumentos passados no execvp s\u00e3o passados para o main do programa executado via argumentos do main . Ao fazer a chamada char prog [] = \"prog1\" ; char * args [] = { \"prog1\" , \"arg1\" , \"arg2\" , NULL }; execvp ( prog , args ); Exercise Qual \u00e9 o valor de argc e argv passado para prog1 ? argc=1, argv={\"prog1\"} argc=3, argv={\"prog1\", \"arg1\", \"arg2\"} argc=2, argv={\"arg1\", \"arg2\"} argc=4, argv={\"prog1\", \"arg1\", \"arg2\", NULL} Resposta Ser\u00e3o tr\u00eas argumentos! if duvidas then man! Caso tenha d\u00favidas, lembre-se do comando man . Explore o manual do execvp com: $ man 3 execvp Warning Os dois pr\u00f3ximos exerc\u00edcios voc\u00ea come\u00e7ar o programa do zero (vazio), pois adaptar exemplos anteriores, apesar de pr\u00e1tico, atrapalha a memoriza\u00e7\u00e3o dos comandos usados. Executando programas fora do PATH do sistema Nos exemplos de exec , supomos que os programas a serem executados estavam no PATH do sistema. Caso voc\u00ea queira subir algum execut\u00e1vel que est\u00e1 na pr\u00f3pria pasta do seu projeto (ou em qualquer caminho fixo/relativo conhecido), utilize algo como ( lembre do ./ ): // Lembre de usar \"./\" neste caso char * args [] = { \"./meuprograma\" , NULL }; if ( execvp ( args [ 0 ], args ) == -1 ) { perror ( \"execvp failed!\" ); exit ( EXIT_FAILURE ); } V\u00e1rias formas de chamar exec No manual, percebemos que temos v\u00e1rias chamadas de exec: execl , execlp , execle , execv , execvp e execvpe . Releia prestando aten\u00e7\u00e3o nas diferen\u00e7as. Aqui, um aux\u00edlio de IA ser\u00e1 \u00fatil! Abra o link https://chatbot.theb.ai/ e fa\u00e7a perguntas como: \"whats the difference between C functions execv and execvp?\" . Solicite exemplos e valide c\u00f3digos! Exercice Crie um programa eh_par que recebe um inteiro como argumento de linha de comando e cujo main retorne 1 se o n\u00famero for par, 0 caso contr\u00e1rio e -1 se ele for negativo. Dicas : pesquise a fun\u00e7\u00e3o atol para fazer a convers\u00e3o do argumento de linha de comando para long . voc\u00ea pode testar seu programa no terminal: basta rodar eh_par 10 para checar se o n\u00famero 10 \u00e9 par. para ver o valor de sa\u00edda do \u00faltimo programa rodado execute echo $? crie um arquivo eh_par.c e compile para eh_par Vamos agora juntar fork , wait e exec em um \u00fanico exerc\u00edcio! Exercice Crie um programa que recebe n\u00fameros via scanf , executa eh_par em um processo filho e usa seu valor de retorno para decidir se o n\u00famero \u00e9 par ou n\u00e3o. Seu programa dever\u00e1 parar de receber n\u00fameros quando eh_par retornar -1. Dica : voc\u00ea pode usar sprintf para converter o inteiro lido para string. Se n\u00e3o souber como usar consulte o manual executando man sprintf no terminal.","title":"14 - Carregamento de programas"},{"location":"aulas/14-exec/#14-carregamento-de-programas","text":"","title":"14 - Carregamento de programas"},{"location":"aulas/14-exec/#argumentos-de-um-programa","text":"Leia com aten\u00e7\u00e3o o c\u00f3digo antes de responder os pr\u00f3ximos exerc\u00edcios. int main ( int argc , char * argv []) { for ( int i = 0 ; i < argc ; i ++ ) { printf ( \"arg: %s \\n \" , argv [ i ]); } return 0 ; } Suponha que o c\u00f3digo exemplo-args.c acima foi compilado para o programa exemplo-args . Considerando a invoca\u00e7\u00e3o a seguir exemplo-args teste var bla foo , responda \u00e0s perguntas abaixo sem rodar o programa . Exercise Qual os valores de argc e argv ? argc=1, argv={\"exemplo-args\"} argc=5, argv={\"exemplo-args\", \"teste\", \"var\", \"bla\", \"foo\"} argc=4, argv={\"teste\", \"var\", \"bla\", \"foo\"} argc=3, argv={\"teste\", \"var\", \"bla\", \"foo\"} Resposta S\u00e3o 5 argumentos, contando com argv[0] sendo o nome do programa chamado. Exercise Qual seria a sa\u00edda do programa para a invoca\u00e7\u00e3o acima? Resposta exemplo-args teste var bla foo Exercise Qual o significado de argv[0] ? Resposta \u00c9 o nome do programa chamado. Example Crie um programa soma que tem o seguinte comportamento: Se o programa for chamado com menos de 2 argumentos mostrar mensagem de erro e sair. Se o programa for chamado com 2 ou mais argumentos, mostrar no terminal a soma deles. Se um argumento n\u00e3o for um n\u00famero consider\u00e1-lo como 0. Dica : execute man atof no terminal ;)","title":"Argumentos de um programa"},{"location":"aulas/14-exec/#carregando-novos-programas-com-exec","text":"A chamada exec \u00e9 usada para carregar programas na mem\u00f3ria e execut\u00e1-los. O novo programa \u00e9 carregado no contexto do processo atual, substituindo-o por completo. Veja um exemplo de uso correto do execvp abaixo, o c\u00f3digo fonte est\u00e1 em exemplo-exec.c . char prog [] = \"ls\" ; // a lista de argumentos sempre come\u00e7a com o nome do // programa e termina com NULL char * args [] = { \"ls\" , \"-l\" , \"-a\" , NULL }; execvp ( prog , args ); printf ( \"Fim do exec! \\n \" ); Exercise Supondo que o execvp funcione, a linha printf(\"Fim do exec!\\n\") executa? SIM N\u00c3O Resposta A linha n\u00e3o \u00e9 executada se o execvp funcionar. O programa antigo \u00e9 completamente substitu\u00eddo pelo novo programa quando o execvp funciona. Os argumentos passados no execvp s\u00e3o passados para o main do programa executado via argumentos do main . Ao fazer a chamada char prog [] = \"prog1\" ; char * args [] = { \"prog1\" , \"arg1\" , \"arg2\" , NULL }; execvp ( prog , args ); Exercise Qual \u00e9 o valor de argc e argv passado para prog1 ? argc=1, argv={\"prog1\"} argc=3, argv={\"prog1\", \"arg1\", \"arg2\"} argc=2, argv={\"arg1\", \"arg2\"} argc=4, argv={\"prog1\", \"arg1\", \"arg2\", NULL} Resposta Ser\u00e3o tr\u00eas argumentos! if duvidas then man! Caso tenha d\u00favidas, lembre-se do comando man . Explore o manual do execvp com: $ man 3 execvp Warning Os dois pr\u00f3ximos exerc\u00edcios voc\u00ea come\u00e7ar o programa do zero (vazio), pois adaptar exemplos anteriores, apesar de pr\u00e1tico, atrapalha a memoriza\u00e7\u00e3o dos comandos usados. Executando programas fora do PATH do sistema Nos exemplos de exec , supomos que os programas a serem executados estavam no PATH do sistema. Caso voc\u00ea queira subir algum execut\u00e1vel que est\u00e1 na pr\u00f3pria pasta do seu projeto (ou em qualquer caminho fixo/relativo conhecido), utilize algo como ( lembre do ./ ): // Lembre de usar \"./\" neste caso char * args [] = { \"./meuprograma\" , NULL }; if ( execvp ( args [ 0 ], args ) == -1 ) { perror ( \"execvp failed!\" ); exit ( EXIT_FAILURE ); } V\u00e1rias formas de chamar exec No manual, percebemos que temos v\u00e1rias chamadas de exec: execl , execlp , execle , execv , execvp e execvpe . Releia prestando aten\u00e7\u00e3o nas diferen\u00e7as. Aqui, um aux\u00edlio de IA ser\u00e1 \u00fatil! Abra o link https://chatbot.theb.ai/ e fa\u00e7a perguntas como: \"whats the difference between C functions execv and execvp?\" . Solicite exemplos e valide c\u00f3digos! Exercice Crie um programa eh_par que recebe um inteiro como argumento de linha de comando e cujo main retorne 1 se o n\u00famero for par, 0 caso contr\u00e1rio e -1 se ele for negativo. Dicas : pesquise a fun\u00e7\u00e3o atol para fazer a convers\u00e3o do argumento de linha de comando para long . voc\u00ea pode testar seu programa no terminal: basta rodar eh_par 10 para checar se o n\u00famero 10 \u00e9 par. para ver o valor de sa\u00edda do \u00faltimo programa rodado execute echo $? crie um arquivo eh_par.c e compile para eh_par Vamos agora juntar fork , wait e exec em um \u00fanico exerc\u00edcio! Exercice Crie um programa que recebe n\u00fameros via scanf , executa eh_par em um processo filho e usa seu valor de retorno para decidir se o n\u00famero \u00e9 par ou n\u00e3o. Seu programa dever\u00e1 parar de receber n\u00fameros quando eh_par retornar -1. Dica : voc\u00ea pode usar sprintf para converter o inteiro lido para string. Se n\u00e3o souber como usar consulte o manual executando man sprintf no terminal.","title":"Carregando novos programas com exec"},{"location":"aulas/15-entrada-saida/","text":"15 - Entrada/Sa\u00edda \u00b6 Trabalhando com arquivos \u00b6 Nesta se\u00e7\u00e3o trabalharemos com as chamadas open , close , read e write . Exercise Leia o c\u00f3digo do arquivo exemplo_io1.c . O qu\u00ea ele faz? Resposta L\u00ea os 5 primeiros caracteres de um arquivo. O arquivo lido \u00e9 passado via terminal. Vamos agora usar o comando man para ver a documenta\u00e7\u00e3o das chamadas de sistema do Linux. Digite no terminal man read . A tela mostrada cont\u00e9m a documenta\u00e7\u00e3o da fun\u00e7\u00e3o read , incluindo sua assinatura e quais cabe\u00e7alhos devem ser inclu\u00eddos para que ela possa ser usada. $ man read Exercise Usando como apoio a documenta\u00e7\u00e3o aberta pelo comando man , como saber que um arquivo foi lido at\u00e9 o fim? Dica : a se\u00e7\u00e3o RETURN VALUE pode te ajudar. Resposta A fun\u00e7\u00e3o read retorna o n\u00famero de caracteres efetivamente lidos. Ela retorna 0 quando o arquivo acabou. A fun\u00e7\u00e3o s\u00f3 retorna quando os caracteres forem lidos, ent\u00e3o ela pode bloquear o programa. Tip Para acelerar suas buscas no man voc\u00ea pode ativar a busca pressionando / . A\u00ed basta digitar o termo procurado. Para avan\u00e7ar para as pr\u00f3ximas ocorr\u00eancias de um termo basta apertar / + Enter . Example Baseado em sua resposta acima, modifique exemplo_io1.c para que ele mostre o todo o conte\u00fado do arquivo. Vamos agora trabalhar com a chamada write . Um exemplo de seu uso est\u00e1 mostrado no arquivo exemplo_io2.c . Exercise Abra o arquivo exemplo_io2.c e explique abaixo como usar write . Se ficar em d\u00favida use o manual ( man write ). Resposta write recebe o identificador do arquivo, um endere\u00e7o de mem\u00f3ria e o n\u00famero de bytes que devem ser copiados deste endere\u00e7o para o arquivo. $ man write Example Em um novo arquivo copy_file.c , crie um programa copy_file que recebe dois nomes de arquivos como argumentos no terminal e copia o conte\u00fado do primeiro para o segundo. Ou seja, voc\u00ea dever\u00e1 abrir ambos arquivos (cada um ter\u00e1 seu pr\u00f3prio file descriptor ) enquanto n\u00e3o chegar ao final do primeiro arquivo ler do primeiro para um buffer escrever este buffer no segundo fecha os dois arquivos Validando Ap\u00f3s compilar, teste sua solu\u00e7\u00e3o com um arquivo qualquer e utilize diff ou cmp para comparar os arquivos. $ ./copy_file arquivo_origem.txt arquivo_destino.txt $ diff arquivo_origem.txt arquivo_destino.txt $ cmp arquivo_origem.txt arquivo_destino.txt Extra \u00b6 Estes exerc\u00edcios n\u00e3o ter\u00e3o corre\u00e7\u00e3o durante a aula e devem ser checados no atendimento. Fa\u00e7a-os se voc\u00ea j\u00e1 acabou os anteriores e a corre\u00e7\u00e3o/discuss\u00e3o ainda n\u00e3o come\u00e7ou. At\u00e9 agora trabalhamos com um buffer com somente um caractere. Isso facilita a programa\u00e7\u00e3o, mas deixa nosso c\u00f3digo muito lento. Example Modifique o copy_file para usar um buffer de 100 caracteres. Me\u00e7a o tempo de execu\u00e7\u00e3o para a c\u00f3pia de um arquivo grande (~100Mb) usando o comando time . N\u00e3o se esque\u00e7a de verificar que os resultados ficaram iguais com o comando diff . O comando time tem como sa\u00edda tr\u00eas informa\u00e7\u00f5es sobre o processo executado: Tempo Real ( real ): O tempo que real que levou para executar o comando, do in\u00edcio ao fim. Tempo do usu\u00e1rio ( user ): O tempo que a CPU gastou na tarefa em si. Tempo do sistema ( sys ): O tempo que a CPU gastou em tarefas de n\u00edvel de sistema relacionadas ao comando. Tip Para saber mais como o time ou diff funcionam use o comando man conforme abaixo. $ man time $ man diff Tip Voc\u00ea pode utilizar o comando dd para gerar um arquivo aleat\u00f3rio de tamanho arbitr\u00e1rio. Por exemplo, para gerar um arquivo de 100MB, podemos fazer: $ dd if = /dev/urandom of = ex.bin bs = 1M count = 100 iflag = fullblock Exercise Voc\u00ea consegue explicar a diferen\u00e7a de desempenho entre as duas vers\u00f5es? Resposta Ter dispon\u00edvel o buffer aumentado faz com que o programa tenha que acessar menos vezes a fila de IO, provendo ganho de performance. Permiss\u00f5es e posse de arquivos \u00b6 No exemplo_io2.c passamos algumas op\u00e7\u00f5es extras para poder criar o arquivo: int fd1 = open ( arq1 , O_WRONLY | O_CREAT , 0700 ); A flag O_CREAT \u00e9 usada para indicar que o arquivo deve ser criado caso ele n\u00e3o exista. O n\u00famero 0700 representa os bits de acesso visto na expositiva. Cada d\u00edgito cont\u00e9m 3 d\u00edgitos que representam as seguintes permiss\u00f5es 4 - permiss\u00e3o de leitura 2 - permiss\u00e3o de escrita 1 - permiss\u00e3o de execu\u00e7\u00e3o O primeiro d\u00edgito cont\u00e9m as permiss\u00f5es do usu\u00e1rio dono do arquivo. O segundo d\u00edgito cont\u00e9m as permiss\u00f5es do grupo dono do arquivo. Usu\u00e1rios que pertencem a este grupo possuem estas permiss\u00f5es. O terceiro d\u00edgito lista as permiss\u00f5es para todos os outros usu\u00e1rios. Exercise Use ls -l na pasta do arquivo criado por copy_file (ou por exemplo_io2 ). Onde \u00e9 poss\u00edvel obter as informa\u00e7\u00f5es de permiss\u00f5es do arquivo? Qual o usu\u00e1rio e grupo donos do arquivo? As permiss\u00f5es passadas para o open foram corretamente colocadas no arquivo? Resposta A primeira coluna cont\u00e9m as permiss\u00f5es na ordem leitura ( r ), escrita ( w ) e execu\u00e7\u00e3o ( x ) para o dono do arquivo, o grupo principal do arquivo e todos os usu\u00e1rios. \u00c9 usado o caractere - para as permiss\u00f5es n\u00e3o concedidas. A segunda coluna mostra o usu\u00e1rio dono do arquivo. A terceira mostra o grupo dono do arquivo. Exercise Quais permiss\u00f5es s\u00e3o garantidas pela m\u00e1scara 640 ? \u00c9 uma boa ideia us\u00e1-la? Resposta Leitura e escrita para o dono, leitura para o grupo e nenhuma permiss\u00e3o para outros usu\u00e1rios. Ela \u00e9 interessante pois permite edi\u00e7\u00e3o somente pelo dono, mas permite leitura para alguns usu\u00e1rios que o dono confia. Por\u00e9m, n\u00e3o permite que qualquer usu\u00e1rio leia nem escreva no arquivo. Exercise Qual m\u00e1scara usaria se quisesse que um arquivo possa ser modificado somente por seu dono, mas possa ser executado por qualquer usu\u00e1rio do sistema (incluindo o dono do arquivo)? Justifique. Resposta 755 Exercise Rode o comando copy_file usando sudo . Use ls -l para listar as informa\u00e7\u00f5es do arquivo. Escreva abaixo quem \u00e9 seu dono e suas permiss\u00f5es de acesso. Resposta Confira no output do ls -l . Se ainda restar d\u00favida, confira com o professor Example Use os comandos chown para mudar o dono do arquivo para seu usu\u00e1rio e chmod para deixar suas permiss\u00f5es como leitura e escrita para voc\u00ea e somente leitura para o restante. Dica : n\u00e3o sabe como usar os comandos acima? Use man . $ man chown Extra \u00b6 Estes exerc\u00edcios trabalham com o conceito de posse de arquivos e de sobrescrita de arquivos j\u00e1 existentes. Exercise Tente usar copy_file usando como fonte algum arquivo que voc\u00ea n\u00e3o possui acesso de leitura (voc\u00ea pode cri\u00e1-lo e depois usar chmod para editar os acessos). O qu\u00ea ocorre? Voc\u00ea consegue explicar este comportamento? Resposta Confira com o professor Example Conserte o erro ocorrido acima checando a sa\u00edda de open . Consulte o manual caso necess\u00e1rio. N\u00e3o se esque\u00e7a de faz\u00ea-lo para o arquivo fonte e destino. Exercise Vamos realizar um experimento neste exerc\u00edcio: Crie um arquivo com 100 caracteres a e chame-o de 100a ; Crie um arquivo com 3 caracteres b e chame-o de 3b ; Use copy_file para copiar 3b em cima de 100a ; Mostre o conte\u00fado do arquivo sobrescrito 100a . Voc\u00ea consegue explicar o que ocorreu? Se sim, busque no manual uma flag que, ao ser passada para o open , evita que isto ocorra. Resposta Confira com o professor Example O copy_file sobrescreve arquivos sem considerar se arquivo existe ou n\u00e3o. Use o manual ( man 2 open ) para encontrar a flag que faz open falhar caso o arquivo de destino j\u00e1 exista e conserte seu programa para perguntar se o usu\u00e1rio deseja sobrescrever o arquivo. Entenda como usar errno para que voc\u00ea consiga diferenciar os dois tipos de erros.","title":"15 - Entrada/Sa\u00edda"},{"location":"aulas/15-entrada-saida/#15-entradasaida","text":"","title":"15 - Entrada/Sa\u00edda"},{"location":"aulas/15-entrada-saida/#trabalhando-com-arquivos","text":"Nesta se\u00e7\u00e3o trabalharemos com as chamadas open , close , read e write . Exercise Leia o c\u00f3digo do arquivo exemplo_io1.c . O qu\u00ea ele faz? Resposta L\u00ea os 5 primeiros caracteres de um arquivo. O arquivo lido \u00e9 passado via terminal. Vamos agora usar o comando man para ver a documenta\u00e7\u00e3o das chamadas de sistema do Linux. Digite no terminal man read . A tela mostrada cont\u00e9m a documenta\u00e7\u00e3o da fun\u00e7\u00e3o read , incluindo sua assinatura e quais cabe\u00e7alhos devem ser inclu\u00eddos para que ela possa ser usada. $ man read Exercise Usando como apoio a documenta\u00e7\u00e3o aberta pelo comando man , como saber que um arquivo foi lido at\u00e9 o fim? Dica : a se\u00e7\u00e3o RETURN VALUE pode te ajudar. Resposta A fun\u00e7\u00e3o read retorna o n\u00famero de caracteres efetivamente lidos. Ela retorna 0 quando o arquivo acabou. A fun\u00e7\u00e3o s\u00f3 retorna quando os caracteres forem lidos, ent\u00e3o ela pode bloquear o programa. Tip Para acelerar suas buscas no man voc\u00ea pode ativar a busca pressionando / . A\u00ed basta digitar o termo procurado. Para avan\u00e7ar para as pr\u00f3ximas ocorr\u00eancias de um termo basta apertar / + Enter . Example Baseado em sua resposta acima, modifique exemplo_io1.c para que ele mostre o todo o conte\u00fado do arquivo. Vamos agora trabalhar com a chamada write . Um exemplo de seu uso est\u00e1 mostrado no arquivo exemplo_io2.c . Exercise Abra o arquivo exemplo_io2.c e explique abaixo como usar write . Se ficar em d\u00favida use o manual ( man write ). Resposta write recebe o identificador do arquivo, um endere\u00e7o de mem\u00f3ria e o n\u00famero de bytes que devem ser copiados deste endere\u00e7o para o arquivo. $ man write Example Em um novo arquivo copy_file.c , crie um programa copy_file que recebe dois nomes de arquivos como argumentos no terminal e copia o conte\u00fado do primeiro para o segundo. Ou seja, voc\u00ea dever\u00e1 abrir ambos arquivos (cada um ter\u00e1 seu pr\u00f3prio file descriptor ) enquanto n\u00e3o chegar ao final do primeiro arquivo ler do primeiro para um buffer escrever este buffer no segundo fecha os dois arquivos Validando Ap\u00f3s compilar, teste sua solu\u00e7\u00e3o com um arquivo qualquer e utilize diff ou cmp para comparar os arquivos. $ ./copy_file arquivo_origem.txt arquivo_destino.txt $ diff arquivo_origem.txt arquivo_destino.txt $ cmp arquivo_origem.txt arquivo_destino.txt","title":"Trabalhando com arquivos"},{"location":"aulas/15-entrada-saida/#extra","text":"Estes exerc\u00edcios n\u00e3o ter\u00e3o corre\u00e7\u00e3o durante a aula e devem ser checados no atendimento. Fa\u00e7a-os se voc\u00ea j\u00e1 acabou os anteriores e a corre\u00e7\u00e3o/discuss\u00e3o ainda n\u00e3o come\u00e7ou. At\u00e9 agora trabalhamos com um buffer com somente um caractere. Isso facilita a programa\u00e7\u00e3o, mas deixa nosso c\u00f3digo muito lento. Example Modifique o copy_file para usar um buffer de 100 caracteres. Me\u00e7a o tempo de execu\u00e7\u00e3o para a c\u00f3pia de um arquivo grande (~100Mb) usando o comando time . N\u00e3o se esque\u00e7a de verificar que os resultados ficaram iguais com o comando diff . O comando time tem como sa\u00edda tr\u00eas informa\u00e7\u00f5es sobre o processo executado: Tempo Real ( real ): O tempo que real que levou para executar o comando, do in\u00edcio ao fim. Tempo do usu\u00e1rio ( user ): O tempo que a CPU gastou na tarefa em si. Tempo do sistema ( sys ): O tempo que a CPU gastou em tarefas de n\u00edvel de sistema relacionadas ao comando. Tip Para saber mais como o time ou diff funcionam use o comando man conforme abaixo. $ man time $ man diff Tip Voc\u00ea pode utilizar o comando dd para gerar um arquivo aleat\u00f3rio de tamanho arbitr\u00e1rio. Por exemplo, para gerar um arquivo de 100MB, podemos fazer: $ dd if = /dev/urandom of = ex.bin bs = 1M count = 100 iflag = fullblock Exercise Voc\u00ea consegue explicar a diferen\u00e7a de desempenho entre as duas vers\u00f5es? Resposta Ter dispon\u00edvel o buffer aumentado faz com que o programa tenha que acessar menos vezes a fila de IO, provendo ganho de performance.","title":"Extra"},{"location":"aulas/15-entrada-saida/#permissoes-e-posse-de-arquivos","text":"No exemplo_io2.c passamos algumas op\u00e7\u00f5es extras para poder criar o arquivo: int fd1 = open ( arq1 , O_WRONLY | O_CREAT , 0700 ); A flag O_CREAT \u00e9 usada para indicar que o arquivo deve ser criado caso ele n\u00e3o exista. O n\u00famero 0700 representa os bits de acesso visto na expositiva. Cada d\u00edgito cont\u00e9m 3 d\u00edgitos que representam as seguintes permiss\u00f5es 4 - permiss\u00e3o de leitura 2 - permiss\u00e3o de escrita 1 - permiss\u00e3o de execu\u00e7\u00e3o O primeiro d\u00edgito cont\u00e9m as permiss\u00f5es do usu\u00e1rio dono do arquivo. O segundo d\u00edgito cont\u00e9m as permiss\u00f5es do grupo dono do arquivo. Usu\u00e1rios que pertencem a este grupo possuem estas permiss\u00f5es. O terceiro d\u00edgito lista as permiss\u00f5es para todos os outros usu\u00e1rios. Exercise Use ls -l na pasta do arquivo criado por copy_file (ou por exemplo_io2 ). Onde \u00e9 poss\u00edvel obter as informa\u00e7\u00f5es de permiss\u00f5es do arquivo? Qual o usu\u00e1rio e grupo donos do arquivo? As permiss\u00f5es passadas para o open foram corretamente colocadas no arquivo? Resposta A primeira coluna cont\u00e9m as permiss\u00f5es na ordem leitura ( r ), escrita ( w ) e execu\u00e7\u00e3o ( x ) para o dono do arquivo, o grupo principal do arquivo e todos os usu\u00e1rios. \u00c9 usado o caractere - para as permiss\u00f5es n\u00e3o concedidas. A segunda coluna mostra o usu\u00e1rio dono do arquivo. A terceira mostra o grupo dono do arquivo. Exercise Quais permiss\u00f5es s\u00e3o garantidas pela m\u00e1scara 640 ? \u00c9 uma boa ideia us\u00e1-la? Resposta Leitura e escrita para o dono, leitura para o grupo e nenhuma permiss\u00e3o para outros usu\u00e1rios. Ela \u00e9 interessante pois permite edi\u00e7\u00e3o somente pelo dono, mas permite leitura para alguns usu\u00e1rios que o dono confia. Por\u00e9m, n\u00e3o permite que qualquer usu\u00e1rio leia nem escreva no arquivo. Exercise Qual m\u00e1scara usaria se quisesse que um arquivo possa ser modificado somente por seu dono, mas possa ser executado por qualquer usu\u00e1rio do sistema (incluindo o dono do arquivo)? Justifique. Resposta 755 Exercise Rode o comando copy_file usando sudo . Use ls -l para listar as informa\u00e7\u00f5es do arquivo. Escreva abaixo quem \u00e9 seu dono e suas permiss\u00f5es de acesso. Resposta Confira no output do ls -l . Se ainda restar d\u00favida, confira com o professor Example Use os comandos chown para mudar o dono do arquivo para seu usu\u00e1rio e chmod para deixar suas permiss\u00f5es como leitura e escrita para voc\u00ea e somente leitura para o restante. Dica : n\u00e3o sabe como usar os comandos acima? Use man . $ man chown","title":"Permiss\u00f5es e posse de arquivos"},{"location":"aulas/15-entrada-saida/#extra_1","text":"Estes exerc\u00edcios trabalham com o conceito de posse de arquivos e de sobrescrita de arquivos j\u00e1 existentes. Exercise Tente usar copy_file usando como fonte algum arquivo que voc\u00ea n\u00e3o possui acesso de leitura (voc\u00ea pode cri\u00e1-lo e depois usar chmod para editar os acessos). O qu\u00ea ocorre? Voc\u00ea consegue explicar este comportamento? Resposta Confira com o professor Example Conserte o erro ocorrido acima checando a sa\u00edda de open . Consulte o manual caso necess\u00e1rio. N\u00e3o se esque\u00e7a de faz\u00ea-lo para o arquivo fonte e destino. Exercise Vamos realizar um experimento neste exerc\u00edcio: Crie um arquivo com 100 caracteres a e chame-o de 100a ; Crie um arquivo com 3 caracteres b e chame-o de 3b ; Use copy_file para copiar 3b em cima de 100a ; Mostre o conte\u00fado do arquivo sobrescrito 100a . Voc\u00ea consegue explicar o que ocorreu? Se sim, busque no manual uma flag que, ao ser passada para o open , evita que isto ocorra. Resposta Confira com o professor Example O copy_file sobrescreve arquivos sem considerar se arquivo existe ou n\u00e3o. Use o manual ( man 2 open ) para encontrar a flag que faz open falhar caso o arquivo de destino j\u00e1 exista e conserte seu programa para perguntar se o usu\u00e1rio deseja sobrescrever o arquivo. Entenda como usar errno para que voc\u00ea consiga diferenciar os dois tipos de erros.","title":"Extra"},{"location":"aulas/16-sinais-I/","text":"16 - Enviando sinais \u00b6 Na aula de hoje falamos sobre sinais e vimos que grande parte deles indica que algo excepcional aconteceu. Veremos neste handout as chamadas usadas para consultar o status de um processo quando ele acaba com erro e como enviar sinais para outros processos. Recuperando informa\u00e7\u00f5es de erros usando wait \u00b6 Anteriormente vimos que ao chamar wait(&status); guardamos informa\u00e7\u00f5es sobre o fim do processo filho na vari\u00e1vel status . Nos outros exerc\u00edcios olhamos para os casos em que WIFEXITED(status) == 1 . int wstatus ; wait ( & wstatus ); printf ( \"Filho acabou \\n \" ); // Utiliza macro para ler um \"peda\u00e7o\" (um ou mais bits) de wstatus printf ( \"Terminou normal?: %d \\n \" , WIFEXITED ( wstatus )); // l\u00ea 0 ou 1 // se terminou normalmente if ( WIFEXITED ( wstatus )) { // l\u00ea o byte menos significativo do return do filho printf ( \"Valor de retorno: %d \\n \" , WEXITSTATUS ( wstatus )); } Todo t\u00e9rmino inesperado de um programa em execu\u00e7\u00e3o (processo) \u00e9 feito usando um sinal. Ao acessar informa\u00e7\u00f5es em um local de mem\u00f3ria n\u00e3o mapeado para o nosso processo ele recebe o sinal SIGSEGV . Ao executar uma divis\u00e3o por zero ele receber\u00e1 o sinal SIGFPE . Logo, nestes casos \u00e9 verdade que WIFSIGNALED(status) == 1 , ent\u00e3o podemos pegar o n\u00famero do sinal usando a macro WTERMSIG(status) . Exercise Leia o arquivo parte1.c . O que ele faz? Quantos processos s\u00e3o criados (conte o original)? Resposta O programa original cria um processo filho, que faz uma divis\u00e3o por zero. S\u00e3o dois processos, portanto. Example Modifique parte1.c para o processo pai esperar o fim do filho e mostrar uma mensagem com o pid do filho que acabou (pegue isto via wait ). Example No proceso pai, ap\u00f3s o wait mostre no terminal as seguintes express\u00f5es: WIFEXITED(status) WIFSIGNALED(status) WTERMSIG(status) To-Do Mostrar o n\u00famero do sinal n\u00e3o \u00e9 muito \u00fatil. Pesquise sobre a chamada strsignal ( man strsignal ) e use-a para mostrar uma mensagem descritiva de qual sinal foi recebido no exerc\u00edcio acima. Tip Ap\u00f3s cada modifica\u00e7\u00e3o no c\u00f3digo, compile e execute para conferir os resultados! Envio de sinais via terminal \u00b6 Al\u00e9m de erros e exce\u00e7\u00f5es, sinais tamb\u00e9m s\u00e3o usados para avisar de mudan\u00e7as no sistema, sejam elas iniciadas pelo usu\u00e1rio ou por outros processos. A sequ\u00eancia de exerc\u00edcios abaixo \u00e9 um experimento de envio de sinais. Example Fa\u00e7a uma c\u00f3pia do arquivo parte1.c e salve como parte2.c . No novo arquivo, altere para que o processo filho mostre seu pid e entre em loop infinito. Claramente nem o pai nem o filho terminam no exemplo acima, para ver isso use no terminal o comando ps -C parte2 , ele mostrar\u00e1 os processos em execu\u00e7\u00e3o. Por\u00e9m, se o filho terminar o pai termina tamb\u00e9m! O sinal SIGKILL \u00e9 usado para terminar for\u00e7adamente um processo e ele pode ser enviado por qualquer outro processo do mesmo usu\u00e1rio (ou o root , que pode mandar sinais para qualquer processo do sistema). O envio de sinais \u00e9 feito usando a chamada kill . Assim como outras chamadas de sistema, kill possui tamb\u00e9m um programa de linha de comando. Example Abra dois terminais e coloque um ao lado do outro. No primeiro, execute o programa parte2.c . Example No segundo terminal, use a ferramenta de linha de comando kill para enviar o sinal SIGKILL para o processo filho. Se precisar, consulte a documenta\u00e7\u00e3o usando man 1 kill . Exercise Use man 7 signal para ver a lista de sinais dispon\u00edveis e seus n\u00fameros. Qual seria o n\u00famero para o sinal SIGINT ? Resposta Execute man 7 signal e procure por Signal numbering for standard signals Isto deve ter feito o pai finalizar e mostrar a informa\u00e7\u00e3o de que o processo filho foi finalizado. Note que o pai tem direito a saber o sinal usado para finalizar um filho: Example Envie o sinal SIGINT para seu processo filho e verifique que o processo pai mostra o n\u00famero correto. Envio de sinais em um programa \u00b6 O programa kill \u00e9 apenas um casquinha em volta de sua chamada de sistema. Example Veja a documenta\u00e7\u00e3o da chamada de sistema (em C) no manual man 2 kill Example Fa\u00e7a uma c\u00f3pia do arquivo parte2.c e salve como parte3.c . Modifique o novo arquivo para que o processo pai espere 10 segundos e envie um SIGKILL para o filho. Exercise Agora os dois processos acabam? As informa\u00e7\u00f5es de finaliza\u00e7\u00e3o no pai condizem com o sinal enviado? Resposta Se restarem d\u00favidas, confira com o professor! Extra \u00b6 At\u00e9 o momento usamos a chamada wait para esperar um processo filho acabar. Por\u00e9m, n\u00e3o sabemos ainda checar se um processo filho acabou (um processo filho espec\u00edfico, sem necessariamente deixar a chamada wait travada)! Podemos fazer isso com a fun\u00e7\u00e3o waitpid , que recebe o pid_t do processo filho, e permite esperar ou n\u00e3o pela finaliza\u00e7\u00e3o dele. Example Pesquise no manual pela flag WNOHANG da chamada waitpid . Example Fa\u00e7a uma c\u00f3pia do arquivo parte3.c e salve como parte4.c . Modifique o novo arquivo para que o processo pai s\u00f3 envie o sinal se o processo filho ainda estiver executando. Salve como parte4.c","title":"16 - Enviando sinais"},{"location":"aulas/16-sinais-I/#16-enviando-sinais","text":"Na aula de hoje falamos sobre sinais e vimos que grande parte deles indica que algo excepcional aconteceu. Veremos neste handout as chamadas usadas para consultar o status de um processo quando ele acaba com erro e como enviar sinais para outros processos.","title":"16 - Enviando sinais"},{"location":"aulas/16-sinais-I/#recuperando-informacoes-de-erros-usando-wait","text":"Anteriormente vimos que ao chamar wait(&status); guardamos informa\u00e7\u00f5es sobre o fim do processo filho na vari\u00e1vel status . Nos outros exerc\u00edcios olhamos para os casos em que WIFEXITED(status) == 1 . int wstatus ; wait ( & wstatus ); printf ( \"Filho acabou \\n \" ); // Utiliza macro para ler um \"peda\u00e7o\" (um ou mais bits) de wstatus printf ( \"Terminou normal?: %d \\n \" , WIFEXITED ( wstatus )); // l\u00ea 0 ou 1 // se terminou normalmente if ( WIFEXITED ( wstatus )) { // l\u00ea o byte menos significativo do return do filho printf ( \"Valor de retorno: %d \\n \" , WEXITSTATUS ( wstatus )); } Todo t\u00e9rmino inesperado de um programa em execu\u00e7\u00e3o (processo) \u00e9 feito usando um sinal. Ao acessar informa\u00e7\u00f5es em um local de mem\u00f3ria n\u00e3o mapeado para o nosso processo ele recebe o sinal SIGSEGV . Ao executar uma divis\u00e3o por zero ele receber\u00e1 o sinal SIGFPE . Logo, nestes casos \u00e9 verdade que WIFSIGNALED(status) == 1 , ent\u00e3o podemos pegar o n\u00famero do sinal usando a macro WTERMSIG(status) . Exercise Leia o arquivo parte1.c . O que ele faz? Quantos processos s\u00e3o criados (conte o original)? Resposta O programa original cria um processo filho, que faz uma divis\u00e3o por zero. S\u00e3o dois processos, portanto. Example Modifique parte1.c para o processo pai esperar o fim do filho e mostrar uma mensagem com o pid do filho que acabou (pegue isto via wait ). Example No proceso pai, ap\u00f3s o wait mostre no terminal as seguintes express\u00f5es: WIFEXITED(status) WIFSIGNALED(status) WTERMSIG(status) To-Do Mostrar o n\u00famero do sinal n\u00e3o \u00e9 muito \u00fatil. Pesquise sobre a chamada strsignal ( man strsignal ) e use-a para mostrar uma mensagem descritiva de qual sinal foi recebido no exerc\u00edcio acima. Tip Ap\u00f3s cada modifica\u00e7\u00e3o no c\u00f3digo, compile e execute para conferir os resultados!","title":"Recuperando informa\u00e7\u00f5es de erros usando wait"},{"location":"aulas/16-sinais-I/#envio-de-sinais-via-terminal","text":"Al\u00e9m de erros e exce\u00e7\u00f5es, sinais tamb\u00e9m s\u00e3o usados para avisar de mudan\u00e7as no sistema, sejam elas iniciadas pelo usu\u00e1rio ou por outros processos. A sequ\u00eancia de exerc\u00edcios abaixo \u00e9 um experimento de envio de sinais. Example Fa\u00e7a uma c\u00f3pia do arquivo parte1.c e salve como parte2.c . No novo arquivo, altere para que o processo filho mostre seu pid e entre em loop infinito. Claramente nem o pai nem o filho terminam no exemplo acima, para ver isso use no terminal o comando ps -C parte2 , ele mostrar\u00e1 os processos em execu\u00e7\u00e3o. Por\u00e9m, se o filho terminar o pai termina tamb\u00e9m! O sinal SIGKILL \u00e9 usado para terminar for\u00e7adamente um processo e ele pode ser enviado por qualquer outro processo do mesmo usu\u00e1rio (ou o root , que pode mandar sinais para qualquer processo do sistema). O envio de sinais \u00e9 feito usando a chamada kill . Assim como outras chamadas de sistema, kill possui tamb\u00e9m um programa de linha de comando. Example Abra dois terminais e coloque um ao lado do outro. No primeiro, execute o programa parte2.c . Example No segundo terminal, use a ferramenta de linha de comando kill para enviar o sinal SIGKILL para o processo filho. Se precisar, consulte a documenta\u00e7\u00e3o usando man 1 kill . Exercise Use man 7 signal para ver a lista de sinais dispon\u00edveis e seus n\u00fameros. Qual seria o n\u00famero para o sinal SIGINT ? Resposta Execute man 7 signal e procure por Signal numbering for standard signals Isto deve ter feito o pai finalizar e mostrar a informa\u00e7\u00e3o de que o processo filho foi finalizado. Note que o pai tem direito a saber o sinal usado para finalizar um filho: Example Envie o sinal SIGINT para seu processo filho e verifique que o processo pai mostra o n\u00famero correto.","title":"Envio de sinais via terminal"},{"location":"aulas/16-sinais-I/#envio-de-sinais-em-um-programa","text":"O programa kill \u00e9 apenas um casquinha em volta de sua chamada de sistema. Example Veja a documenta\u00e7\u00e3o da chamada de sistema (em C) no manual man 2 kill Example Fa\u00e7a uma c\u00f3pia do arquivo parte2.c e salve como parte3.c . Modifique o novo arquivo para que o processo pai espere 10 segundos e envie um SIGKILL para o filho. Exercise Agora os dois processos acabam? As informa\u00e7\u00f5es de finaliza\u00e7\u00e3o no pai condizem com o sinal enviado? Resposta Se restarem d\u00favidas, confira com o professor!","title":"Envio de sinais em um programa"},{"location":"aulas/16-sinais-I/#extra","text":"At\u00e9 o momento usamos a chamada wait para esperar um processo filho acabar. Por\u00e9m, n\u00e3o sabemos ainda checar se um processo filho acabou (um processo filho espec\u00edfico, sem necessariamente deixar a chamada wait travada)! Podemos fazer isso com a fun\u00e7\u00e3o waitpid , que recebe o pid_t do processo filho, e permite esperar ou n\u00e3o pela finaliza\u00e7\u00e3o dele. Example Pesquise no manual pela flag WNOHANG da chamada waitpid . Example Fa\u00e7a uma c\u00f3pia do arquivo parte3.c e salve como parte4.c . Modifique o novo arquivo para que o processo pai s\u00f3 envie o sinal se o processo filho ainda estiver executando. Salve como parte4.c","title":"Extra"},{"location":"aulas/17-sinais-II/","text":"17 - Capturando sinais \u00b6 Na aula de hoje iremos criar programas que reagem a sinais recebidos. J\u00e1 vimos que o sistema tem uma s\u00e9rie de comportamentos padr\u00e3o para cada sinal, ent\u00e3o hoje aprenderemos a customizar esse comportamento. Warning Apesar de muitos recursos mostrarem o uso da chamada signal para a captura de sinais, ela \u00e9 considerada obsoleta e o recomendado \u00e9 usar sigaction , que \u00e9 um pouco mais complicada de usar mas permite maior flexibilidade ao definir o comportamento do processo. Capturando sinais - a chamada sigaction \u00b6 O programa trecho apresentado abaixo cria um struct sigaction e o seta para executar um handler quando o processo receber SIGINT (Ctrl+C). // Fora da main, criamos a fun\u00e7\u00e3o que ser\u00e1 nosso handler void sig_handler ( int num ) { // faz algo aqui } int main () { .... /* Dentro da main, uma das primeiras coisas que fazemos \u00e9 registrar nosso handler */ struct sigaction s ; s . sa_handler = sig_handler ; // aqui vai a fun\u00e7\u00e3o a ser executada sigemptyset ( & s . sa_mask ); s . sa_flags = 0 ; sigaction ( SIGINT , & s , NULL ); .... } Example Usando como exemplo o c\u00f3digo acima, modifique o arquivo sinal1.c para que o programa s\u00f3 termine ap\u00f3s apertar Ctrl+C tr\u00eas vezes. Voc\u00ea pode usar exit para sair na terceira vez. N\u00e3o se esque\u00e7a de consultar man sigaction para verificar quais include s devem ser usados. Clique para ver uma proposta de solu\u00e7\u00e3o do exerc\u00edcio! #include <stdio.h> #include <unistd.h> #include <signal.h> #include <stdlib.h> #include <sys/types.h> int contador = 0 ; void sig_handler ( int num ) { contador ++ ; printf ( \"Chamou Ctrl+C \\n \" ); if ( contador == 3 ) { exit ( 0 ); } } int main () { struct sigaction handler ; handler . sa_handler = sig_handler ; handler . sa_flags = 0 ; sigemptyset ( & handler . sa_mask ); sigaction ( SIGINT , & handler , NULL ); printf ( \"Meu pid: %d \\n \" , getpid ()); while ( 1 ) { sleep ( 1 ); } return 0 ; } Provavelmente sua solu\u00e7\u00e3o para o exerc\u00edcio acima funciona, mas seu t\u00e9rmino n\u00e3o \u00e9 condizente com a a\u00e7\u00e3o do usu\u00e1rio. Ao sair com exit o processo pai (no caso o shell) n\u00e3o consegue saber que o programa foi interrompido pelo usu\u00e1rio e acha que ele terminou normalmente. Podemos resetar o comportamento padr\u00e3o de um sinal atribuindo a constante SIG_DFL ( signal default ) a sigaction.sa_handler . Example Restaure o comportamento original no segundo Ctrl+C , fazendo com que o processo realmente termine com o sinal. Clique para ver uma proposta de solu\u00e7\u00e3o do exerc\u00edcio! #include <stdio.h> #include <unistd.h> #include <signal.h> #include <stdlib.h> #include <sys/types.h> int contador = 0 ; void sig_handler ( int num ) { contador ++ ; printf ( \"Chamou Ctrl+C \\n \" ); if ( contador == 2 ) { struct sigaction handler ; handler . sa_handler = SIG_DFL ; handler . sa_flags = 0 ; sigemptyset ( & handler . sa_mask ); sigaction ( SIGINT , & handler , NULL ); } } int main () { struct sigaction handler ; handler . sa_handler = sig_handler ; handler . sa_flags = 0 ; sigemptyset ( & handler . sa_mask ); sigaction ( SIGINT , & handler , NULL ); printf ( \"Meu pid: %d \\n \" , getpid ()); while ( 1 ) { sleep ( 1 ); } return 0 ; } Exercise Podemos verificar o sinal de encerramento do \u00faltimo processo finalizado usando o comando kill -l \"$?\" . Execute-o e veja que realmente \u00e9 SIGINT . Resposta voc\u00ea deve receber no terminal uma string identificando o sinal. Um dos problemas da solu\u00e7\u00e3o proposta \u00e9 que o \u00faltimo CTRL+C fica sem printf de mensagem! Para resolver o problema, vamos alterar a linha if (contador == 3) e fazer o processo enviar um SIGINT para si pr\u00f3prio. Clique para ver uma proposta de solu\u00e7\u00e3o do exerc\u00edcio! #include <stdio.h> #include <unistd.h> #include <signal.h> #include <stdlib.h> #include <signal.h> int contador = 0 ; void sig_handler ( int num ) { contador ++ ; printf ( \"Chamou Ctrl+C \\n \" ); if ( contador == 3 ) { struct sigaction handler ; handler . sa_handler = SIG_DFL ; handler . sa_flags = 0 ; sigemptyset ( & handler . sa_mask ); sigaction ( SIGINT , & handler , NULL ); /* Envia o sinal para si mesmo. Outra forma: raise(SIGINT); */ kill ( getpid (), SIGINT ); } } int main () { struct sigaction handler ; handler . sa_handler = sig_handler ; handler . sa_flags = 0 ; sigemptyset ( & handler . sa_mask ); sigaction ( SIGINT , & handler , NULL ); printf ( \"Meu pid: %d \\n \" , getpid ()); while ( 1 ) { sleep ( 1 ); } return 0 ; } Sinais e concorr\u00eancia \u00b6 Nesta parte vamos trabalhar com o arquivo sinais-concorrentes.c . Example Leia o conte\u00fado do arquivo acima e complete as partes faltantes. Exercise Teste sua implementa\u00e7\u00e3o enviando sinais SIGINT e SIGTERM para seu processo. Os resultados foram os esperados? Resposta Os handlers foram corretamente chamados. Mas precisamos conferir melhor o valor da vari\u00e1vel status. Vamos agora examinar o que acontece quando trabalhamos com v\u00e1rios sinais sendo recebidos ao mesmo tempo. Example Abra dois terminais. No primeiro execute sinais-concorrentes . Exercise No segundo terminal, realize rapidamente a seguinte sequ\u00eancia de comandos. Para cada comando, anote o que \u00e9 mostrado no terminal. Envie o sinal SIGINT para o programa. Envie o sinal SIGTERM para o programa. Envie de novo SIGINT. Resposta Envie kill -s SIGINT <pid> , kill -s SIGTERM <pid> e kill -s SIGINT <pid> e confira o resultado! Exercise Assumindo que cada fun\u00e7\u00e3o roda do come\u00e7o ao fim sem interrup\u00e7\u00e3o, os valores da vari\u00e1vel status foram os esperados? Se n\u00e3o, como voc\u00ea explica o ocorrido? Resposta N\u00e3o! Podemos perceber que o valor do status foi modificado sem que o primeiro handler fosse finalizado, tornando inconsistente a nossa tratativa. Isto ocorre porque a chegada de um novo sinal faz com que o handler que est\u00e1 executando seja interrompido e o novo handler do novo sinal passa a executar. Apenas quando este segundo handler finalizar \u00e9 que o anterior continuar\u00e1 sua execu\u00e7\u00e3o. Warning Valide sua resposta com o professor antes de prosseguir. Se quiser, poder\u00e1 esperar pela corre\u00e7\u00e3o do exerc\u00edcio. Bloqueio de sinais \u00b6 A principal vantagem de usarmos sigaction \u00e9 que esta chamada permite configurar sinais a serem bloqueados durante a execu\u00e7\u00e3o da fun\u00e7\u00e3o sa_handler . Ou seja, se um sinal bloqueado for recebido durante sua execu\u00e7\u00e3o ele \u00e9 colocado \"em espera\" at\u00e9 que sa_handler acabe de rodar! Exercise Bloquear sinais evita o problema detectado na parte anterior? Resposta Sim! Desta forma, garantimos consist\u00eancia no valor da vari\u00e1vel status . Exercise Quais sinais dever\u00e3o ser bloqueados durante a execu\u00e7\u00e3o do handler SIGINT ? E durante a execu\u00e7\u00e3o do handler SIGTERM ? Resposta No registro do handler de SIGINT , bloqueamos SIGTERM . No registro do handler de SIGTERM , bloqueamos SIGINT . Exercise O campo sa_mask , da estrutura struct sigaction , permite bloquear sinais enquanto os handlers executam. Veja nos slides da aula como acessar esse campo e use man sigaddset para ver como preench\u00ea-lo. Escreva abaixo os comandos para tal. Resposta Podemos fazer, por exemplo, sigaddset(&handler_sigterm.sa_mask, SIGINT); Example Modifique sinais-concorrentes.c para que SIGTERM seja bloqueado enquanto o handler de SIGINT roda. Repita ent\u00e3o o experiemento acima e veja que n\u00e3o h\u00e1 mais conflito na vari\u00e1vel global compartilhada. O que fizemos n\u00e3o permite que SIGINT seja interrompido por um SIGTERM , mas permite que um SIGTERM seja interrompido por um SIGINT ! Corrija esta situa\u00e7\u00e3o. Exerc\u00edcios para praticar \u00b6 Exercise Modifique sinal1.c para que, ao ser colocado em background usando Ctrl+Z (SIGTSTP), imprima uma mensagem antes de parar de executar. Dicas : Voc\u00ea precisa retornar o comportamento padr\u00e3o do sinal depois de dar o print. Pesquise como usar raise para (re)enviar um sinal para o pr\u00f3prio processo. Exercise Complete o programa acima com uma outra fun\u00e7\u00e3o que imprime a mensagem Continuando! quando o programa voltar a rodar (sinal SIGCONT ). Uma parte importante de sinais em sistemas POSIX \u00e9 que, ao interromper um processo, eles podem cancelar opera\u00e7\u00f5es que estavam ocorrendo. Em especial, chamadas de sistema que deixam um processo bloqueado (como wait e sleep ) ou que fazem opera\u00e7\u00f5es de entrada/sa\u00edda (como read e write ). Exercise Compile e rode o programa sleep_longo.c . O qu\u00ea foi mostrado na tela? Exercise Rode novamente o programa. Abra um novo terminal e envie um sinal SIGTERM para este processo. O qu\u00ea \u00e9 mostrado na tela? Voc\u00ea consegue interpretar este resultado? Dicas : Ser\u00e1 \u00fatil exibir na sa\u00edda padr\u00e3o o PID do processo! Repita a execu\u00e7\u00e3o m\u00faltiplas vezes. Vai te ajudar a entender o que acontece. Em algumas envie o sinal SIGTERM rapidamente, em outras, aguarde mais alguns segundos! Exercise Como checamos que sleep realmente parou o processo por todo o tempo? Resposta A resposta est\u00e1 no manual. Leia em especial o RETURN VALUE! $ man 3 sleep Exercise Modifique o programa para que ele chame sleep tanto quanto for necess\u00e1rio para que o processo durma o tempo especificado. Salve este arquivo como sleep_longo_while.c . Exercise Troque o c\u00f3digo de sleep_longo.c para ignorar o sinal SIGTERM . O programa agora funciona como esperado? Por que?","title":"17 - Capturando sinais"},{"location":"aulas/17-sinais-II/#17-capturando-sinais","text":"Na aula de hoje iremos criar programas que reagem a sinais recebidos. J\u00e1 vimos que o sistema tem uma s\u00e9rie de comportamentos padr\u00e3o para cada sinal, ent\u00e3o hoje aprenderemos a customizar esse comportamento. Warning Apesar de muitos recursos mostrarem o uso da chamada signal para a captura de sinais, ela \u00e9 considerada obsoleta e o recomendado \u00e9 usar sigaction , que \u00e9 um pouco mais complicada de usar mas permite maior flexibilidade ao definir o comportamento do processo.","title":"17 - Capturando sinais"},{"location":"aulas/17-sinais-II/#capturando-sinais-a-chamada-sigaction","text":"O programa trecho apresentado abaixo cria um struct sigaction e o seta para executar um handler quando o processo receber SIGINT (Ctrl+C). // Fora da main, criamos a fun\u00e7\u00e3o que ser\u00e1 nosso handler void sig_handler ( int num ) { // faz algo aqui } int main () { .... /* Dentro da main, uma das primeiras coisas que fazemos \u00e9 registrar nosso handler */ struct sigaction s ; s . sa_handler = sig_handler ; // aqui vai a fun\u00e7\u00e3o a ser executada sigemptyset ( & s . sa_mask ); s . sa_flags = 0 ; sigaction ( SIGINT , & s , NULL ); .... } Example Usando como exemplo o c\u00f3digo acima, modifique o arquivo sinal1.c para que o programa s\u00f3 termine ap\u00f3s apertar Ctrl+C tr\u00eas vezes. Voc\u00ea pode usar exit para sair na terceira vez. N\u00e3o se esque\u00e7a de consultar man sigaction para verificar quais include s devem ser usados. Clique para ver uma proposta de solu\u00e7\u00e3o do exerc\u00edcio! #include <stdio.h> #include <unistd.h> #include <signal.h> #include <stdlib.h> #include <sys/types.h> int contador = 0 ; void sig_handler ( int num ) { contador ++ ; printf ( \"Chamou Ctrl+C \\n \" ); if ( contador == 3 ) { exit ( 0 ); } } int main () { struct sigaction handler ; handler . sa_handler = sig_handler ; handler . sa_flags = 0 ; sigemptyset ( & handler . sa_mask ); sigaction ( SIGINT , & handler , NULL ); printf ( \"Meu pid: %d \\n \" , getpid ()); while ( 1 ) { sleep ( 1 ); } return 0 ; } Provavelmente sua solu\u00e7\u00e3o para o exerc\u00edcio acima funciona, mas seu t\u00e9rmino n\u00e3o \u00e9 condizente com a a\u00e7\u00e3o do usu\u00e1rio. Ao sair com exit o processo pai (no caso o shell) n\u00e3o consegue saber que o programa foi interrompido pelo usu\u00e1rio e acha que ele terminou normalmente. Podemos resetar o comportamento padr\u00e3o de um sinal atribuindo a constante SIG_DFL ( signal default ) a sigaction.sa_handler . Example Restaure o comportamento original no segundo Ctrl+C , fazendo com que o processo realmente termine com o sinal. Clique para ver uma proposta de solu\u00e7\u00e3o do exerc\u00edcio! #include <stdio.h> #include <unistd.h> #include <signal.h> #include <stdlib.h> #include <sys/types.h> int contador = 0 ; void sig_handler ( int num ) { contador ++ ; printf ( \"Chamou Ctrl+C \\n \" ); if ( contador == 2 ) { struct sigaction handler ; handler . sa_handler = SIG_DFL ; handler . sa_flags = 0 ; sigemptyset ( & handler . sa_mask ); sigaction ( SIGINT , & handler , NULL ); } } int main () { struct sigaction handler ; handler . sa_handler = sig_handler ; handler . sa_flags = 0 ; sigemptyset ( & handler . sa_mask ); sigaction ( SIGINT , & handler , NULL ); printf ( \"Meu pid: %d \\n \" , getpid ()); while ( 1 ) { sleep ( 1 ); } return 0 ; } Exercise Podemos verificar o sinal de encerramento do \u00faltimo processo finalizado usando o comando kill -l \"$?\" . Execute-o e veja que realmente \u00e9 SIGINT . Resposta voc\u00ea deve receber no terminal uma string identificando o sinal. Um dos problemas da solu\u00e7\u00e3o proposta \u00e9 que o \u00faltimo CTRL+C fica sem printf de mensagem! Para resolver o problema, vamos alterar a linha if (contador == 3) e fazer o processo enviar um SIGINT para si pr\u00f3prio. Clique para ver uma proposta de solu\u00e7\u00e3o do exerc\u00edcio! #include <stdio.h> #include <unistd.h> #include <signal.h> #include <stdlib.h> #include <signal.h> int contador = 0 ; void sig_handler ( int num ) { contador ++ ; printf ( \"Chamou Ctrl+C \\n \" ); if ( contador == 3 ) { struct sigaction handler ; handler . sa_handler = SIG_DFL ; handler . sa_flags = 0 ; sigemptyset ( & handler . sa_mask ); sigaction ( SIGINT , & handler , NULL ); /* Envia o sinal para si mesmo. Outra forma: raise(SIGINT); */ kill ( getpid (), SIGINT ); } } int main () { struct sigaction handler ; handler . sa_handler = sig_handler ; handler . sa_flags = 0 ; sigemptyset ( & handler . sa_mask ); sigaction ( SIGINT , & handler , NULL ); printf ( \"Meu pid: %d \\n \" , getpid ()); while ( 1 ) { sleep ( 1 ); } return 0 ; }","title":"Capturando sinais - a chamada sigaction"},{"location":"aulas/17-sinais-II/#sinais-e-concorrencia","text":"Nesta parte vamos trabalhar com o arquivo sinais-concorrentes.c . Example Leia o conte\u00fado do arquivo acima e complete as partes faltantes. Exercise Teste sua implementa\u00e7\u00e3o enviando sinais SIGINT e SIGTERM para seu processo. Os resultados foram os esperados? Resposta Os handlers foram corretamente chamados. Mas precisamos conferir melhor o valor da vari\u00e1vel status. Vamos agora examinar o que acontece quando trabalhamos com v\u00e1rios sinais sendo recebidos ao mesmo tempo. Example Abra dois terminais. No primeiro execute sinais-concorrentes . Exercise No segundo terminal, realize rapidamente a seguinte sequ\u00eancia de comandos. Para cada comando, anote o que \u00e9 mostrado no terminal. Envie o sinal SIGINT para o programa. Envie o sinal SIGTERM para o programa. Envie de novo SIGINT. Resposta Envie kill -s SIGINT <pid> , kill -s SIGTERM <pid> e kill -s SIGINT <pid> e confira o resultado! Exercise Assumindo que cada fun\u00e7\u00e3o roda do come\u00e7o ao fim sem interrup\u00e7\u00e3o, os valores da vari\u00e1vel status foram os esperados? Se n\u00e3o, como voc\u00ea explica o ocorrido? Resposta N\u00e3o! Podemos perceber que o valor do status foi modificado sem que o primeiro handler fosse finalizado, tornando inconsistente a nossa tratativa. Isto ocorre porque a chegada de um novo sinal faz com que o handler que est\u00e1 executando seja interrompido e o novo handler do novo sinal passa a executar. Apenas quando este segundo handler finalizar \u00e9 que o anterior continuar\u00e1 sua execu\u00e7\u00e3o. Warning Valide sua resposta com o professor antes de prosseguir. Se quiser, poder\u00e1 esperar pela corre\u00e7\u00e3o do exerc\u00edcio.","title":"Sinais e concorr\u00eancia"},{"location":"aulas/17-sinais-II/#bloqueio-de-sinais","text":"A principal vantagem de usarmos sigaction \u00e9 que esta chamada permite configurar sinais a serem bloqueados durante a execu\u00e7\u00e3o da fun\u00e7\u00e3o sa_handler . Ou seja, se um sinal bloqueado for recebido durante sua execu\u00e7\u00e3o ele \u00e9 colocado \"em espera\" at\u00e9 que sa_handler acabe de rodar! Exercise Bloquear sinais evita o problema detectado na parte anterior? Resposta Sim! Desta forma, garantimos consist\u00eancia no valor da vari\u00e1vel status . Exercise Quais sinais dever\u00e3o ser bloqueados durante a execu\u00e7\u00e3o do handler SIGINT ? E durante a execu\u00e7\u00e3o do handler SIGTERM ? Resposta No registro do handler de SIGINT , bloqueamos SIGTERM . No registro do handler de SIGTERM , bloqueamos SIGINT . Exercise O campo sa_mask , da estrutura struct sigaction , permite bloquear sinais enquanto os handlers executam. Veja nos slides da aula como acessar esse campo e use man sigaddset para ver como preench\u00ea-lo. Escreva abaixo os comandos para tal. Resposta Podemos fazer, por exemplo, sigaddset(&handler_sigterm.sa_mask, SIGINT); Example Modifique sinais-concorrentes.c para que SIGTERM seja bloqueado enquanto o handler de SIGINT roda. Repita ent\u00e3o o experiemento acima e veja que n\u00e3o h\u00e1 mais conflito na vari\u00e1vel global compartilhada. O que fizemos n\u00e3o permite que SIGINT seja interrompido por um SIGTERM , mas permite que um SIGTERM seja interrompido por um SIGINT ! Corrija esta situa\u00e7\u00e3o.","title":"Bloqueio de sinais"},{"location":"aulas/17-sinais-II/#exercicios-para-praticar","text":"Exercise Modifique sinal1.c para que, ao ser colocado em background usando Ctrl+Z (SIGTSTP), imprima uma mensagem antes de parar de executar. Dicas : Voc\u00ea precisa retornar o comportamento padr\u00e3o do sinal depois de dar o print. Pesquise como usar raise para (re)enviar um sinal para o pr\u00f3prio processo. Exercise Complete o programa acima com uma outra fun\u00e7\u00e3o que imprime a mensagem Continuando! quando o programa voltar a rodar (sinal SIGCONT ). Uma parte importante de sinais em sistemas POSIX \u00e9 que, ao interromper um processo, eles podem cancelar opera\u00e7\u00f5es que estavam ocorrendo. Em especial, chamadas de sistema que deixam um processo bloqueado (como wait e sleep ) ou que fazem opera\u00e7\u00f5es de entrada/sa\u00edda (como read e write ). Exercise Compile e rode o programa sleep_longo.c . O qu\u00ea foi mostrado na tela? Exercise Rode novamente o programa. Abra um novo terminal e envie um sinal SIGTERM para este processo. O qu\u00ea \u00e9 mostrado na tela? Voc\u00ea consegue interpretar este resultado? Dicas : Ser\u00e1 \u00fatil exibir na sa\u00edda padr\u00e3o o PID do processo! Repita a execu\u00e7\u00e3o m\u00faltiplas vezes. Vai te ajudar a entender o que acontece. Em algumas envie o sinal SIGTERM rapidamente, em outras, aguarde mais alguns segundos! Exercise Como checamos que sleep realmente parou o processo por todo o tempo? Resposta A resposta est\u00e1 no manual. Leia em especial o RETURN VALUE! $ man 3 sleep Exercise Modifique o programa para que ele chame sleep tanto quanto for necess\u00e1rio para que o processo durma o tempo especificado. Salve este arquivo como sleep_longo_while.c . Exercise Troque o c\u00f3digo de sleep_longo.c para ignorar o sinal SIGTERM . O programa agora funciona como esperado? Por que?","title":"Exerc\u00edcios para praticar"},{"location":"aulas/18-threads-I/","text":"18 - Concorr\u00eancia e Threads \u00b6 Nossa aula de hoje envolver\u00e1 aprender a API pthreads para cria\u00e7\u00e3o de threads e sincroniza\u00e7\u00e3o simples. Criando tarefas e esperando elas acabarem \u00b6 O exemplo abaixo cria uma thread que roda a fun\u00e7\u00e3o primeira_thread , espera por seu fim e mostra a mensagem Fim do programa . // Fun\u00e7\u00f5es rodadas em thread sempre tem essa assinatura void * minha_thread ( void * arg ) { printf ( \"Hello thread! \\n \" ); return NULL ; } .... pthread_t tid ; int error = pthread_create ( & tid , NULL , minha_thread , NULL ); pthread_join ( tid , NULL ); // espera tid acabar. Example Compile o arquivo exemplo1.c com a flag especial -pthread e execute-o. $ gcc exemplo1.c -o exemplo1 -pthread $ ./exemplo1 Vamos dissecar a chamada da fun\u00e7\u00e3o pthread_create : int error = pthread_create ( & tid , // vari\u00e1vel para guardar ID da nova thread NULL , // op\u00e7\u00f5es de cria\u00e7\u00e3o. NULL = op\u00e7\u00f5es padr\u00e3o minha_thread , // fun\u00e7\u00e3o a ser executada NULL // par\u00e2metro passado para a fun\u00e7\u00e3o acima ); Toda thread que rodarmos ter\u00e1 a seguinte assinatura (mudando, \u00e9 claro, o nome da fun\u00e7\u00e3o). void * minha_thread ( void * arg ); Uma vari\u00e1vel do tipo void * representa um endere\u00e7o de mem\u00f3ria cujo conte\u00fado \u00e9 desconhecido. Ou seja, ele diz somente onde encontrar os dados, mas n\u00e3o diz o que est\u00e1 guardado na mem\u00f3ria naquele lugar. Este tipo de vari\u00e1vel \u00e9 usada quando queremos passar blocos de mem\u00f3ria entre fun\u00e7\u00f5es mas n\u00e3o queremos fixar um tipo de dados. Veremos com mais detalhes como isto funciona na parte 2. Example O manual cont\u00e9m entradas muito bem escritas de todas as chamadas de POSIX threads que usaremos. Abra as seguintes e se familiarize com seu conte\u00fado. $ man 7 pthreads $ man 3 pthread_create $ man 3 pthread_join Assim como processos, threads s\u00e3o escalonadas pelo kernel. Isto significa que n\u00e3o controlamos a ordem em que elas rodam no nosso programa. Ou seja, ao executar pthread_create n\u00e3o sabemos se a thread principal (aquela que roda o main ) continuar\u00e1 rodando ou se o controle passar\u00e1 instantaneamente para a nova thread. A primitiva de sincroniza\u00e7\u00e3o mais simples que dispomos \u00e9 pthread_join , que garante que uma thread s\u00f3 prossegue quando outra acabar. Exercise Retire o pthread_join do programa exemplo e o execute. Repita a execu\u00e7\u00e3o v\u00e1rias vezes. Todas as vezes o resultado \u00e9 o mesmo? O qu\u00ea acontece? Resposta N\u00e3o. Como a main pode chegar no return 0 , ent\u00e3o o processo pode acabar sem que a thread tenha sido devidamente executada. Exercise \u00c9 poss\u00edvel que duas threads chamem pthread_join na mesma thread destino? Consulte o manual para saber esta resposta. Resposta A resposta est\u00e1 dispon\u00edvel na se\u00e7\u00e3o DESCRIPTION ao executar man 3 pthread_join : If multiple threads simultaneously try to join with the same thread... A resposta acima indica que precisaremos de outras primitivas de sincroniza\u00e7\u00e3o mais sofisticadas no futuro. Veremos isso nas pr\u00f3ximas aulas. Example Em um novo arquivo .c , crie quatro threads, cada uma executando uma fun\u00e7\u00e3o diferente que faz um print distinto. Compile e execute seu programa v\u00e1rias vezes. A sa\u00edda ser\u00e1 sempre a mesma, com os printfs sempre na mesma ordem? O que est\u00e1 acontecendo?! Passando argumentos para threads \u00b6 Nossas threads ainda s\u00e3o muito limitadas: elas n\u00e3o recebem nenhum argumento nem devolvem resultados. Vamos consertar isso nesta se\u00e7\u00e3o. Vimos na parte 1 que o \u00faltimo argumento de pthread_create \u00e9 um ponteiro para os dados que nossa fun\u00e7\u00e3o dever\u00e1 receber. Neste sequ\u00eancia de exerc\u00edcios iremos aprender a usar este argumento para passar dados para nossas threads. Nosso primeiro exerc\u00edcio ser\u00e1 feito passo a passo. Siga cada um dos passos a risca e depois responda as quest\u00f5es. Vamos trabalhar a partir de um arquivo vazio. Example Crie um programa simples com uma fun\u00e7\u00e3o main que aloca (usando malloc) um vetor *vi com 4 int s e um vetor *tids com 4 pthread_t s. Example Adicione ao seu programa um for que cria 4 threads, use o vetor *vi para armazenar, em cada posi\u00e7\u00e3o do vetor, os valores do \u00edndice do for , e no vetor *tids na na chamada da fun\u00e7\u00e3o pthread_create . Passe como \u00faltimo argumento da fun\u00e7\u00e3o pthread_create o endere\u00e7o do elemento correspondente de vi . Example Espere pelo fim desta thread. Example Crie uma fun\u00e7\u00e3o void *tarefa_print_i(void *arg) que declara uma vari\u00e1vel int *i e d\u00e1 print em seu conte\u00fado. Inicialize a vari\u00e1vel i como mostrado abaixo: int *i = (int *) arg; Exercise Explique a utiliza\u00e7\u00e3o da vari\u00e1vel i na tarefa acima. Resposta Apontadores void * cont\u00e9m somente o endere\u00e7o do dado, mas sem indicar seu tipo. Ao declarar i acima dizemos que queremos interpretar aquele endere\u00e7o como o endere\u00e7o de um int . Assim, quando fazemos *i conseguimos acessar o inteiro presente no endere\u00e7o passado para a thread. Se seu programa estiver correto voc\u00ea dever\u00e1 ver no terminal 4 prints com n\u00fameros de 0 a 3, cada um vindo de um thread. Warning Se tiver problemas, valide seu c\u00f3digo com algum colega que j\u00e1 tenha sido validado pelo professor. Se n\u00e3o tiver ningu\u00e9m por perto j\u00e1 validado me chame ;) Exercise Explique como \u00e9 feita a passagem do argumento para a thread. Resposta A thread recebe o endere\u00e7o da respectiva posi\u00e7\u00e3o do array alocado din\u00e2micamente. Exercise Passamos para a thread um valor alocado dinamicamente. Por que isso \u00e9 necess\u00e1rio? Resposta Vamos discutir depois! Vamos explorar a resposta da pergunta acima nos pr\u00f3ximos exerc\u00edcios. Para cada exerc\u00edcio, encontre seu problema, descreva-o usando suas pr\u00f3prias palavras e mostre um exemplo de sa\u00edda poss\u00edvel. Somente depois de escrever sua resposta rode o programa. Warning Cada exerc\u00edcio foca em um problema diferente. A resposta n\u00e3o \u00e9 a mesma para ambas. Exercise Identifique um problema de escopo de dados no c\u00f3digo abaixo (arquivo parte2-1.c ) Dica: compile, execute e leia o c\u00f3digo para tentar entender o problema! void * minha_thread ( void * arg ) { int * i = ( int * ) arg ; printf ( \"Hello thread! %d \\n \" , * i ); } // dentro do main for ( int i = 0 ; i < 4 ; i ++ ) { pthread_create ( & tid [ i ], NULL , minha_thread , & i ); } Resposta Com threads, n\u00e3o tenho garantir da ordem de escalonamento (n\u00e3o qual thread o sistema operacional vai escolher para execu\u00e7\u00e3o, nem em qual ordem). Assim, a thread da main altera o valor da vari\u00e1vel i e quando cada thread executa, o valor recuperado \u00e9 diferente do esperado. Exercise Identifique um problema de escopo de dados no c\u00f3digo abaixo (arquivo parte2-2.c ) Dica: compile, execute e leia o c\u00f3digo para tentar entender o problema! void * minha_thread ( void * arg ) { int * i = ( int * ) arg ; printf ( \"Hello thread! %d \\n \" , * i ); } pthread_t * criar_threads ( int n ) { pthread_t * tids = malloc ( sizeof ( pthread_t ) * n ); for ( int i = 0 ; i < n ; i ++ ) { pthread_create ( & tids [ i ], NULL , minha_thread , & i ); } return tids ; } // dentro do main pthread_t * tids = criar_threads ( 4 ); Resposta Lembra da pilha ou stack ? Veja nos slides, cada thread tem o seu pr\u00f3prio espa\u00e7o para guardar suas vari\u00e1veis locais. Quando uma fun\u00e7\u00e3o \u00e9 finalizada, o espa\u00e7o alocado a ela na stack pode ser reutilizado. Neste exemplo, cada thread da minha_thread tenta ler uma vari\u00e1vel local i criada no for da fun\u00e7\u00e3o criar_threads , que pode n\u00e3o \"existir\" mais quando a fun\u00e7\u00e3o minha_thread \u00e9 executada. Warning Valide sua solu\u00e7\u00e3o com o professor para garantir que realmente entendeu! Agora que j\u00e1 entendemos como passar um argumento e que devemos sempre coloc\u00e1-lo no heap , passar v\u00e1rios \u00e9 muito simples: alocamos um struct com todos os dados que queremos enviar e passamos seu endere\u00e7o no \u00faltimo argumento. Ao receb\u00ea-lo, a fun\u00e7\u00e3o faz um cast de void * para um ponteiro para o struct . Example Modifique seu exerc\u00edcio do come\u00e7o desta parte para receber dois argumentos do tipo inteiro e imprimir ambos valores. Retornando valores \u00b6 Na pr\u00e1tica, ao passar struct s para threads como argumentos j\u00e1 sabemos como retornar valores: basta adicionar um campo que pr\u00f3pria thread deve preencher com o resultado de sua execu\u00e7\u00e3o. Isso \u00e9 equivalente a criar uma fun\u00e7\u00e3o que retorna valores em vari\u00e1veis passadas por refer\u00eancia (ou seja, escrevendo em vari\u00e1veis passadas como ponteiros). Example Modifique seu exerc\u00edcio da parte anterior para que as threads retornem a multiplica\u00e7\u00e3o dos dois inteiros passados. Fa\u00e7a o print deste valor no main .","title":"18 - Concorr\u00eancia e Threads"},{"location":"aulas/18-threads-I/#18-concorrencia-e-threads","text":"Nossa aula de hoje envolver\u00e1 aprender a API pthreads para cria\u00e7\u00e3o de threads e sincroniza\u00e7\u00e3o simples.","title":"18 - Concorr\u00eancia e Threads"},{"location":"aulas/18-threads-I/#criando-tarefas-e-esperando-elas-acabarem","text":"O exemplo abaixo cria uma thread que roda a fun\u00e7\u00e3o primeira_thread , espera por seu fim e mostra a mensagem Fim do programa . // Fun\u00e7\u00f5es rodadas em thread sempre tem essa assinatura void * minha_thread ( void * arg ) { printf ( \"Hello thread! \\n \" ); return NULL ; } .... pthread_t tid ; int error = pthread_create ( & tid , NULL , minha_thread , NULL ); pthread_join ( tid , NULL ); // espera tid acabar. Example Compile o arquivo exemplo1.c com a flag especial -pthread e execute-o. $ gcc exemplo1.c -o exemplo1 -pthread $ ./exemplo1 Vamos dissecar a chamada da fun\u00e7\u00e3o pthread_create : int error = pthread_create ( & tid , // vari\u00e1vel para guardar ID da nova thread NULL , // op\u00e7\u00f5es de cria\u00e7\u00e3o. NULL = op\u00e7\u00f5es padr\u00e3o minha_thread , // fun\u00e7\u00e3o a ser executada NULL // par\u00e2metro passado para a fun\u00e7\u00e3o acima ); Toda thread que rodarmos ter\u00e1 a seguinte assinatura (mudando, \u00e9 claro, o nome da fun\u00e7\u00e3o). void * minha_thread ( void * arg ); Uma vari\u00e1vel do tipo void * representa um endere\u00e7o de mem\u00f3ria cujo conte\u00fado \u00e9 desconhecido. Ou seja, ele diz somente onde encontrar os dados, mas n\u00e3o diz o que est\u00e1 guardado na mem\u00f3ria naquele lugar. Este tipo de vari\u00e1vel \u00e9 usada quando queremos passar blocos de mem\u00f3ria entre fun\u00e7\u00f5es mas n\u00e3o queremos fixar um tipo de dados. Veremos com mais detalhes como isto funciona na parte 2. Example O manual cont\u00e9m entradas muito bem escritas de todas as chamadas de POSIX threads que usaremos. Abra as seguintes e se familiarize com seu conte\u00fado. $ man 7 pthreads $ man 3 pthread_create $ man 3 pthread_join Assim como processos, threads s\u00e3o escalonadas pelo kernel. Isto significa que n\u00e3o controlamos a ordem em que elas rodam no nosso programa. Ou seja, ao executar pthread_create n\u00e3o sabemos se a thread principal (aquela que roda o main ) continuar\u00e1 rodando ou se o controle passar\u00e1 instantaneamente para a nova thread. A primitiva de sincroniza\u00e7\u00e3o mais simples que dispomos \u00e9 pthread_join , que garante que uma thread s\u00f3 prossegue quando outra acabar. Exercise Retire o pthread_join do programa exemplo e o execute. Repita a execu\u00e7\u00e3o v\u00e1rias vezes. Todas as vezes o resultado \u00e9 o mesmo? O qu\u00ea acontece? Resposta N\u00e3o. Como a main pode chegar no return 0 , ent\u00e3o o processo pode acabar sem que a thread tenha sido devidamente executada. Exercise \u00c9 poss\u00edvel que duas threads chamem pthread_join na mesma thread destino? Consulte o manual para saber esta resposta. Resposta A resposta est\u00e1 dispon\u00edvel na se\u00e7\u00e3o DESCRIPTION ao executar man 3 pthread_join : If multiple threads simultaneously try to join with the same thread... A resposta acima indica que precisaremos de outras primitivas de sincroniza\u00e7\u00e3o mais sofisticadas no futuro. Veremos isso nas pr\u00f3ximas aulas. Example Em um novo arquivo .c , crie quatro threads, cada uma executando uma fun\u00e7\u00e3o diferente que faz um print distinto. Compile e execute seu programa v\u00e1rias vezes. A sa\u00edda ser\u00e1 sempre a mesma, com os printfs sempre na mesma ordem? O que est\u00e1 acontecendo?!","title":"Criando tarefas e esperando elas acabarem"},{"location":"aulas/18-threads-I/#passando-argumentos-para-threads","text":"Nossas threads ainda s\u00e3o muito limitadas: elas n\u00e3o recebem nenhum argumento nem devolvem resultados. Vamos consertar isso nesta se\u00e7\u00e3o. Vimos na parte 1 que o \u00faltimo argumento de pthread_create \u00e9 um ponteiro para os dados que nossa fun\u00e7\u00e3o dever\u00e1 receber. Neste sequ\u00eancia de exerc\u00edcios iremos aprender a usar este argumento para passar dados para nossas threads. Nosso primeiro exerc\u00edcio ser\u00e1 feito passo a passo. Siga cada um dos passos a risca e depois responda as quest\u00f5es. Vamos trabalhar a partir de um arquivo vazio. Example Crie um programa simples com uma fun\u00e7\u00e3o main que aloca (usando malloc) um vetor *vi com 4 int s e um vetor *tids com 4 pthread_t s. Example Adicione ao seu programa um for que cria 4 threads, use o vetor *vi para armazenar, em cada posi\u00e7\u00e3o do vetor, os valores do \u00edndice do for , e no vetor *tids na na chamada da fun\u00e7\u00e3o pthread_create . Passe como \u00faltimo argumento da fun\u00e7\u00e3o pthread_create o endere\u00e7o do elemento correspondente de vi . Example Espere pelo fim desta thread. Example Crie uma fun\u00e7\u00e3o void *tarefa_print_i(void *arg) que declara uma vari\u00e1vel int *i e d\u00e1 print em seu conte\u00fado. Inicialize a vari\u00e1vel i como mostrado abaixo: int *i = (int *) arg; Exercise Explique a utiliza\u00e7\u00e3o da vari\u00e1vel i na tarefa acima. Resposta Apontadores void * cont\u00e9m somente o endere\u00e7o do dado, mas sem indicar seu tipo. Ao declarar i acima dizemos que queremos interpretar aquele endere\u00e7o como o endere\u00e7o de um int . Assim, quando fazemos *i conseguimos acessar o inteiro presente no endere\u00e7o passado para a thread. Se seu programa estiver correto voc\u00ea dever\u00e1 ver no terminal 4 prints com n\u00fameros de 0 a 3, cada um vindo de um thread. Warning Se tiver problemas, valide seu c\u00f3digo com algum colega que j\u00e1 tenha sido validado pelo professor. Se n\u00e3o tiver ningu\u00e9m por perto j\u00e1 validado me chame ;) Exercise Explique como \u00e9 feita a passagem do argumento para a thread. Resposta A thread recebe o endere\u00e7o da respectiva posi\u00e7\u00e3o do array alocado din\u00e2micamente. Exercise Passamos para a thread um valor alocado dinamicamente. Por que isso \u00e9 necess\u00e1rio? Resposta Vamos discutir depois! Vamos explorar a resposta da pergunta acima nos pr\u00f3ximos exerc\u00edcios. Para cada exerc\u00edcio, encontre seu problema, descreva-o usando suas pr\u00f3prias palavras e mostre um exemplo de sa\u00edda poss\u00edvel. Somente depois de escrever sua resposta rode o programa. Warning Cada exerc\u00edcio foca em um problema diferente. A resposta n\u00e3o \u00e9 a mesma para ambas. Exercise Identifique um problema de escopo de dados no c\u00f3digo abaixo (arquivo parte2-1.c ) Dica: compile, execute e leia o c\u00f3digo para tentar entender o problema! void * minha_thread ( void * arg ) { int * i = ( int * ) arg ; printf ( \"Hello thread! %d \\n \" , * i ); } // dentro do main for ( int i = 0 ; i < 4 ; i ++ ) { pthread_create ( & tid [ i ], NULL , minha_thread , & i ); } Resposta Com threads, n\u00e3o tenho garantir da ordem de escalonamento (n\u00e3o qual thread o sistema operacional vai escolher para execu\u00e7\u00e3o, nem em qual ordem). Assim, a thread da main altera o valor da vari\u00e1vel i e quando cada thread executa, o valor recuperado \u00e9 diferente do esperado. Exercise Identifique um problema de escopo de dados no c\u00f3digo abaixo (arquivo parte2-2.c ) Dica: compile, execute e leia o c\u00f3digo para tentar entender o problema! void * minha_thread ( void * arg ) { int * i = ( int * ) arg ; printf ( \"Hello thread! %d \\n \" , * i ); } pthread_t * criar_threads ( int n ) { pthread_t * tids = malloc ( sizeof ( pthread_t ) * n ); for ( int i = 0 ; i < n ; i ++ ) { pthread_create ( & tids [ i ], NULL , minha_thread , & i ); } return tids ; } // dentro do main pthread_t * tids = criar_threads ( 4 ); Resposta Lembra da pilha ou stack ? Veja nos slides, cada thread tem o seu pr\u00f3prio espa\u00e7o para guardar suas vari\u00e1veis locais. Quando uma fun\u00e7\u00e3o \u00e9 finalizada, o espa\u00e7o alocado a ela na stack pode ser reutilizado. Neste exemplo, cada thread da minha_thread tenta ler uma vari\u00e1vel local i criada no for da fun\u00e7\u00e3o criar_threads , que pode n\u00e3o \"existir\" mais quando a fun\u00e7\u00e3o minha_thread \u00e9 executada. Warning Valide sua solu\u00e7\u00e3o com o professor para garantir que realmente entendeu! Agora que j\u00e1 entendemos como passar um argumento e que devemos sempre coloc\u00e1-lo no heap , passar v\u00e1rios \u00e9 muito simples: alocamos um struct com todos os dados que queremos enviar e passamos seu endere\u00e7o no \u00faltimo argumento. Ao receb\u00ea-lo, a fun\u00e7\u00e3o faz um cast de void * para um ponteiro para o struct . Example Modifique seu exerc\u00edcio do come\u00e7o desta parte para receber dois argumentos do tipo inteiro e imprimir ambos valores.","title":"Passando argumentos para threads"},{"location":"aulas/18-threads-I/#retornando-valores","text":"Na pr\u00e1tica, ao passar struct s para threads como argumentos j\u00e1 sabemos como retornar valores: basta adicionar um campo que pr\u00f3pria thread deve preencher com o resultado de sua execu\u00e7\u00e3o. Isso \u00e9 equivalente a criar uma fun\u00e7\u00e3o que retorna valores em vari\u00e1veis passadas por refer\u00eancia (ou seja, escrevendo em vari\u00e1veis passadas como ponteiros). Example Modifique seu exerc\u00edcio da parte anterior para que as threads retornem a multiplica\u00e7\u00e3o dos dois inteiros passados. Fa\u00e7a o print deste valor no main .","title":"Retornando valores"},{"location":"aulas/19-sincronizacao/","text":"19 - Sincroniza\u00e7\u00e3o com Mutex \u00b6 Na \u00faltima aula aprendemos as APIs da biblioteca pthread para criar e esperar a finaliza\u00e7\u00e3o de threads. Tamb\u00e9m aprendemos a passar argumentos e receber de volta valores usando um struct alocado dinamicamente. Aquecimento \u00b6 Vamos iniciar uma revis\u00e3o trabalhando em cima do arquivo soma_global.c . Example Abra o arquivo e analise seu conte\u00fado. Exercise Qual o papel da fun\u00e7\u00e3o soma_parcial ? Explique o papel de cada atributo de struct soma_parcial_args . Resposta Soma parte de um array (alguns elementos). Nos argumentos, o *vetor representa um ponteiro para todos os elementos do array. J\u00e1 start e end representam o range de posi\u00e7\u00f5es as quais queremos somar. Exercise Como voc\u00ea setaria os atributos de struct soma_partical_args para obter a soma do vetor todo? E para obter somente a soma da primeira metade do vetor? Resposta args->vetor = vetor; args->start = 0; args->end = n; Para fins did\u00e1ticos, estamos atualizando diretamente a vari\u00e1vel soma_total dentro do for . Example Complete as partes faltantes e rode o programa e compile o programa soma_global.c : gcc soma_global.c -o soma_global -pthread Execute dois testes com entrada dos arquivos in1.txt e in2.txt . ./soma_global < in1.txt ./soma_global < in1.txt Eles d\u00e3o os resultados esperados? Exercise Os resultados acima estar\u00e3o errados. Voc\u00ea consegue explicar por que? Resposta Na opera\u00e7\u00e3o soma = soma + spa->vetor[i]; a vari\u00e1vel global soma est\u00e1 sendo lida, somada e posteriormente atribu\u00edda a ela pr\u00f3pria. Entretando, entre a leitura e a atribui\u00e7\u00e3o, outra thread pode atualizar o valor da soma , tornando os resultados inconsistentes e imprevis\u00edveis. Sincroniza\u00e7\u00e3o usando mutex - Sem\u00e1foro Bin\u00e1rio \u00b6 Vamos agora trabalhar agora para corrigir este erro! Lembrando da aula, as opera\u00e7\u00f5es poss\u00edveis s\u00e3o as seguintes: lock - se tiver destravado, trava e continua; se n\u00e3o estiver espera. unlock - se tiver a trava, a destrava e permite que outras tarefas travem. Note que n\u00e3o existe garantia de ordem! Ou seja, se tiverem v\u00e1rios processos esperando por um mutex qualquer um deles pode receber o acesso. Inclusive, uma thread pode esperar \"para sempre\" e nunca receber o acesso. N\u00e3o \u00e9 prov\u00e1vel, mas \u00e9 poss\u00edvel. Warning Voc\u00ea pode precisar instalar o pacote manpages-posix-dev para obter as p\u00e1ginas do manual usadas neste roteiro. $ sudo apt update $ sudo apt install manpages-posix-dev Exercise Identifique no seu c\u00f3digo quais linhas comp\u00f5e a regi\u00e3o cr\u00edtica e onde deveriam estar as diretivas lock e unlock . Escreva abaixo suas conclu\u00f5es. Resposta Onde a soma est\u00e1 sendo atualizada. Damos lock antes e unlock depois da linha soma = soma + spa->vetor[i]; Example Coloque um coment\u00e1rio nas linhas identificadas acima. J\u00e1 sabemos onde iremos colocar as opera\u00e7\u00f5es de lock e unlock do mutex. Agora falta s\u00f3 cri\u00e1-lo. Exercise O mutex precisa ser criado e inicializado. Onde isto deve ser feito? Como ele pode ser recebido pela fun\u00e7\u00e3o da thread? Resposta Podemos fazer isto na fun\u00e7\u00e3o main , antes da cria\u00e7\u00e3o das threads. Para que ele seja recebido pela fun\u00e7\u00e3o, podemos criar um outro argumento na nossa struct soma_parcial_args ! Exercise Consulte o manual de pthread_mutex_init e escreva abaixo como criar e inicializar um mutex. Resposta Podemos fazer, por exemplo: pthread_mutex_t mutex_soma = PTHREAD_MUTEX_INITIALIZER ; Exercise Consulte o manual de pthread_mutex_lock e pthread_mutex_unlock e escreva abaixo como us\u00e1-las. Resposta pthread_mutex_lock ( < mutex_address > ); // Fa\u00e7a sua opera\u00e7\u00e3o! pthread_mutex_unlock ( < mutex_address > ); Example Com base nas suas respostas acima, conserte seu programa soma_global.c e verifique que ele retorna os resultados corretos. Exercise Agora me\u00e7a o tempo de execu\u00e7\u00e3o e anote abaixo. Compare com o original (que n\u00e3o funcionava) e explique a diferen\u00e7a. Resposta Podemos conferir utilizando o comando time no terminal. Percebemos um aumento no tempo com o uso do mutex. Isto ocorre devido a necessidade de sincronizar o acesso \u00e0 vari\u00e1vel global soma . $ time soma_global_v1 < in2.txt $ time soma_global_v2 < in2.txt Tip Usar mutex \u00e9 muito caro! Al\u00e9m de acabar com o paralelismo, as opera\u00e7\u00f5es lock e unlock tamb\u00e9m s\u00e3o custosas. Economizando mutex \u00b6 Nesta parte final iremos ver como diminuir o n\u00famero de chamadas ao mutex . Exercise \u00c9 necess\u00e1rio atualizar a vari\u00e1vel global soma a cada itera\u00e7\u00e3o do for ? E \u00e9 poss\u00edvel atualiz\u00e1-la somente uma vez por thread? Resposta Podemos criar uma vari\u00e1vel local que acumula a soma e s\u00f3 atualiza soma_global no fim. Seria uma vari\u00e1vel por thread! Example Implemente a ideia acima e veja se houve melhora. Salve como soma-global2.c . O exerc\u00edcio acima dever\u00e1 ter desempenho bom, j\u00e1 que limitamos a quantidade de vezes que usamos o mutex . Vamos tentar outra ideia agora. Exercise Precisamos da vari\u00e1vel global? E se cada thread retornasse sua soma parcial? Como o programa poderia ser organizado para que essa ideia funcione? Resposta Cada thread poderia retornar na struct de argumentos o resultado de sua soma. Na fun\u00e7\u00e3o main, ap\u00f3s cada reposta de conclus\u00e3o da thread (retorno da pthread_join ), poder\u00edamos somar os resultados. Exercise A ideia acima precisou de mutex ? Por que? Resposta N\u00e3o, pois na fun\u00e7\u00e3o main a execu\u00e7\u00e3o da soma seria sequencial. Example Implemente a ideia acima e confira os resultados. Houve melhora no desempenho?","title":"19 - Sincroniza\u00e7\u00e3o com Mutex"},{"location":"aulas/19-sincronizacao/#19-sincronizacao-com-mutex","text":"Na \u00faltima aula aprendemos as APIs da biblioteca pthread para criar e esperar a finaliza\u00e7\u00e3o de threads. Tamb\u00e9m aprendemos a passar argumentos e receber de volta valores usando um struct alocado dinamicamente.","title":"19 - Sincroniza\u00e7\u00e3o com Mutex"},{"location":"aulas/19-sincronizacao/#aquecimento","text":"Vamos iniciar uma revis\u00e3o trabalhando em cima do arquivo soma_global.c . Example Abra o arquivo e analise seu conte\u00fado. Exercise Qual o papel da fun\u00e7\u00e3o soma_parcial ? Explique o papel de cada atributo de struct soma_parcial_args . Resposta Soma parte de um array (alguns elementos). Nos argumentos, o *vetor representa um ponteiro para todos os elementos do array. J\u00e1 start e end representam o range de posi\u00e7\u00f5es as quais queremos somar. Exercise Como voc\u00ea setaria os atributos de struct soma_partical_args para obter a soma do vetor todo? E para obter somente a soma da primeira metade do vetor? Resposta args->vetor = vetor; args->start = 0; args->end = n; Para fins did\u00e1ticos, estamos atualizando diretamente a vari\u00e1vel soma_total dentro do for . Example Complete as partes faltantes e rode o programa e compile o programa soma_global.c : gcc soma_global.c -o soma_global -pthread Execute dois testes com entrada dos arquivos in1.txt e in2.txt . ./soma_global < in1.txt ./soma_global < in1.txt Eles d\u00e3o os resultados esperados? Exercise Os resultados acima estar\u00e3o errados. Voc\u00ea consegue explicar por que? Resposta Na opera\u00e7\u00e3o soma = soma + spa->vetor[i]; a vari\u00e1vel global soma est\u00e1 sendo lida, somada e posteriormente atribu\u00edda a ela pr\u00f3pria. Entretando, entre a leitura e a atribui\u00e7\u00e3o, outra thread pode atualizar o valor da soma , tornando os resultados inconsistentes e imprevis\u00edveis.","title":"Aquecimento"},{"location":"aulas/19-sincronizacao/#sincronizacao-usando-mutex-semaforo-binario","text":"Vamos agora trabalhar agora para corrigir este erro! Lembrando da aula, as opera\u00e7\u00f5es poss\u00edveis s\u00e3o as seguintes: lock - se tiver destravado, trava e continua; se n\u00e3o estiver espera. unlock - se tiver a trava, a destrava e permite que outras tarefas travem. Note que n\u00e3o existe garantia de ordem! Ou seja, se tiverem v\u00e1rios processos esperando por um mutex qualquer um deles pode receber o acesso. Inclusive, uma thread pode esperar \"para sempre\" e nunca receber o acesso. N\u00e3o \u00e9 prov\u00e1vel, mas \u00e9 poss\u00edvel. Warning Voc\u00ea pode precisar instalar o pacote manpages-posix-dev para obter as p\u00e1ginas do manual usadas neste roteiro. $ sudo apt update $ sudo apt install manpages-posix-dev Exercise Identifique no seu c\u00f3digo quais linhas comp\u00f5e a regi\u00e3o cr\u00edtica e onde deveriam estar as diretivas lock e unlock . Escreva abaixo suas conclu\u00f5es. Resposta Onde a soma est\u00e1 sendo atualizada. Damos lock antes e unlock depois da linha soma = soma + spa->vetor[i]; Example Coloque um coment\u00e1rio nas linhas identificadas acima. J\u00e1 sabemos onde iremos colocar as opera\u00e7\u00f5es de lock e unlock do mutex. Agora falta s\u00f3 cri\u00e1-lo. Exercise O mutex precisa ser criado e inicializado. Onde isto deve ser feito? Como ele pode ser recebido pela fun\u00e7\u00e3o da thread? Resposta Podemos fazer isto na fun\u00e7\u00e3o main , antes da cria\u00e7\u00e3o das threads. Para que ele seja recebido pela fun\u00e7\u00e3o, podemos criar um outro argumento na nossa struct soma_parcial_args ! Exercise Consulte o manual de pthread_mutex_init e escreva abaixo como criar e inicializar um mutex. Resposta Podemos fazer, por exemplo: pthread_mutex_t mutex_soma = PTHREAD_MUTEX_INITIALIZER ; Exercise Consulte o manual de pthread_mutex_lock e pthread_mutex_unlock e escreva abaixo como us\u00e1-las. Resposta pthread_mutex_lock ( < mutex_address > ); // Fa\u00e7a sua opera\u00e7\u00e3o! pthread_mutex_unlock ( < mutex_address > ); Example Com base nas suas respostas acima, conserte seu programa soma_global.c e verifique que ele retorna os resultados corretos. Exercise Agora me\u00e7a o tempo de execu\u00e7\u00e3o e anote abaixo. Compare com o original (que n\u00e3o funcionava) e explique a diferen\u00e7a. Resposta Podemos conferir utilizando o comando time no terminal. Percebemos um aumento no tempo com o uso do mutex. Isto ocorre devido a necessidade de sincronizar o acesso \u00e0 vari\u00e1vel global soma . $ time soma_global_v1 < in2.txt $ time soma_global_v2 < in2.txt Tip Usar mutex \u00e9 muito caro! Al\u00e9m de acabar com o paralelismo, as opera\u00e7\u00f5es lock e unlock tamb\u00e9m s\u00e3o custosas.","title":"Sincroniza\u00e7\u00e3o usando mutex - Sem\u00e1foro Bin\u00e1rio"},{"location":"aulas/19-sincronizacao/#economizando-mutex","text":"Nesta parte final iremos ver como diminuir o n\u00famero de chamadas ao mutex . Exercise \u00c9 necess\u00e1rio atualizar a vari\u00e1vel global soma a cada itera\u00e7\u00e3o do for ? E \u00e9 poss\u00edvel atualiz\u00e1-la somente uma vez por thread? Resposta Podemos criar uma vari\u00e1vel local que acumula a soma e s\u00f3 atualiza soma_global no fim. Seria uma vari\u00e1vel por thread! Example Implemente a ideia acima e veja se houve melhora. Salve como soma-global2.c . O exerc\u00edcio acima dever\u00e1 ter desempenho bom, j\u00e1 que limitamos a quantidade de vezes que usamos o mutex . Vamos tentar outra ideia agora. Exercise Precisamos da vari\u00e1vel global? E se cada thread retornasse sua soma parcial? Como o programa poderia ser organizado para que essa ideia funcione? Resposta Cada thread poderia retornar na struct de argumentos o resultado de sua soma. Na fun\u00e7\u00e3o main, ap\u00f3s cada reposta de conclus\u00e3o da thread (retorno da pthread_join ), poder\u00edamos somar os resultados. Exercise A ideia acima precisou de mutex ? Por que? Resposta N\u00e3o, pois na fun\u00e7\u00e3o main a execu\u00e7\u00e3o da soma seria sequencial. Example Implemente a ideia acima e confira os resultados. Houve melhora no desempenho?","title":"Economizando mutex"},{"location":"aulas/20-semaforos/","text":"20 - Sem\u00e1foros \u00b6 Nas \u00faltimas aulas aprendemos as APIs da biblioteca pthread para criar e esperar a finaliza\u00e7\u00e3o de threads. Tamb\u00e9m aprendemos a passar argumentos e receber de volta valores usando um struct alocado dinamicamente. Usamos mutex quando precisamos criar regi\u00f5es de exclus\u00e3o m\u00fatua onde somente uma thread pode entrar por vez. Esta restri\u00e7\u00e3o \u00e9 muito forte e n\u00e3o contempla outro caso muito comum em programa\u00e7\u00e3o concorrente: sincroniza\u00e7\u00e3o de threads. Ou seja, o objetivo n\u00e3o \u00e9 proteger o acesso a dados compartilhados, mas sim impor restri\u00e7\u00f5es no progresso das threads de maneira que elas estejam sempre em uma situa\u00e7\u00e3o v\u00e1lida. Para isto trabalharemos com sem\u00e1foros , que s\u00e3o um mecanismo de sincroniza\u00e7\u00e3o mais sofisticado e em geral usado para que threads sincronizem seu progresso e possam executar em paralelo . Defini\u00e7\u00e3o : duas tarefas podem ser feitas em paralelo se elas n\u00e3o compartilham absolutamente nenhuma informa\u00e7\u00e3o. elas compartilham informa\u00e7\u00e3o mas possuem mecanismos de sincroniza\u00e7\u00e3o de tal maneira que toda ordem de execu\u00e7\u00e3o poss\u00edvel de suas instru\u00e7\u00f5es resulte no mesmo resultado final. Sem\u00e1foros ajudam a criar programas no segundo caso. Nesta aula iremos olhar o caso mais simples de sincroniza\u00e7\u00e3o: duas threads combinam de s\u00f3 progredirem quando chegarem em um certo ponto do programa. Rendez-vous (Sem\u00e1foros no Papel) \u00b6 A express\u00e3o Rendez-vous significa, literalmente, encontro em franc\u00eas. Ela \u00e9 usada para marcar um hor\u00e1rio para duas ou mais pessoas se encontrarem. No contexto de sincroniza\u00e7\u00e3o de tarefas, ele tamb\u00e9m \u00e9 usado para nomear o problema de sincroniza\u00e7\u00e3o mais simples: duas threads rodando fun\u00e7\u00f5es distintas precisam se sincronizar no meio de suas fun\u00e7\u00f5es. As partes A e B podem ser feitas em qualquer ordem, mas ambas obrigatoriamente devem ocorrer antes de iniciar a execu\u00e7\u00e3o de C e D. Note que C e D tamb\u00e9m podem ser feitas em qualquer ordem. Warning Quando dizemos que duas tarefas podem ser feitas em qualquer ordem n\u00e3o quer dizer que elas possam ser feitas em paralelo! Apenas estamos dizendo que A inteira pode ocorrer antes ou depois de B inteira e os resultados ser\u00e3o os mesmos. Exercise Quais das ordens de execu\u00e7\u00e3o das partes A, B, C e D s\u00e3o v\u00e1lidas, segundo o RDV? A C B D A B C D B D A C Resposta O RDV separa a execu\u00e7\u00e3o de A e B de C e D. Ou seja, A B C D \u00e9 um resultado poss\u00edvel! Exercise Quais das ordens de execu\u00e7\u00e3o das partes A, B, C e D s\u00e3o v\u00e1lidas, segundo o RDV? B A D C A D B C B C A D Resposta O RDV separa a execu\u00e7\u00e3o de A e B de C e D. Ou seja, B A D C \u00e9 um resultado poss\u00edvel! Exercise Quais das ordens de execu\u00e7\u00e3o das partes A, B, C e D s\u00e3o v\u00e1lidas, segundo o RDV? A B D C B D A C B C A D Resposta Vamos listar todos os resultados v\u00e1lidos/poss\u00edvels: ABCD , ABDC , BACD ou BADC . Sempre A ou B antes de C ou D ! Vamos fazer a solu\u00e7\u00e3o do RDV no papel primeiro. Exercise Preencha aqui quantos sem\u00e1foros ser\u00e3o usados, seus nomes e valores iniciais. Resposta Vamos criar dois sem\u00e1foros s1 e s2 , inicializados na main com valor zero. Como as threads recebem apenas um argumento, seria uma boa criar uma struct para passar a refer\u00eancia dos sem\u00e1foros. Exercise Indique onde voc\u00ea usaria seus sem\u00e1foros para resolver o RDV. Resposta O sem\u00e1foro s1 ser\u00e1 \u00fatil para indicar que a thread1 chegou no RDV. J\u00e1 o sem\u00e1foro s2 ser\u00e1 utilizado para indicar que a thread2 chegou no RDV. Assim, utilizaremos os sem\u00e1foros entre os dois printf em cada fun\u00e7\u00e3o das threads. Sem\u00e1foros POSIX \u00b6 Existem, basicamente, dois tipos de sem\u00e1foros: named semaphores recebem um nome globalmente \u00fanico no sistema operacional e s\u00e3o compartilhados entre processos diferentes e independentes, inclusive que n\u00e3o t\u00eam rela\u00e7\u00e3o de parentesco (como pai-filho). unnamed semaphores n\u00e3o t\u00eam nome, s\u00e3o criados como vari\u00e1veis local ou global e s\u00e3o acessados diretamente pelas threads de um mesmo processo. Como estamos usando threads, estamos interessados em unnamed semaphores . Use a p\u00e1gina sem_overview do manual para responder as perguntas abaixo. Exercise Quais fun\u00e7\u00f5es podemos usar para criar, destruir e operar unnamed semaphore ? Resposta sem_init , sem_destroy , sem_post e sem_wait . Example Implemente (do zero) um programa que cria duas threads e as sincroniza usando RDV . Ambas dever\u00e3o fazer um printf qualquer antes e um depois do ponto de encontro. Use a imagem do come\u00e7o da aula como guia. Barreiras - Exerc\u00edcio para Entrega \u00b6 Tip Esta aula cont\u00e9m atividade para entrega! Trabalhe na pasta atv/13-barrier que est\u00e1 no seu reposit\u00f3rio de entregas! Leia o README.md ! Se at\u00e9 aqui foi tranquilo, vamos misturar as duas aulas? Uma barreira \u00e9 a generaliza\u00e7\u00e3o do Rendez-vous, em que N threads rodando o mesmo c\u00f3digo precisam esperar umas pelas outras para continuar. Nesta tarefa, voc\u00ea deve lan\u00e7ar quatro threads e utilizar uma barreira para sincronizar as threads , de modo que elas esperem todas terem chegado na barreira para liberar a impress\u00e3o de qualquer printf(\"Depois da barreira\\n\"); . Aten\u00e7\u00e3o! N\u00e3o altere os printf , eles representam uma tarefa a ser executada. Fa\u00e7a a implementa\u00e7\u00e3o da barreira sem alter\u00e1-los, nem adicione novos. Vamos implementar nossa barreira usando a seguinte estrat\u00e9gia: uma vari\u00e1vel compartilhada num_barrier ir\u00e1 contar quantas threads j\u00e1 chegaram e est\u00e3o esperando na barreira. um sem\u00e1foro sem_barrier servir\u00e1 para \"travar\" as threads na barreira. Exercise Dadas as vari\u00e1veis acima, precisar\u00edamos usar um mutex_t ? SIM N\u00c2O Resposta A vari\u00e1vel compartilhada num_barrier precisa ser protegida por um mutex para ser acessada simult\u00e2neamente. Seguiremos o seguinte algoritmo: Quando uma thread chega na barreira ela verifica se \u00e9 a \u00faltima: se n\u00e3o for, ela soma 1 em num_barrier e espera sem_barrier . se se ela for a \u00faltima, ela ir\u00e1 liberar todas as outras usando sem_barrier . Exercise A \u00faltima thread dever\u00e1 executar sem_post quantas vezes em sem_barrier para liberar todas as threads que est\u00e3o esperando? 1 4 N - 1 : Onde N \u00e9 o n\u00famero de threads criadas Resposta Cada sem_post libera exatamente uma thread que estava bloqueada no sem_wait . Como teremos N - 1 bloqueadas, basta 1 thread realizar N - 1 chamadas de sem_post para liberar cada uma das threads bloqueadas. Example Implemente as ideias acima no arquivo barrier.c . Done Acabou? Garanta que seu resultado est\u00e1 na pasta 13-barrier do reposit\u00f3rio de atividades e fa\u00e7a a submiss\u00e3o da tag!","title":"20 - Sem\u00e1foros"},{"location":"aulas/20-semaforos/#20-semaforos","text":"Nas \u00faltimas aulas aprendemos as APIs da biblioteca pthread para criar e esperar a finaliza\u00e7\u00e3o de threads. Tamb\u00e9m aprendemos a passar argumentos e receber de volta valores usando um struct alocado dinamicamente. Usamos mutex quando precisamos criar regi\u00f5es de exclus\u00e3o m\u00fatua onde somente uma thread pode entrar por vez. Esta restri\u00e7\u00e3o \u00e9 muito forte e n\u00e3o contempla outro caso muito comum em programa\u00e7\u00e3o concorrente: sincroniza\u00e7\u00e3o de threads. Ou seja, o objetivo n\u00e3o \u00e9 proteger o acesso a dados compartilhados, mas sim impor restri\u00e7\u00f5es no progresso das threads de maneira que elas estejam sempre em uma situa\u00e7\u00e3o v\u00e1lida. Para isto trabalharemos com sem\u00e1foros , que s\u00e3o um mecanismo de sincroniza\u00e7\u00e3o mais sofisticado e em geral usado para que threads sincronizem seu progresso e possam executar em paralelo . Defini\u00e7\u00e3o : duas tarefas podem ser feitas em paralelo se elas n\u00e3o compartilham absolutamente nenhuma informa\u00e7\u00e3o. elas compartilham informa\u00e7\u00e3o mas possuem mecanismos de sincroniza\u00e7\u00e3o de tal maneira que toda ordem de execu\u00e7\u00e3o poss\u00edvel de suas instru\u00e7\u00f5es resulte no mesmo resultado final. Sem\u00e1foros ajudam a criar programas no segundo caso. Nesta aula iremos olhar o caso mais simples de sincroniza\u00e7\u00e3o: duas threads combinam de s\u00f3 progredirem quando chegarem em um certo ponto do programa.","title":"20 - Sem\u00e1foros"},{"location":"aulas/20-semaforos/#rendez-vous-semaforos-no-papel","text":"A express\u00e3o Rendez-vous significa, literalmente, encontro em franc\u00eas. Ela \u00e9 usada para marcar um hor\u00e1rio para duas ou mais pessoas se encontrarem. No contexto de sincroniza\u00e7\u00e3o de tarefas, ele tamb\u00e9m \u00e9 usado para nomear o problema de sincroniza\u00e7\u00e3o mais simples: duas threads rodando fun\u00e7\u00f5es distintas precisam se sincronizar no meio de suas fun\u00e7\u00f5es. As partes A e B podem ser feitas em qualquer ordem, mas ambas obrigatoriamente devem ocorrer antes de iniciar a execu\u00e7\u00e3o de C e D. Note que C e D tamb\u00e9m podem ser feitas em qualquer ordem. Warning Quando dizemos que duas tarefas podem ser feitas em qualquer ordem n\u00e3o quer dizer que elas possam ser feitas em paralelo! Apenas estamos dizendo que A inteira pode ocorrer antes ou depois de B inteira e os resultados ser\u00e3o os mesmos. Exercise Quais das ordens de execu\u00e7\u00e3o das partes A, B, C e D s\u00e3o v\u00e1lidas, segundo o RDV? A C B D A B C D B D A C Resposta O RDV separa a execu\u00e7\u00e3o de A e B de C e D. Ou seja, A B C D \u00e9 um resultado poss\u00edvel! Exercise Quais das ordens de execu\u00e7\u00e3o das partes A, B, C e D s\u00e3o v\u00e1lidas, segundo o RDV? B A D C A D B C B C A D Resposta O RDV separa a execu\u00e7\u00e3o de A e B de C e D. Ou seja, B A D C \u00e9 um resultado poss\u00edvel! Exercise Quais das ordens de execu\u00e7\u00e3o das partes A, B, C e D s\u00e3o v\u00e1lidas, segundo o RDV? A B D C B D A C B C A D Resposta Vamos listar todos os resultados v\u00e1lidos/poss\u00edvels: ABCD , ABDC , BACD ou BADC . Sempre A ou B antes de C ou D ! Vamos fazer a solu\u00e7\u00e3o do RDV no papel primeiro. Exercise Preencha aqui quantos sem\u00e1foros ser\u00e3o usados, seus nomes e valores iniciais. Resposta Vamos criar dois sem\u00e1foros s1 e s2 , inicializados na main com valor zero. Como as threads recebem apenas um argumento, seria uma boa criar uma struct para passar a refer\u00eancia dos sem\u00e1foros. Exercise Indique onde voc\u00ea usaria seus sem\u00e1foros para resolver o RDV. Resposta O sem\u00e1foro s1 ser\u00e1 \u00fatil para indicar que a thread1 chegou no RDV. J\u00e1 o sem\u00e1foro s2 ser\u00e1 utilizado para indicar que a thread2 chegou no RDV. Assim, utilizaremos os sem\u00e1foros entre os dois printf em cada fun\u00e7\u00e3o das threads.","title":"Rendez-vous (Sem\u00e1foros no Papel)"},{"location":"aulas/20-semaforos/#semaforos-posix","text":"Existem, basicamente, dois tipos de sem\u00e1foros: named semaphores recebem um nome globalmente \u00fanico no sistema operacional e s\u00e3o compartilhados entre processos diferentes e independentes, inclusive que n\u00e3o t\u00eam rela\u00e7\u00e3o de parentesco (como pai-filho). unnamed semaphores n\u00e3o t\u00eam nome, s\u00e3o criados como vari\u00e1veis local ou global e s\u00e3o acessados diretamente pelas threads de um mesmo processo. Como estamos usando threads, estamos interessados em unnamed semaphores . Use a p\u00e1gina sem_overview do manual para responder as perguntas abaixo. Exercise Quais fun\u00e7\u00f5es podemos usar para criar, destruir e operar unnamed semaphore ? Resposta sem_init , sem_destroy , sem_post e sem_wait . Example Implemente (do zero) um programa que cria duas threads e as sincroniza usando RDV . Ambas dever\u00e3o fazer um printf qualquer antes e um depois do ponto de encontro. Use a imagem do come\u00e7o da aula como guia.","title":"Sem\u00e1foros POSIX"},{"location":"aulas/20-semaforos/#barreiras-exercicio-para-entrega","text":"Tip Esta aula cont\u00e9m atividade para entrega! Trabalhe na pasta atv/13-barrier que est\u00e1 no seu reposit\u00f3rio de entregas! Leia o README.md ! Se at\u00e9 aqui foi tranquilo, vamos misturar as duas aulas? Uma barreira \u00e9 a generaliza\u00e7\u00e3o do Rendez-vous, em que N threads rodando o mesmo c\u00f3digo precisam esperar umas pelas outras para continuar. Nesta tarefa, voc\u00ea deve lan\u00e7ar quatro threads e utilizar uma barreira para sincronizar as threads , de modo que elas esperem todas terem chegado na barreira para liberar a impress\u00e3o de qualquer printf(\"Depois da barreira\\n\"); . Aten\u00e7\u00e3o! N\u00e3o altere os printf , eles representam uma tarefa a ser executada. Fa\u00e7a a implementa\u00e7\u00e3o da barreira sem alter\u00e1-los, nem adicione novos. Vamos implementar nossa barreira usando a seguinte estrat\u00e9gia: uma vari\u00e1vel compartilhada num_barrier ir\u00e1 contar quantas threads j\u00e1 chegaram e est\u00e3o esperando na barreira. um sem\u00e1foro sem_barrier servir\u00e1 para \"travar\" as threads na barreira. Exercise Dadas as vari\u00e1veis acima, precisar\u00edamos usar um mutex_t ? SIM N\u00c2O Resposta A vari\u00e1vel compartilhada num_barrier precisa ser protegida por um mutex para ser acessada simult\u00e2neamente. Seguiremos o seguinte algoritmo: Quando uma thread chega na barreira ela verifica se \u00e9 a \u00faltima: se n\u00e3o for, ela soma 1 em num_barrier e espera sem_barrier . se se ela for a \u00faltima, ela ir\u00e1 liberar todas as outras usando sem_barrier . Exercise A \u00faltima thread dever\u00e1 executar sem_post quantas vezes em sem_barrier para liberar todas as threads que est\u00e3o esperando? 1 4 N - 1 : Onde N \u00e9 o n\u00famero de threads criadas Resposta Cada sem_post libera exatamente uma thread que estava bloqueada no sem_wait . Como teremos N - 1 bloqueadas, basta 1 thread realizar N - 1 chamadas de sem_post para liberar cada uma das threads bloqueadas. Example Implemente as ideias acima no arquivo barrier.c . Done Acabou? Garanta que seu resultado est\u00e1 na pasta 13-barrier do reposit\u00f3rio de atividades e fa\u00e7a a submiss\u00e3o da tag!","title":"Barreiras - Exerc\u00edcio para Entrega"},{"location":"aulas/21-semaforos-II/","text":"21 - Sem\u00e1foros II e Modelos de concorr\u00eancia \u00b6 Na aula anterior, trabalhamos com sem\u00e1foros de um ponto de vista principalmente conceitual. Aproveitaremos a aula de hoje para fixar nosso conhecimento sobre sem\u00e1foros, verificando como implementar sem\u00e1foros POSIX. Al\u00e9m disso, iremos explorar o modelo produtor consumidor. Corre\u00e7\u00e3o Rendez-vous POSIX \u00b6 Implemente (do zero) um programa que cria duas threads e as sincroniza usando RDV . Ambas dever\u00e3o fazer um print antes e um depois do ponto de encontro. Use o seguinte esquema como guia. As partes A e B podem ser feitas em qualquer ordem, mas ambas obrigatoriamente devem ocorrer antes de iniciar a execu\u00e7\u00e3o de C e D. Note que C e D tamb\u00e9m podem ser feitas em qualquer ordem. Gabarito #include <stdlib.h> #include <stdio.h> #include <pthread.h> #include <semaphore.h> typedef struct { sem_t * s1 , * s2 ; } t_arg ; void * thread1 ( void * _arg ) { t_arg * arg = _arg ; printf ( \"A \\n \" ); sem_post ( arg -> s1 ); // thread1 avisa que chegou na barreira sem_wait ( arg -> s2 ); // Pergunta se a outra thread chegou na barreira printf ( \"C \\n \" ); return NULL ; } void * thread2 ( void * _arg ) { t_arg * arg = _arg ; printf ( \"B \\n \" ); sem_post ( arg -> s2 ); // thread2 avisa que chegou na barreira sem_wait ( arg -> s1 ); // Pergunta se a outra thread chegou na barreira printf ( \"D \\n \" ); return NULL ; } int main ( int argc , char * argv []) { pthread_t * tid = malloc ( sizeof ( pthread_t ) * 2 ); t_arg * arg = malloc ( sizeof ( t_arg )); sem_t * s1 = malloc ( sizeof ( sem_t )); sem_t * s2 = malloc ( sizeof ( sem_t )); sem_init ( s1 , 0 , 0 ); sem_init ( s2 , 0 , 0 ); arg -> s1 = s1 ; arg -> s2 = s2 ; pthread_create ( & tid [ 0 ], NULL , thread1 , arg ); pthread_create ( & tid [ 1 ], NULL , thread2 , arg ); pthread_join ( tid [ 0 ], NULL ); pthread_join ( tid [ 1 ], NULL ); sem_destroy ( s1 ); sem_destroy ( s2 ); free ( tid ); free ( s1 ); free ( s2 ); free ( arg ); return 0 ; } Exercise Os sem\u00e1foros poderiam ser inicializados com 1 ? Resposta N\u00e3o! Qualquer um deles que for inicializado com 1 far\u00e1 com que a thread que espera por ele passe direto na barreira, um resultado indesejado. Recomendo que teste e rode v\u00e1rias vezes! Exercise Dentro das threads, podemos inverter e fazer o sem_wait antes do sem_post ? Exemplo: void * thread1 ( void * _arg ) { t_arg * arg = _arg ; printf ( \"A \\n \" ); sem_wait ( arg -> s2 ); // ALTEROU AQUI sem_post ( arg -> s1 ); // ALTEROU AQUI printf ( \"C \\n \" ); return NULL ; } Resposta Se alterar em apenas uma thread, at\u00e9 ir\u00e1 funcionar. Supondo a altera\u00e7\u00e3o na thread1, o resultado pr\u00e1tico \u00e9 que ter\u00edamos uma ordem fixa, a thread1 sempre esperaria o aviso de que a thread2 chegou na barreira antes de avisar que ela mesmo chegou. Entretanto, se ambas as threads fossem alteradas para ter o sem_wait antes do sem_post ent\u00e3o a thread1 esperaria pelo aviso da thread2, mas a thread2 tamb\u00e9m esperaria pelo aviso da thread1. Ent\u00e3o ambas as threads ficariam travadas , em estado de deadlock . Aplica\u00e7\u00e3o de Sem\u00e1foros \u00b6 J\u00e1 vimos o uso de sem\u00e1foros para sincronizar threads, de forma que as threads esperem pelas outras em um ponto de encontro. Agora, vamos utilizar sem\u00e1foros para controlar a quantidade de threads que podem acessar ao mesmo tempo um recurso computacional. Example Implemente (do zero) um programa que cria N threads, entretanto, apenas MAX threads podem executar ao mesmo tempo. Sua thread pode fazer um procedimento qualquer, por exemplo, um loop infinito que simula um processamento de dados! Tip Tente pensar no que acontece com sem_wait e sem_post quando o sem\u00e1foro \u00e9 inicializado com valor maior que zero. Gabarito #include <stdio.h> #include <stdlib.h> #include <pthread.h> #include <semaphore.h> #include <unistd.h> #define N 10 #define MAX 2 typedef struct { sem_t * sem ; } arg_thread_t ; void * faz_algo ( void * arg_ ) { arg_thread_t * arg = arg_ ; // Wait no sem\u00e1foro: solicita permiss\u00e3o para executar sem_wait ( arg -> sem ); printf ( \"Thread executando! \\n \" ); // simula tarefa while ( random () > 100 ); printf ( \"Thread vai finalizar! \\n \" ); // Post no sem\u00e1foro: avisa que terminou de executar sem_post ( arg -> sem ); return NULL ; } int main () { // Configura sem\u00e1foro sem_t semaph ; // Inicializa sem\u00e1foro com o n\u00famero m\u00e1ximo de threads executando simultaneamente sem_init ( & semaph , 0 , MAX ); // Configura argumentos arg_thread_t * arg = malloc ( sizeof ( arg_thread_t )); arg -> sem = & semaph ; pthread_t * tid = malloc ( sizeof ( pthread_t ) * N ); // Cria todas as threads (o sem\u00e1foro ir\u00e1 controlar a execu\u00e7\u00e3o) for ( int i = 0 ; i < N ; i ++ ){ pthread_create ( & tid [ i ], NULL , faz_algo , arg ); } // espere pelas threads for ( int i = 0 ; i < N ; i ++ ){ pthread_join ( tid [ i ], NULL ); } sem_destroy ( & semaph ); free ( tid ); free ( arg ); return 0 ; } Modelos de concorr\u00eancia \u00b6 Vamos implementar o modelo produtor consumidor , levando em considera\u00e7\u00e3o que: As threads produtoras e consumidoras compartilham um cache \u00fanico. Pode ser um array de inteiros. Ambas as threads rodam em loop infinito simulando um stream de dados. A cada itera\u00e7\u00e3o, as threads sorteiam um valor aleat\u00f3rio de segundos (por ex, entre 0 e 5 ) e ent\u00e3o tentam pruduzir / consumir os dados. Fa\u00e7a! Implemente (do zero) um programa que cria uma thread produtora e uma thread consumidora. Voc\u00ea pode supor que a thread produtora adiciona n\u00fameros na fila de tarefas, enquanto a thread consumidora espera por um segundo ou dois (para simular processamento) e ent\u00e3o exibe o n\u00famero consumido na sa\u00edda padr\u00e3o. Exercise Como os \u00edndices do cache ser\u00e3o manipulados pelas threads produtora e consumidora?! Qual tipo de dados \u00e9 indicado? Resposta Procure por fila circular, buffer circular! Exercise Como podemos controlar para que a thread produtora espere caso o buffer esteja cheio? Resposta Podemos utilizar um sem\u00e1foro inicializado com o tamanho no buffer. Cada produ\u00e7\u00e3o realiza um wait neste sem\u00e1foro. Quando o sem\u00e1foro zera ent\u00e3o o cache est\u00e1 cheio e a thread produtora deve esperar. Tente pensar se o consumo deve ou n\u00e3o atualizar este sem\u00e1foro! Exercise Como podemos controlar para que a thread consumidora espere caso o buffer esteja vazio? Resposta Podemos utilizar um sem\u00e1foro inicializado com zero. Quando a thread produtora produz algo, este sem\u00e1foro recebe um post. Tente pensar se o consumo deve ou n\u00e3o atualizar este sem\u00e1foro! Example Implemente uma vers\u00e3o com M threads produtoras e N threads consumidoras.","title":"21 - Sem\u00e1foros II e Modelos de concorr\u00eancia"},{"location":"aulas/21-semaforos-II/#21-semaforos-ii-e-modelos-de-concorrencia","text":"Na aula anterior, trabalhamos com sem\u00e1foros de um ponto de vista principalmente conceitual. Aproveitaremos a aula de hoje para fixar nosso conhecimento sobre sem\u00e1foros, verificando como implementar sem\u00e1foros POSIX. Al\u00e9m disso, iremos explorar o modelo produtor consumidor.","title":"21 - Sem\u00e1foros II e Modelos de concorr\u00eancia"},{"location":"aulas/21-semaforos-II/#correcao-rendez-vous-posix","text":"Implemente (do zero) um programa que cria duas threads e as sincroniza usando RDV . Ambas dever\u00e3o fazer um print antes e um depois do ponto de encontro. Use o seguinte esquema como guia. As partes A e B podem ser feitas em qualquer ordem, mas ambas obrigatoriamente devem ocorrer antes de iniciar a execu\u00e7\u00e3o de C e D. Note que C e D tamb\u00e9m podem ser feitas em qualquer ordem. Gabarito #include <stdlib.h> #include <stdio.h> #include <pthread.h> #include <semaphore.h> typedef struct { sem_t * s1 , * s2 ; } t_arg ; void * thread1 ( void * _arg ) { t_arg * arg = _arg ; printf ( \"A \\n \" ); sem_post ( arg -> s1 ); // thread1 avisa que chegou na barreira sem_wait ( arg -> s2 ); // Pergunta se a outra thread chegou na barreira printf ( \"C \\n \" ); return NULL ; } void * thread2 ( void * _arg ) { t_arg * arg = _arg ; printf ( \"B \\n \" ); sem_post ( arg -> s2 ); // thread2 avisa que chegou na barreira sem_wait ( arg -> s1 ); // Pergunta se a outra thread chegou na barreira printf ( \"D \\n \" ); return NULL ; } int main ( int argc , char * argv []) { pthread_t * tid = malloc ( sizeof ( pthread_t ) * 2 ); t_arg * arg = malloc ( sizeof ( t_arg )); sem_t * s1 = malloc ( sizeof ( sem_t )); sem_t * s2 = malloc ( sizeof ( sem_t )); sem_init ( s1 , 0 , 0 ); sem_init ( s2 , 0 , 0 ); arg -> s1 = s1 ; arg -> s2 = s2 ; pthread_create ( & tid [ 0 ], NULL , thread1 , arg ); pthread_create ( & tid [ 1 ], NULL , thread2 , arg ); pthread_join ( tid [ 0 ], NULL ); pthread_join ( tid [ 1 ], NULL ); sem_destroy ( s1 ); sem_destroy ( s2 ); free ( tid ); free ( s1 ); free ( s2 ); free ( arg ); return 0 ; } Exercise Os sem\u00e1foros poderiam ser inicializados com 1 ? Resposta N\u00e3o! Qualquer um deles que for inicializado com 1 far\u00e1 com que a thread que espera por ele passe direto na barreira, um resultado indesejado. Recomendo que teste e rode v\u00e1rias vezes! Exercise Dentro das threads, podemos inverter e fazer o sem_wait antes do sem_post ? Exemplo: void * thread1 ( void * _arg ) { t_arg * arg = _arg ; printf ( \"A \\n \" ); sem_wait ( arg -> s2 ); // ALTEROU AQUI sem_post ( arg -> s1 ); // ALTEROU AQUI printf ( \"C \\n \" ); return NULL ; } Resposta Se alterar em apenas uma thread, at\u00e9 ir\u00e1 funcionar. Supondo a altera\u00e7\u00e3o na thread1, o resultado pr\u00e1tico \u00e9 que ter\u00edamos uma ordem fixa, a thread1 sempre esperaria o aviso de que a thread2 chegou na barreira antes de avisar que ela mesmo chegou. Entretanto, se ambas as threads fossem alteradas para ter o sem_wait antes do sem_post ent\u00e3o a thread1 esperaria pelo aviso da thread2, mas a thread2 tamb\u00e9m esperaria pelo aviso da thread1. Ent\u00e3o ambas as threads ficariam travadas , em estado de deadlock .","title":"Corre\u00e7\u00e3o Rendez-vous POSIX"},{"location":"aulas/21-semaforos-II/#aplicacao-de-semaforos","text":"J\u00e1 vimos o uso de sem\u00e1foros para sincronizar threads, de forma que as threads esperem pelas outras em um ponto de encontro. Agora, vamos utilizar sem\u00e1foros para controlar a quantidade de threads que podem acessar ao mesmo tempo um recurso computacional. Example Implemente (do zero) um programa que cria N threads, entretanto, apenas MAX threads podem executar ao mesmo tempo. Sua thread pode fazer um procedimento qualquer, por exemplo, um loop infinito que simula um processamento de dados! Tip Tente pensar no que acontece com sem_wait e sem_post quando o sem\u00e1foro \u00e9 inicializado com valor maior que zero. Gabarito #include <stdio.h> #include <stdlib.h> #include <pthread.h> #include <semaphore.h> #include <unistd.h> #define N 10 #define MAX 2 typedef struct { sem_t * sem ; } arg_thread_t ; void * faz_algo ( void * arg_ ) { arg_thread_t * arg = arg_ ; // Wait no sem\u00e1foro: solicita permiss\u00e3o para executar sem_wait ( arg -> sem ); printf ( \"Thread executando! \\n \" ); // simula tarefa while ( random () > 100 ); printf ( \"Thread vai finalizar! \\n \" ); // Post no sem\u00e1foro: avisa que terminou de executar sem_post ( arg -> sem ); return NULL ; } int main () { // Configura sem\u00e1foro sem_t semaph ; // Inicializa sem\u00e1foro com o n\u00famero m\u00e1ximo de threads executando simultaneamente sem_init ( & semaph , 0 , MAX ); // Configura argumentos arg_thread_t * arg = malloc ( sizeof ( arg_thread_t )); arg -> sem = & semaph ; pthread_t * tid = malloc ( sizeof ( pthread_t ) * N ); // Cria todas as threads (o sem\u00e1foro ir\u00e1 controlar a execu\u00e7\u00e3o) for ( int i = 0 ; i < N ; i ++ ){ pthread_create ( & tid [ i ], NULL , faz_algo , arg ); } // espere pelas threads for ( int i = 0 ; i < N ; i ++ ){ pthread_join ( tid [ i ], NULL ); } sem_destroy ( & semaph ); free ( tid ); free ( arg ); return 0 ; }","title":"Aplica\u00e7\u00e3o de Sem\u00e1foros"},{"location":"aulas/21-semaforos-II/#modelos-de-concorrencia","text":"Vamos implementar o modelo produtor consumidor , levando em considera\u00e7\u00e3o que: As threads produtoras e consumidoras compartilham um cache \u00fanico. Pode ser um array de inteiros. Ambas as threads rodam em loop infinito simulando um stream de dados. A cada itera\u00e7\u00e3o, as threads sorteiam um valor aleat\u00f3rio de segundos (por ex, entre 0 e 5 ) e ent\u00e3o tentam pruduzir / consumir os dados. Fa\u00e7a! Implemente (do zero) um programa que cria uma thread produtora e uma thread consumidora. Voc\u00ea pode supor que a thread produtora adiciona n\u00fameros na fila de tarefas, enquanto a thread consumidora espera por um segundo ou dois (para simular processamento) e ent\u00e3o exibe o n\u00famero consumido na sa\u00edda padr\u00e3o. Exercise Como os \u00edndices do cache ser\u00e3o manipulados pelas threads produtora e consumidora?! Qual tipo de dados \u00e9 indicado? Resposta Procure por fila circular, buffer circular! Exercise Como podemos controlar para que a thread produtora espere caso o buffer esteja cheio? Resposta Podemos utilizar um sem\u00e1foro inicializado com o tamanho no buffer. Cada produ\u00e7\u00e3o realiza um wait neste sem\u00e1foro. Quando o sem\u00e1foro zera ent\u00e3o o cache est\u00e1 cheio e a thread produtora deve esperar. Tente pensar se o consumo deve ou n\u00e3o atualizar este sem\u00e1foro! Exercise Como podemos controlar para que a thread consumidora espere caso o buffer esteja vazio? Resposta Podemos utilizar um sem\u00e1foro inicializado com zero. Quando a thread produtora produz algo, este sem\u00e1foro recebe um post. Tente pensar se o consumo deve ou n\u00e3o atualizar este sem\u00e1foro! Example Implemente uma vers\u00e3o com M threads produtoras e N threads consumidoras.","title":"Modelos de concorr\u00eancia"},{"location":"aulas/22-questoes-de-revisao/","text":"22 - Quest\u00f5es de revis\u00e3o \u00b6 Parte 1 \u00b6 Com base no c\u00f3digo em parte1.c , responda. Exercise Quantos processos s\u00e3o criados pela execu\u00e7\u00e3o do programa? Answer Contando com o processo original, ser\u00e3o criados quatro processos ao todo! Exercise Cada processo executa dois printf: \"f1 %d ....\" e \"fim %d\\n\" . Encontre os pares de printf dada a sa\u00edda abaixo. Ou seja, para cada print \"Fim %d\\n\" encontre o print \"f1 %d ... \" correspondente. f1 7525 f2 7526 counter 6 f1 7525 f2 0 counter 2 fim 7526 f1 0 f2 7527 counter 8 f1 0 f2 0 counter 4 fim 7527 fim 7524 fim 7525 Exercise A sa\u00edda abaixo \u00e9 uma poss\u00edvel sa\u00edda do programa acima? Explique por que. Voc\u00ea pode supor que o processo original tem pid 137 f1 138 f2 139 counter 6 f1 138 f2 0 counter 2 fim 137 fim 139 f1 0 f2 140 counter 8 f1 0 f2 0 counter 4 fim 140 fim 138 Warning Neste item voc\u00ea dever\u00e1 explicar por que a sa\u00edda \u00e9 ou n\u00e3o poss\u00edvel e n\u00e3o apontar o que est\u00e1 diferente entre a sa\u00edda mostrada e algum teste que voc\u00ea tenha feito. Parte 2 \u00b6 A figura sincronizacao.svg mostra uma situa\u00e7\u00e3o com 4 threads em que existem depend\u00eancias entre as partes de cada thread. Fa\u00e7a as tarefas abaixo no programa parte2.c . Example Lance as threads no main. Example Use sem\u00e1foros para criar as situa\u00e7\u00f5es de sincroniza\u00e7\u00e3o na figura. Exercise Escreva abaixo os nomes dos sem\u00e1foros utilizados, seu valor inicial e seu significado no programa. Parte 3 \u00b6 Ler um arquivo linha a linha \u00e9 uma opera\u00e7\u00e3o comum em programas e \u00e9 feito de maneira bastante pr\u00e1tica em Python usando a fun\u00e7\u00e3o readlines . Example No arquivo parte3.c implemente a fun\u00e7\u00e3o char *proxima_linha(int fd) que retorna uma string contendo a pr\u00f3xima linha do arquivo apontado por fd . Ao chegar no fim do arquivo a fun\u00e7\u00e3o passa a retornar NULL . Danger neste exerc\u00edcio voc\u00ea n\u00e3o pode usar a fun\u00e7\u00e3o getline . preencha sua fun\u00e7\u00e3o no arquivo esqueleto.c Rubrica 50% o exerc\u00edcio foi feito levando em conta um tamanho m\u00e1ximo de linha 100% linhas de tamanho arbitr\u00e1rio podem ser lidas. Example Fa\u00e7a agora uma fun\u00e7\u00e3o main que usa sua fun\u00e7\u00e3o acima para ler todas as linhas de um arquivo passado como argumento de linha de comando e mostrar somente as que iniciam com uma letra mai\u00fascula. Voc\u00ea n\u00e3o precisa fazer a rubrica \"completa\" para fazer este item. Parte 4 \u00b6 Para completar a revis\u00e3o, desenvolva solu\u00e7\u00f5es para um simulado de prova! Fa\u00e7a o download do arquivo simulado_sishard.zip disponivel no Blackboard da disciplina ( Conte\u00fado->AF-Simulado->Avalia\u00e7\u00e3o Final Simulado ). Desenvolva a prova e aproveite para tirar qualquer d\u00favida com os professores! Aten\u00e7\u00e3o Perceba no simulado de prova que o README.md ou README.html cont\u00e9m todos os detalhes para resolu\u00e7\u00e3o das quest\u00f5es, incluindo crit\u00e9rios de avalia\u00e7\u00e3o .","title":"22 - Quest\u00f5es de revis\u00e3o"},{"location":"aulas/22-questoes-de-revisao/#22-questoes-de-revisao","text":"","title":"22 - Quest\u00f5es de revis\u00e3o"},{"location":"aulas/22-questoes-de-revisao/#parte-1","text":"Com base no c\u00f3digo em parte1.c , responda. Exercise Quantos processos s\u00e3o criados pela execu\u00e7\u00e3o do programa? Answer Contando com o processo original, ser\u00e3o criados quatro processos ao todo! Exercise Cada processo executa dois printf: \"f1 %d ....\" e \"fim %d\\n\" . Encontre os pares de printf dada a sa\u00edda abaixo. Ou seja, para cada print \"Fim %d\\n\" encontre o print \"f1 %d ... \" correspondente. f1 7525 f2 7526 counter 6 f1 7525 f2 0 counter 2 fim 7526 f1 0 f2 7527 counter 8 f1 0 f2 0 counter 4 fim 7527 fim 7524 fim 7525 Exercise A sa\u00edda abaixo \u00e9 uma poss\u00edvel sa\u00edda do programa acima? Explique por que. Voc\u00ea pode supor que o processo original tem pid 137 f1 138 f2 139 counter 6 f1 138 f2 0 counter 2 fim 137 fim 139 f1 0 f2 140 counter 8 f1 0 f2 0 counter 4 fim 140 fim 138 Warning Neste item voc\u00ea dever\u00e1 explicar por que a sa\u00edda \u00e9 ou n\u00e3o poss\u00edvel e n\u00e3o apontar o que est\u00e1 diferente entre a sa\u00edda mostrada e algum teste que voc\u00ea tenha feito.","title":"Parte 1"},{"location":"aulas/22-questoes-de-revisao/#parte-2","text":"A figura sincronizacao.svg mostra uma situa\u00e7\u00e3o com 4 threads em que existem depend\u00eancias entre as partes de cada thread. Fa\u00e7a as tarefas abaixo no programa parte2.c . Example Lance as threads no main. Example Use sem\u00e1foros para criar as situa\u00e7\u00f5es de sincroniza\u00e7\u00e3o na figura. Exercise Escreva abaixo os nomes dos sem\u00e1foros utilizados, seu valor inicial e seu significado no programa.","title":"Parte 2"},{"location":"aulas/22-questoes-de-revisao/#parte-3","text":"Ler um arquivo linha a linha \u00e9 uma opera\u00e7\u00e3o comum em programas e \u00e9 feito de maneira bastante pr\u00e1tica em Python usando a fun\u00e7\u00e3o readlines . Example No arquivo parte3.c implemente a fun\u00e7\u00e3o char *proxima_linha(int fd) que retorna uma string contendo a pr\u00f3xima linha do arquivo apontado por fd . Ao chegar no fim do arquivo a fun\u00e7\u00e3o passa a retornar NULL . Danger neste exerc\u00edcio voc\u00ea n\u00e3o pode usar a fun\u00e7\u00e3o getline . preencha sua fun\u00e7\u00e3o no arquivo esqueleto.c Rubrica 50% o exerc\u00edcio foi feito levando em conta um tamanho m\u00e1ximo de linha 100% linhas de tamanho arbitr\u00e1rio podem ser lidas. Example Fa\u00e7a agora uma fun\u00e7\u00e3o main que usa sua fun\u00e7\u00e3o acima para ler todas as linhas de um arquivo passado como argumento de linha de comando e mostrar somente as que iniciam com uma letra mai\u00fascula. Voc\u00ea n\u00e3o precisa fazer a rubrica \"completa\" para fazer este item.","title":"Parte 3"},{"location":"aulas/22-questoes-de-revisao/#parte-4","text":"Para completar a revis\u00e3o, desenvolva solu\u00e7\u00f5es para um simulado de prova! Fa\u00e7a o download do arquivo simulado_sishard.zip disponivel no Blackboard da disciplina ( Conte\u00fado->AF-Simulado->Avalia\u00e7\u00e3o Final Simulado ). Desenvolva a prova e aproveite para tirar qualquer d\u00favida com os professores! Aten\u00e7\u00e3o Perceba no simulado de prova que o README.md ou README.html cont\u00e9m todos os detalhes para resolu\u00e7\u00e3o das quest\u00f5es, incluindo crit\u00e9rios de avalia\u00e7\u00e3o .","title":"Parte 4"},{"location":"labs/hackerlab/","text":"Hackerlab \u00b6 Introdu\u00e7\u00e3o \u00b6 O prop\u00f3sito desta atividade \u00e9 torn\u00e1-los proficientes na engenharia reversa de execut\u00e1veis . Cada um de voc\u00eas recebeu um execut\u00e1vel app que pede uma s\u00e9rie de senhas para ser desativado. Estas senhas devem ser descobertas atrav\u00e9s da an\u00e1lise do c\u00f3digo Assembly do execut\u00e1vel. Onde trabalhar? \u00b6 O seu execut\u00e1vel app foi deixado no seu reposit\u00f3rio de entregas da disciplina na pasta lab/01-hackerlab . Ao execut\u00e1-lo, confira se o seu nome \u00e9 a primeira sa\u00edda. Em caso negativo, entre em contato com o professor imediatamente. Como trabalhar? \u00b6 Execute o app . Ser\u00e1 apresentado seu nome. Ent\u00e3o, o programa ir\u00e1 esperar uma entrada, que \u00e9 uma senha que destrava o level 1. $ ./app FABIO Level1: Para descrobrir a senha, voc\u00ea ter\u00e1 que abrir o app no gdb e fazer engenharia reversa para entender seu c\u00f3digo. Quando voc\u00ea tiver descoberto uma senha que destrava o n\u00edvel, teste se funciona! Vamos supor que voc\u00ea desconfia que a senha seja lasanha . $ ./app FABIO Level1:lasanha Nao foi desta vez! Como podemos ver, lasanha n\u00e3o \u00e9 uma senha correta para o n\u00edvel 1! Conforme for descobrindo, voc\u00ea dever\u00e1 editar um arquivo solucao.txt contendo as senhas usadas para desativar cada n\u00edvel. Cada senha dever\u00e1 estar em uma linha. O arquivo entregue deve funcionar como entrada para liberar acesso \u00e0 aplica\u00e7\u00e3o! $ ./app < solucao.txt Aten\u00e7\u00e3o! O arquivo deve se chamar solucao.txt , ser editado no Linux e codificado como UTF-8. Como entregar? \u00b6 Para que sua solu\u00e7\u00e3o seja considerada pelo servidor de corre\u00e7\u00e3o, ap\u00f3s subir suas altera\u00e7\u00f5es para o github, fa\u00e7a uma tag com o padr\u00e3o de nomenclatura lab1.x.y , substituindo x e y por qualquer n\u00famero inteiro! Ex: $ git tag -a lab1.0.1 -m \"lab1.0.1\" $ git push origin lab1.0.1 Entregas cont\u00ednuas! N\u00e3o deixe para entregar no \u00faltimo minuto, fa\u00e7a entregas cont\u00ednuas conforme for evoluindo nos n\u00edveis! Al\u00e9m disso, comece logo . O lab foi pensado para ser feito conforme os conte\u00fados s\u00e3o apresentados. Certamente ter\u00e1 dificuldades se deixar para os \u00faltimos dias! Como serei avaliado? \u00b6 S\u00e3o dez n\u00edveis e cada um vale 1,0 de nota. Sua solu\u00e7\u00e3o conseguir\u00e1 ficar com status pass apenas quando conseguir passar em todos os n\u00edveis, entretanto, mesmo com fail a nota parcial ser\u00e1 considerada. Qual o prazo? \u00b6 Veja mais em https://insper.github.io/SistemasHardwareSoftware/sobre/","title":"Hackerlab"},{"location":"labs/hackerlab/#hackerlab","text":"","title":"Hackerlab"},{"location":"labs/hackerlab/#introducao","text":"O prop\u00f3sito desta atividade \u00e9 torn\u00e1-los proficientes na engenharia reversa de execut\u00e1veis . Cada um de voc\u00eas recebeu um execut\u00e1vel app que pede uma s\u00e9rie de senhas para ser desativado. Estas senhas devem ser descobertas atrav\u00e9s da an\u00e1lise do c\u00f3digo Assembly do execut\u00e1vel.","title":"Introdu\u00e7\u00e3o"},{"location":"labs/hackerlab/#onde-trabalhar","text":"O seu execut\u00e1vel app foi deixado no seu reposit\u00f3rio de entregas da disciplina na pasta lab/01-hackerlab . Ao execut\u00e1-lo, confira se o seu nome \u00e9 a primeira sa\u00edda. Em caso negativo, entre em contato com o professor imediatamente.","title":"Onde trabalhar?"},{"location":"labs/hackerlab/#como-trabalhar","text":"Execute o app . Ser\u00e1 apresentado seu nome. Ent\u00e3o, o programa ir\u00e1 esperar uma entrada, que \u00e9 uma senha que destrava o level 1. $ ./app FABIO Level1: Para descrobrir a senha, voc\u00ea ter\u00e1 que abrir o app no gdb e fazer engenharia reversa para entender seu c\u00f3digo. Quando voc\u00ea tiver descoberto uma senha que destrava o n\u00edvel, teste se funciona! Vamos supor que voc\u00ea desconfia que a senha seja lasanha . $ ./app FABIO Level1:lasanha Nao foi desta vez! Como podemos ver, lasanha n\u00e3o \u00e9 uma senha correta para o n\u00edvel 1! Conforme for descobrindo, voc\u00ea dever\u00e1 editar um arquivo solucao.txt contendo as senhas usadas para desativar cada n\u00edvel. Cada senha dever\u00e1 estar em uma linha. O arquivo entregue deve funcionar como entrada para liberar acesso \u00e0 aplica\u00e7\u00e3o! $ ./app < solucao.txt Aten\u00e7\u00e3o! O arquivo deve se chamar solucao.txt , ser editado no Linux e codificado como UTF-8.","title":"Como trabalhar?"},{"location":"labs/hackerlab/#como-entregar","text":"Para que sua solu\u00e7\u00e3o seja considerada pelo servidor de corre\u00e7\u00e3o, ap\u00f3s subir suas altera\u00e7\u00f5es para o github, fa\u00e7a uma tag com o padr\u00e3o de nomenclatura lab1.x.y , substituindo x e y por qualquer n\u00famero inteiro! Ex: $ git tag -a lab1.0.1 -m \"lab1.0.1\" $ git push origin lab1.0.1 Entregas cont\u00ednuas! N\u00e3o deixe para entregar no \u00faltimo minuto, fa\u00e7a entregas cont\u00ednuas conforme for evoluindo nos n\u00edveis! Al\u00e9m disso, comece logo . O lab foi pensado para ser feito conforme os conte\u00fados s\u00e3o apresentados. Certamente ter\u00e1 dificuldades se deixar para os \u00faltimos dias!","title":"Como entregar?"},{"location":"labs/hackerlab/#como-serei-avaliado","text":"S\u00e3o dez n\u00edveis e cada um vale 1,0 de nota. Sua solu\u00e7\u00e3o conseguir\u00e1 ficar com status pass apenas quando conseguir passar em todos os n\u00edveis, entretanto, mesmo com fail a nota parcial ser\u00e1 considerada.","title":"Como serei avaliado?"},{"location":"labs/hackerlab/#qual-o-prazo","text":"Veja mais em https://insper.github.io/SistemasHardwareSoftware/sobre/","title":"Qual o prazo?"},{"location":"labs/processos/","text":"Lab de Processos \u00b6 Neste laborat\u00f3rio, voc\u00ea implementar\u00e1 um shell Unix simples (como tantos outros que existem, bash , csh etc.) chamado inspersh . A fun\u00e7\u00e3o b\u00e1sica de um shell \u00e9 aceitar comandos como entradas na linha de comando e executar os programas correspondentes em resposta. O prop\u00f3sito deste laborat\u00f3rio \u00e9 ajudar voc\u00ea a aprender os fundamentos das chamadas de sistema para criar e gerenciar processos conforme voc\u00ea implementa seu programa. Voc\u00ea escrever\u00e1 o c\u00f3digo para seu programa shell no arquivo inspersh.c , que estar\u00e1 em branco sem nenhuma fun\u00e7\u00e3o, isto desafiar\u00e1 suas habilidades de desenvolvedor, pois ter\u00e1 que aprender a usar diversas fun\u00e7\u00f5es das bibliotecas da linguagem C, uma sugest\u00e3o \u00e9 que para cada fun\u00e7\u00e3o que for utilizar, teste o seu funcionamento (entrada e sa\u00edda) em um programa separado para depois utilizar na implementa\u00e7\u00e3o do inspersh.c , e lembre-se, \u00e9 muito importante que voc\u00ea leia com aten\u00e7\u00e3o as especifica\u00e7\u00f5es das fun\u00e7\u00f5es no manual da fun\u00e7\u00e3o, para isso voc\u00ea pode usar o comando man no terminal. A seguir seguem algumas boas boas pr\u00e1ticas de programa\u00e7\u00e3o que poder\u00e3o lhe ajudar: Planeje a totalidade da sua tarefa : Crie um esqueleto de como todo o seu c\u00f3digo ficar\u00e1. Isso evitar\u00e1 que voc\u00ea precise reestruturar todo o seu c\u00f3digo para adicionar um \u00fanico recurso novo; Estruture seu c\u00f3digo em fun\u00e7\u00f5es modulares : Voc\u00ea n\u00e3o quer depurar um while de 1500 linhas dentro de main ; Trabalhe incrementalmente : Implemente um recurso, teste, depure, siga em frente; e Fa\u00e7a o c\u00f3digo leg\u00edvel : Uma boa nomenclatura e espa\u00e7amento tornar\u00e3o seu c\u00f3digo muito mais leg\u00edvel. Iniciando seu shell \u00b6 O shell de ser iniciado a partir do diret\u00f3rio onde foi carregado o programa, em seguida deve ficar executando um loop como o trecho abaixo: enquanto comando diferente de exit 1 - Imprima um prompt de comando 2 - Leia o comando da entrada padr\u00e3o 3 - Executa o comando O shell suporta dois tipos de comandos: internos e externos . Os comandos internos s\u00e3o parte do c\u00f3digo do shell e s\u00e3o executados sem criar um novo processo. Os comandos externos devem ser executados por um novo processo, com a chamada das fun\u00e7\u00f5es fork/execvp/waitpid . Para identificar um comando externo , considere que se o comando n\u00e3o for um dos comandos internos listados a seguir, ele \u00e9 um comando externo . Os argumentos de comando ser\u00e3o separados por espa\u00e7os em branco, n\u00e3o se preocupe com espa\u00e7amento irregular em entradas de comando (ou seja, espa\u00e7o em branco extra antes e depois de cada token ). Isso \u00e9 considerado comportamento indefinido e n\u00e3o ser\u00e1 testado. Voc\u00ea \u00e9 livre para tornar seu c\u00f3digo t\u00e3o robusto quanto quiser, mas testaremos apenas os casos b\u00e1sicos com um espa\u00e7o entre os tokens . Avalia\u00e7\u00e3o \u00b6 O inspersh ser\u00e1 avaliado de forma manual usando uma rubrica que descreve as funcionalidades implementadas. Quanto maior o n\u00famero de funcionalidades maior ser\u00e1 a nota. FASE 0 \u00b6 O programa inspersh.c n\u00e3o compila ou compila com warnings . N\u00e3o preencheu o arquivo README.md N\u00e3o entregou o v\u00eddeo explicativo; O programa n\u00e3o implementa algum dos requisitos da rubrica da fase 1 . NOTA desta fase: 0.0 \u00b6 FASE 1: \u00b6 Video explicativo com \u00e1udio e a tela de vis\u00edvel com a execu\u00e7\u00e3o da implamenta\u00e7\u00e3o, comentando as informa\u00e7\u00f5es colocadas no arquivo README.md . Preencheu o arquivo README.md com as seguintes informa\u00e7\u00f5es: Seu nome e uma descri\u00e7\u00e3o de qual fase do laborat\u00f3rio voc\u00ea conseguiu completar; Relate tamb\u00e9m quaisquer bugs ou erros identificados no seu shell ;e Alguma decis\u00e3o de design interessante que voc\u00ea gostaria de compartilhar. O programa inspersh.c compila sem warnings . Para compilar use: gcc inspersh.c -Wall -Wno-unused-result -g -Og -o inspersh O programa printa o prompt do shell , a partir do diret\u00f3rio onde foi carregado o programa no formato (pid=<pid>)<path>$ , como por exemplo: ( pid = 1234 ) /home/lab02$ Sendo que o <pid> \u00e9 o ID do processo atual e <path> \u00e9 o caminho completo para o diret\u00f3rio de trabalho atual. O programa l\u00ea e interpreta uma linha com o comando que ser\u00e1 executado, pela entrada padr\u00e3o ( stdin ), para isso ser\u00e1 necess\u00e1rio dividir a entrada com base nos espa\u00e7os. Um token \u00e9 qualquer sequ\u1ebdncia de caracteres delimitado pelo in\u00edcio e fim da linha, ou por espa\u00e7os. O primeiro token \u00e9 considerado o comando , e todos os tokens seguintes s\u00e3o referidos como argumentos . Implmenta os comandos internos : exit : encerra o inspersh elibera todos os recursos. cd <dir> : o diretorio atual \u00e9 alterado para o diret\u00f3rio informado <dir> . Se o diret\u00f3rio informado come\u00e7ar com / o diretorio deve ser atualizado a partir da raiz do sistema de arquivo, caso contr\u00e1rio deve ser atualizado em rela\u00e7\u00e3o ao diret\u00f3rio atual. Caso o argumento <dir> n\u00e3o seja informado o shell deve regressar ao diret\u00f3rio inicial onde foi carregado o programa. Se por algum motivo <dir> n\u00e3o for um diret\u00f3rio v\u00e1lido, o inspersh dever\u00e1 manter seu diret\u00f3rio de trabalho atual e dever\u00e1 imprimir: dir: diretorio nao existe. , al\u00e9m disso n\u00e3o \u00e9 necess\u00e1rio tratar o comando cd .. , veja abaixo um trecho de execu\u00e7\u00e3o do comando cd : ( pid = 1234 ) /home/lab02$ cd testes ( pid = 1234 ) /home/lab02/testes$ cd dir_imaginario dir_imaginario: diretorio nao existe. ( pid = 1234 ) /home/lab02/testes$ cd teste2 ( pid = 1234 ) /home/lab02/testes/teste2$ cd ( pid = 1234 ) /home/lab02$ ls : lista conte\u00fado de um diret\u00f3rio (arquivos e outros diret\u00f3rios), informando se um elemento \u00e9 um diret\u00f3rio ou arquivo. Se for um arquivo deve ser impresso o tamanho do arquivo em bytes , e por fim o nome do elemento no sistema de arquivos, ignorem os arquivos e diret\u00f3rios que comecem com caractere . (ponto), este n\u00e3o deve ser listado, abaixo um exemplo da execu\u00e7\u00e3o do comando ls : ( pid = 1234 ) /home/lab02$ ls d - - um_diretorio a - 7566 - inspersh.c a - 16526 - processos.md a - 19064 - processo.html a - 332496 - inspersh d - - testes ( pid = 1234 ) /home/lab02$ N\u00e3o se preocupe aqui com a ordem em que aparecem os elementos que est\u00e3o no diret\u00f3rio, o importante \u00e9 informar corretamente as informa\u00e7oes dos elementos. Dica de implementa\u00e7\u00e3o : leia atentamente os manuais ( man ) das fun\u00e7\u00f5es a seguir, elas poder\u00e3o lhe ajudar a atender os requisitos dessa fase. getpid , getcwd , fgets , chdir , opendir , readdir , closedir e stat ( man 2 stat )- NOTA at\u00e9 essa fase: 3.0 \u00b6 FASE 2 \u00b6 Programa inspersh.c roda sem erros no valgrind . Para testar o seu program use: valgrind --leak-check=yes ./inspersh Implementa os comandos externos : se o comando n\u00e3o for um comando interno do inspersh.c (ou seja, qualquer comando diferente de cd , ls , exit ), o inspersh deve considerar o nome do comando como o nome de um arquivo execut\u00e1vel, como por exemplos os comandos: cat, top, pwd, ps, /usr/bin/ls -l, echo hello, sleep 5, lscpu, ... O c\u00f3digo desses comandos deve ser executado em um processo diferente daquele que executa o inspersh.c , para tanto voc\u00ea deve usar fork() , execvp() e waitpid() . Caso tenha sucesso na execu\u00e7\u00e3o do comando externo deve ser impressa a seguinte mensagem: (pid=<pid>):comando externo [<cmd>] executado com sucesso. , se o comando externo falhar no momento da chamada do execvp o inspersh deve enviar uma mensagem apropriadas, como por exemplo: (pid=<pid>):falha na execucao do comando externo [<cmd>] . Considere que <pid> \u00e9 o valor do pid do execut\u00e1vel e <cmd> \u00e9 o nome do comando. Veja um exemplo de execu\u00e7\u00e3o dos comandos externos: ( pid = 1234 ) /home/lab02$ sleep 5 ( pid = 4321 ) :comando externo [ sleep ] executado com sucesso. ( pid = 1234 ) /home/lab02$ SLEEP 5 ( pid = 4322 ) :falha na execu\u00e7\u00e3o do comando externo [ SLEEP ] . ( pid = 1234 ) /home/lab02$ echo Ola mundo !! Ola Mundo !! ( pid = 4327 ) :comando externo [ echo ] executado com sucesso. ( pid = 1234 ) /home/lab02$ pwd /home/lab02 ( pid = 4327 ) :comando externo [ pwd ] executado com sucesso. ( pid = 1234 ) /home/lab02$ IMPORTANTE : N\u00e3o \u00e9 permitido o uso da fun\u00e7\u00e3o system() nesse lab, caso use ser\u00e1 atribu\u00eddo a nota da FASE 0 . Programa captura Ctrl+C : geralmente quando pressionamos Ctrl+C , o programa em execu\u00e7\u00e3o no primeiro plano \u00e9 finalizado, no entanto, o inspersh.c deve verificar se h\u00e1 outro programa em primeiro plano em execu\u00e7\u00e3o no momento e, se houver, ele deve finalizar esse processo usando o sinal SIGINT , e apresentar uma mensagem apropriado como (pid=<pid>):comando externo [<cmd>] finalizado com Ctrl+C. , caso contr\u00e1rio o inspersh.c ignora o Ctrl+C . ( pid = 1234 ) /home/lab02$ sleep 5 ^C ( pid = 4323 ) :comando externo [ sleep ] finalizado com Ctrl+C. ( pid = 1234 ) /home/lab02$ + Dica de implementa\u00e7\u00e3o : para aguardar os comandos externos finalizados com Ctrl+C utilize a fun\u00e7\u00e3o waitpid() com argumento n\u00e3o bloqueante, para tanto leia atentamente o manual dessa fun\u00e7\u00e3o ( man waitpid ). NOTA at\u00e9 essa fase: 5.0 \u00b6 FASE 3 \u00b6 Nessa fase o seu shell deve suportar o armazenamento do hist\u00f3rico de comandos executados, por conta disso o execut\u00e1vel inspersh dever\u00e1 ser inicializado da seguinte forma: $./inspersh <arquivo_historico> Se o arquivo n\u00e3o existir, voc\u00ea deve trat\u00e1-lo como um arquivo vazio, o formato do arquivo de hist\u00f3rico deve ser uma lista comandos executados. Ao sair, o inspersh deve anexar os comandos da sess\u00e3o atual no arquivo de hist\u00f3rico fornecido, no mesmo arquivo informado no in\u00edcio da execu\u00e7\u00e3o do shell . Exemplo do arquivo historico.txt : cd testes echo Ola Mundo! Considere o inspersh executando carregando o arquivo historico.txt : $./inspersh historico.txt ( pid = 1234 ) /home/lab02$ cd dir_imaginario dir_imaginario: diret\u00f3rio nao existe. ( pid = 1234 ) /home/lab02$ exit Exemplo como ficaria o arquivo de historico.txt ap\u00f3s a execu\u00e7\u00e3o do inspersh : cd testes echo Ola Mundo! cd dir_imaginario Note que comando tanto os comandos executados com sucesso e com falha s\u00e3o armazenados no hist\u00f3rico, e o comando exit n\u00e3o \u00e9 armazenado no arquivo de hist\u00f3rico. Implementa comandos para acessar o hist\u00f3rico do shell a partir do prompt do inspersh : ! : Imprime para cada comando (em ordem cronol\u00f3gica) seu n\u00famero de linha (indexado a partir do 0 ), uma tabula\u00e7\u00e3o, o comando em si e uma nova linha, e \u00e9 claro, o comando ! n\u00e3o \u00e9 armazenado no hist\u00f3rico. ( pid = 1234 ) /home/lab02$ ! 0 cd testes 1 echo Ola Mundo! 2 cd dir_imaginario ( pid = 1234 ) /home/lab02$ !# : Reexecuta o #\u00e9simo comando no hist\u00f3rico e armazena a nova execu\u00e7\u00e3o do comando no hist\u00f3rico, antes de executar o #\u00e9simo comando de ser impresso na tela. Se # n\u00e3o for um \u00edndice v\u00e1lido, imprima indice invalido (essa mensagem n\u00e3o deve ser armazenado no hist\u00f3rico). E por fim o comando !# n\u00e3o \u00e9 armazenado no hist\u00f3rico, o exemplo abaixo assume que o hist\u00f3rico est\u00e1 vazio : ( pid = 1234 ) /home/lab02$ echo Echo Algo! Echo Algo! ( pid = 1237 ) :comando externo [ echo ] executado com sucesso. ( pid = 1234 ) /home/lab02$ echo Outro echo Outro echo ( pid = 1239 ) :comando externo [ echo ] executado com sucesso. ( pid = 1234 ) /home/lab02$ ! 0 echo Echo Algo! 1 echo Outro echo ( pid = 1234 ) /home/lab02$ !1 echo Outro echo Outro echo ( pid = 2230 ) :comando externo [ echo ] executado com sucesso. ( pid = 1234 ) /home/lab02$ !4 indice invalido ( pid = 1234 ) /home/lab02$ ! 0 echo Echo Algo! 1 echo Outro echo 2 echo Outro echo ( pid = 1234 ) /home/lab02$ !<prefixo> : Imprime e executa o \u00faltimo comando que tem o prefixo especificado. Se nenhuma correspond\u00eancia for encontrada, imprima a mensagem de erro comando nao encontrado e n\u00e3o armazene nada no hist\u00f3rico. Caso encontre alguma correspond\u00eancia, imprima o comando antes de execut\u00e1-lo. Importante, comando !<prefixo> n\u00e3o \u00e9 armazenado no hist\u00f3rico, mas o comando que est\u00e1 sendo executado (se houver) \u00e9, o exemplo a seguir assume um hist\u00f3rico vazio : ( pid = 1234 ) /home/lab02$ echo Echo Algo! Echo Algo! ( pid = 1237 ) :comando externo [ echo ] executado com sucesso. ( pid = 1234 ) /home/lab02$ echo Outro echo Outro echo ( pid = 1239 ) :comando externo [ echo ] executado com sucesso. ( pid = 1234 ) /home/lab02$ ! 0 echo Echo Algo! 1 echo Outro echo ( pid = 1234 ) /home/lab02$ !echo echo Outro echo Outro echo ( pid = 2230 ) :comando externo [ echo ] executado com sucesso. ( pid = 1234 ) /home/lab02$ !eco comando nao encontrado ( pid = 1234 ) /home/lab02$ ! 0 echo Echo Algo! 1 echo Outro echo 2 echo Outro echo ( pid = 1234 ) /home/lab02$ NOTA at\u00e9 essa fase: 8.0 \u00b6 FASE 4 \u00b6 Nessa fase o comando interno ls deve ser incrementado. Considera a Figura 1 que apresenta uma de \u00e1rvore de diret\u00f3rios e arquivos de um sistema de arquivos. O seu programa inspersh.c deve implementar as seguintes funcionalidades: Figura 1 : Exemplo de \u00e1rvore de diret\u00f3rios e arquivos Implementa o argumento -o para o comando ls , o argumento indica ao comando ao comando ls que conte\u00fado do diretorio corrente deve ser impressa em ordem alfab\u00e9tica, colocando os diret\u00f3rios antes dos arquivos. Considere que o execut\u00e1vel inspersh est\u00e1 na raiz da \u00e1rvore acima, a sa\u00edda para o comando ls -o seria: ./dirA ./dirC ./temp.txt Implementa o argumento -n que percorre, a partir do diret\u00f3rio corrente, toda a \u00e1rvore de diret\u00f3rio por n\u00edvel , considere que o execut\u00e1vel inspersh est\u00e1 na raiz da \u00e1rvore apresentada na Figura 1 , a sa\u00edda para o comando ls -n seria: ./dirA ./dirC ./temp.txt ./dirA/dirB ./dirA/my1.dat ./dirC/my2.dat ./dirC/temp.txt ./dirA/dirB/my3.dat Implementa o argumento -h que faz com que o comando ls percorra toda \u00e1rvore de diret\u00f3rio a partir do diret\u00f3rio corrente explorando o primeiro diret\u00f3rio completamente antes de voltar e explorar o pr\u00f3ximo diret\u00f3rio no mesmo n\u00edvel, repetindo esse processo para cada diret\u00f3rio que ser\u00e1 percorrido. Considere que o execut\u00e1vel inspersh est\u00e1 na raiz da \u00e1rvore apresentada na Figura 1 , a sa\u00edda para o comando ls -h seria: ./dirA ./dirA/dirB ./dirA/dirB/my3.dat ./dirA/my1.dat ./dirC ./dirC/my2.dat ./dirC/temp.txt ./temp.txt NOTA at\u00e9 essa fase: 10.0 \u00b6 IMPORTANTE: Considere as fases como cumulativas , ou seja, cada vers\u00e3o deve manter as funcionalidades da fase anterior e acrescentar novas. Por exemplo, a vers\u00e3o da Fase 2 , al\u00e9m de executar os comandos externos deve continuar os comandos internos implementado na Fase 1 , e assim por diante. Notas de programa\u00e7\u00e3o \u00b6 A linha de comando do seu programa precisa manipular linhas de entrada de at\u00e9 1024 caracteres ; Um comando n\u00e3o ultrapassar\u00e1 8 tokens ; e Em diret\u00f3rio teremos no m\u00e1ximo 128 elementos (diret\u00f3rios e arquivos). Considere que o tamanho m\u00e1ximo de um <path> ser\u00e1 de 1024 caracteres. Restri\u00e7\u00f5es \u00b6 Esta atividade serve como avalia\u00e7\u00e3o dos conceitos vistos na disciplina. Portanto, algumas restri\u00e7\u00f5es ser\u00e3o aplicadas ao c\u00f3digo de voc\u00eas: todo trabalho com arquivos dever\u00e1 ser feito usando as APIs POSIX vistas em aula. N\u00e3o \u00e9 permitido o uso de fun\u00e7\u00f5es da Standard I/O para manipula\u00e7\u00e3o de arquivos, como por exemplo fopen() , fdopen() , fread() , fclose() , entre outras . se voc\u00ea usar algum trecho de c\u00f3digo da documenta\u00e7\u00e3o (ou de outra fonte), coloque uma atribui\u00e7\u00e3o em um coment\u00e1rio no c\u00f3digo. Fica proibido o uso de ferramentas de gera\u00e7\u00e3o de c\u00f3digo autom\u00e1tico por IA , como por exemplo o ChatGPT . O n\u00e3o atendimento dessas restri\u00e7\u00f5es resultar\u00e3o em atribui\u00e7\u00e3o da nota zero para esse lab. Entrega \u00b6 Voc\u00ea dever\u00e1 colocar o programa fonte inspersh.c na pasta lab/02-lab-processos em seu reposit\u00f3rio de atividades (github), na branch principal, e fazer upload (push) do arquivo fonte no seu reposit\u00f3rio , n\u00e3o precisa soltar tag. Lembre-se de se atentar ao prazo de entrega definido aqui! .","title":"Lab de Processos"},{"location":"labs/processos/#lab-de-processos","text":"Neste laborat\u00f3rio, voc\u00ea implementar\u00e1 um shell Unix simples (como tantos outros que existem, bash , csh etc.) chamado inspersh . A fun\u00e7\u00e3o b\u00e1sica de um shell \u00e9 aceitar comandos como entradas na linha de comando e executar os programas correspondentes em resposta. O prop\u00f3sito deste laborat\u00f3rio \u00e9 ajudar voc\u00ea a aprender os fundamentos das chamadas de sistema para criar e gerenciar processos conforme voc\u00ea implementa seu programa. Voc\u00ea escrever\u00e1 o c\u00f3digo para seu programa shell no arquivo inspersh.c , que estar\u00e1 em branco sem nenhuma fun\u00e7\u00e3o, isto desafiar\u00e1 suas habilidades de desenvolvedor, pois ter\u00e1 que aprender a usar diversas fun\u00e7\u00f5es das bibliotecas da linguagem C, uma sugest\u00e3o \u00e9 que para cada fun\u00e7\u00e3o que for utilizar, teste o seu funcionamento (entrada e sa\u00edda) em um programa separado para depois utilizar na implementa\u00e7\u00e3o do inspersh.c , e lembre-se, \u00e9 muito importante que voc\u00ea leia com aten\u00e7\u00e3o as especifica\u00e7\u00f5es das fun\u00e7\u00f5es no manual da fun\u00e7\u00e3o, para isso voc\u00ea pode usar o comando man no terminal. A seguir seguem algumas boas boas pr\u00e1ticas de programa\u00e7\u00e3o que poder\u00e3o lhe ajudar: Planeje a totalidade da sua tarefa : Crie um esqueleto de como todo o seu c\u00f3digo ficar\u00e1. Isso evitar\u00e1 que voc\u00ea precise reestruturar todo o seu c\u00f3digo para adicionar um \u00fanico recurso novo; Estruture seu c\u00f3digo em fun\u00e7\u00f5es modulares : Voc\u00ea n\u00e3o quer depurar um while de 1500 linhas dentro de main ; Trabalhe incrementalmente : Implemente um recurso, teste, depure, siga em frente; e Fa\u00e7a o c\u00f3digo leg\u00edvel : Uma boa nomenclatura e espa\u00e7amento tornar\u00e3o seu c\u00f3digo muito mais leg\u00edvel.","title":"Lab de Processos"},{"location":"labs/processos/#iniciando-seu-shell","text":"O shell de ser iniciado a partir do diret\u00f3rio onde foi carregado o programa, em seguida deve ficar executando um loop como o trecho abaixo: enquanto comando diferente de exit 1 - Imprima um prompt de comando 2 - Leia o comando da entrada padr\u00e3o 3 - Executa o comando O shell suporta dois tipos de comandos: internos e externos . Os comandos internos s\u00e3o parte do c\u00f3digo do shell e s\u00e3o executados sem criar um novo processo. Os comandos externos devem ser executados por um novo processo, com a chamada das fun\u00e7\u00f5es fork/execvp/waitpid . Para identificar um comando externo , considere que se o comando n\u00e3o for um dos comandos internos listados a seguir, ele \u00e9 um comando externo . Os argumentos de comando ser\u00e3o separados por espa\u00e7os em branco, n\u00e3o se preocupe com espa\u00e7amento irregular em entradas de comando (ou seja, espa\u00e7o em branco extra antes e depois de cada token ). Isso \u00e9 considerado comportamento indefinido e n\u00e3o ser\u00e1 testado. Voc\u00ea \u00e9 livre para tornar seu c\u00f3digo t\u00e3o robusto quanto quiser, mas testaremos apenas os casos b\u00e1sicos com um espa\u00e7o entre os tokens .","title":"Iniciando seu shell"},{"location":"labs/processos/#avaliacao","text":"O inspersh ser\u00e1 avaliado de forma manual usando uma rubrica que descreve as funcionalidades implementadas. Quanto maior o n\u00famero de funcionalidades maior ser\u00e1 a nota.","title":"Avalia\u00e7\u00e3o"},{"location":"labs/processos/#fase-0","text":"O programa inspersh.c n\u00e3o compila ou compila com warnings . N\u00e3o preencheu o arquivo README.md N\u00e3o entregou o v\u00eddeo explicativo; O programa n\u00e3o implementa algum dos requisitos da rubrica da fase 1 .","title":"FASE 0"},{"location":"labs/processos/#nota-desta-fase-00","text":"","title":"NOTA desta fase: 0.0"},{"location":"labs/processos/#fase-1","text":"Video explicativo com \u00e1udio e a tela de vis\u00edvel com a execu\u00e7\u00e3o da implamenta\u00e7\u00e3o, comentando as informa\u00e7\u00f5es colocadas no arquivo README.md . Preencheu o arquivo README.md com as seguintes informa\u00e7\u00f5es: Seu nome e uma descri\u00e7\u00e3o de qual fase do laborat\u00f3rio voc\u00ea conseguiu completar; Relate tamb\u00e9m quaisquer bugs ou erros identificados no seu shell ;e Alguma decis\u00e3o de design interessante que voc\u00ea gostaria de compartilhar. O programa inspersh.c compila sem warnings . Para compilar use: gcc inspersh.c -Wall -Wno-unused-result -g -Og -o inspersh O programa printa o prompt do shell , a partir do diret\u00f3rio onde foi carregado o programa no formato (pid=<pid>)<path>$ , como por exemplo: ( pid = 1234 ) /home/lab02$ Sendo que o <pid> \u00e9 o ID do processo atual e <path> \u00e9 o caminho completo para o diret\u00f3rio de trabalho atual. O programa l\u00ea e interpreta uma linha com o comando que ser\u00e1 executado, pela entrada padr\u00e3o ( stdin ), para isso ser\u00e1 necess\u00e1rio dividir a entrada com base nos espa\u00e7os. Um token \u00e9 qualquer sequ\u1ebdncia de caracteres delimitado pelo in\u00edcio e fim da linha, ou por espa\u00e7os. O primeiro token \u00e9 considerado o comando , e todos os tokens seguintes s\u00e3o referidos como argumentos . Implmenta os comandos internos : exit : encerra o inspersh elibera todos os recursos. cd <dir> : o diretorio atual \u00e9 alterado para o diret\u00f3rio informado <dir> . Se o diret\u00f3rio informado come\u00e7ar com / o diretorio deve ser atualizado a partir da raiz do sistema de arquivo, caso contr\u00e1rio deve ser atualizado em rela\u00e7\u00e3o ao diret\u00f3rio atual. Caso o argumento <dir> n\u00e3o seja informado o shell deve regressar ao diret\u00f3rio inicial onde foi carregado o programa. Se por algum motivo <dir> n\u00e3o for um diret\u00f3rio v\u00e1lido, o inspersh dever\u00e1 manter seu diret\u00f3rio de trabalho atual e dever\u00e1 imprimir: dir: diretorio nao existe. , al\u00e9m disso n\u00e3o \u00e9 necess\u00e1rio tratar o comando cd .. , veja abaixo um trecho de execu\u00e7\u00e3o do comando cd : ( pid = 1234 ) /home/lab02$ cd testes ( pid = 1234 ) /home/lab02/testes$ cd dir_imaginario dir_imaginario: diretorio nao existe. ( pid = 1234 ) /home/lab02/testes$ cd teste2 ( pid = 1234 ) /home/lab02/testes/teste2$ cd ( pid = 1234 ) /home/lab02$ ls : lista conte\u00fado de um diret\u00f3rio (arquivos e outros diret\u00f3rios), informando se um elemento \u00e9 um diret\u00f3rio ou arquivo. Se for um arquivo deve ser impresso o tamanho do arquivo em bytes , e por fim o nome do elemento no sistema de arquivos, ignorem os arquivos e diret\u00f3rios que comecem com caractere . (ponto), este n\u00e3o deve ser listado, abaixo um exemplo da execu\u00e7\u00e3o do comando ls : ( pid = 1234 ) /home/lab02$ ls d - - um_diretorio a - 7566 - inspersh.c a - 16526 - processos.md a - 19064 - processo.html a - 332496 - inspersh d - - testes ( pid = 1234 ) /home/lab02$ N\u00e3o se preocupe aqui com a ordem em que aparecem os elementos que est\u00e3o no diret\u00f3rio, o importante \u00e9 informar corretamente as informa\u00e7oes dos elementos. Dica de implementa\u00e7\u00e3o : leia atentamente os manuais ( man ) das fun\u00e7\u00f5es a seguir, elas poder\u00e3o lhe ajudar a atender os requisitos dessa fase. getpid , getcwd , fgets , chdir , opendir , readdir , closedir e stat ( man 2 stat )-","title":"FASE 1:"},{"location":"labs/processos/#nota-ate-essa-fase-30","text":"","title":"NOTA at\u00e9 essa fase: 3.0"},{"location":"labs/processos/#fase-2","text":"Programa inspersh.c roda sem erros no valgrind . Para testar o seu program use: valgrind --leak-check=yes ./inspersh Implementa os comandos externos : se o comando n\u00e3o for um comando interno do inspersh.c (ou seja, qualquer comando diferente de cd , ls , exit ), o inspersh deve considerar o nome do comando como o nome de um arquivo execut\u00e1vel, como por exemplos os comandos: cat, top, pwd, ps, /usr/bin/ls -l, echo hello, sleep 5, lscpu, ... O c\u00f3digo desses comandos deve ser executado em um processo diferente daquele que executa o inspersh.c , para tanto voc\u00ea deve usar fork() , execvp() e waitpid() . Caso tenha sucesso na execu\u00e7\u00e3o do comando externo deve ser impressa a seguinte mensagem: (pid=<pid>):comando externo [<cmd>] executado com sucesso. , se o comando externo falhar no momento da chamada do execvp o inspersh deve enviar uma mensagem apropriadas, como por exemplo: (pid=<pid>):falha na execucao do comando externo [<cmd>] . Considere que <pid> \u00e9 o valor do pid do execut\u00e1vel e <cmd> \u00e9 o nome do comando. Veja um exemplo de execu\u00e7\u00e3o dos comandos externos: ( pid = 1234 ) /home/lab02$ sleep 5 ( pid = 4321 ) :comando externo [ sleep ] executado com sucesso. ( pid = 1234 ) /home/lab02$ SLEEP 5 ( pid = 4322 ) :falha na execu\u00e7\u00e3o do comando externo [ SLEEP ] . ( pid = 1234 ) /home/lab02$ echo Ola mundo !! Ola Mundo !! ( pid = 4327 ) :comando externo [ echo ] executado com sucesso. ( pid = 1234 ) /home/lab02$ pwd /home/lab02 ( pid = 4327 ) :comando externo [ pwd ] executado com sucesso. ( pid = 1234 ) /home/lab02$ IMPORTANTE : N\u00e3o \u00e9 permitido o uso da fun\u00e7\u00e3o system() nesse lab, caso use ser\u00e1 atribu\u00eddo a nota da FASE 0 . Programa captura Ctrl+C : geralmente quando pressionamos Ctrl+C , o programa em execu\u00e7\u00e3o no primeiro plano \u00e9 finalizado, no entanto, o inspersh.c deve verificar se h\u00e1 outro programa em primeiro plano em execu\u00e7\u00e3o no momento e, se houver, ele deve finalizar esse processo usando o sinal SIGINT , e apresentar uma mensagem apropriado como (pid=<pid>):comando externo [<cmd>] finalizado com Ctrl+C. , caso contr\u00e1rio o inspersh.c ignora o Ctrl+C . ( pid = 1234 ) /home/lab02$ sleep 5 ^C ( pid = 4323 ) :comando externo [ sleep ] finalizado com Ctrl+C. ( pid = 1234 ) /home/lab02$ + Dica de implementa\u00e7\u00e3o : para aguardar os comandos externos finalizados com Ctrl+C utilize a fun\u00e7\u00e3o waitpid() com argumento n\u00e3o bloqueante, para tanto leia atentamente o manual dessa fun\u00e7\u00e3o ( man waitpid ).","title":"FASE 2"},{"location":"labs/processos/#nota-ate-essa-fase-50","text":"","title":"NOTA at\u00e9 essa fase: 5.0"},{"location":"labs/processos/#fase-3","text":"Nessa fase o seu shell deve suportar o armazenamento do hist\u00f3rico de comandos executados, por conta disso o execut\u00e1vel inspersh dever\u00e1 ser inicializado da seguinte forma: $./inspersh <arquivo_historico> Se o arquivo n\u00e3o existir, voc\u00ea deve trat\u00e1-lo como um arquivo vazio, o formato do arquivo de hist\u00f3rico deve ser uma lista comandos executados. Ao sair, o inspersh deve anexar os comandos da sess\u00e3o atual no arquivo de hist\u00f3rico fornecido, no mesmo arquivo informado no in\u00edcio da execu\u00e7\u00e3o do shell . Exemplo do arquivo historico.txt : cd testes echo Ola Mundo! Considere o inspersh executando carregando o arquivo historico.txt : $./inspersh historico.txt ( pid = 1234 ) /home/lab02$ cd dir_imaginario dir_imaginario: diret\u00f3rio nao existe. ( pid = 1234 ) /home/lab02$ exit Exemplo como ficaria o arquivo de historico.txt ap\u00f3s a execu\u00e7\u00e3o do inspersh : cd testes echo Ola Mundo! cd dir_imaginario Note que comando tanto os comandos executados com sucesso e com falha s\u00e3o armazenados no hist\u00f3rico, e o comando exit n\u00e3o \u00e9 armazenado no arquivo de hist\u00f3rico. Implementa comandos para acessar o hist\u00f3rico do shell a partir do prompt do inspersh : ! : Imprime para cada comando (em ordem cronol\u00f3gica) seu n\u00famero de linha (indexado a partir do 0 ), uma tabula\u00e7\u00e3o, o comando em si e uma nova linha, e \u00e9 claro, o comando ! n\u00e3o \u00e9 armazenado no hist\u00f3rico. ( pid = 1234 ) /home/lab02$ ! 0 cd testes 1 echo Ola Mundo! 2 cd dir_imaginario ( pid = 1234 ) /home/lab02$ !# : Reexecuta o #\u00e9simo comando no hist\u00f3rico e armazena a nova execu\u00e7\u00e3o do comando no hist\u00f3rico, antes de executar o #\u00e9simo comando de ser impresso na tela. Se # n\u00e3o for um \u00edndice v\u00e1lido, imprima indice invalido (essa mensagem n\u00e3o deve ser armazenado no hist\u00f3rico). E por fim o comando !# n\u00e3o \u00e9 armazenado no hist\u00f3rico, o exemplo abaixo assume que o hist\u00f3rico est\u00e1 vazio : ( pid = 1234 ) /home/lab02$ echo Echo Algo! Echo Algo! ( pid = 1237 ) :comando externo [ echo ] executado com sucesso. ( pid = 1234 ) /home/lab02$ echo Outro echo Outro echo ( pid = 1239 ) :comando externo [ echo ] executado com sucesso. ( pid = 1234 ) /home/lab02$ ! 0 echo Echo Algo! 1 echo Outro echo ( pid = 1234 ) /home/lab02$ !1 echo Outro echo Outro echo ( pid = 2230 ) :comando externo [ echo ] executado com sucesso. ( pid = 1234 ) /home/lab02$ !4 indice invalido ( pid = 1234 ) /home/lab02$ ! 0 echo Echo Algo! 1 echo Outro echo 2 echo Outro echo ( pid = 1234 ) /home/lab02$ !<prefixo> : Imprime e executa o \u00faltimo comando que tem o prefixo especificado. Se nenhuma correspond\u00eancia for encontrada, imprima a mensagem de erro comando nao encontrado e n\u00e3o armazene nada no hist\u00f3rico. Caso encontre alguma correspond\u00eancia, imprima o comando antes de execut\u00e1-lo. Importante, comando !<prefixo> n\u00e3o \u00e9 armazenado no hist\u00f3rico, mas o comando que est\u00e1 sendo executado (se houver) \u00e9, o exemplo a seguir assume um hist\u00f3rico vazio : ( pid = 1234 ) /home/lab02$ echo Echo Algo! Echo Algo! ( pid = 1237 ) :comando externo [ echo ] executado com sucesso. ( pid = 1234 ) /home/lab02$ echo Outro echo Outro echo ( pid = 1239 ) :comando externo [ echo ] executado com sucesso. ( pid = 1234 ) /home/lab02$ ! 0 echo Echo Algo! 1 echo Outro echo ( pid = 1234 ) /home/lab02$ !echo echo Outro echo Outro echo ( pid = 2230 ) :comando externo [ echo ] executado com sucesso. ( pid = 1234 ) /home/lab02$ !eco comando nao encontrado ( pid = 1234 ) /home/lab02$ ! 0 echo Echo Algo! 1 echo Outro echo 2 echo Outro echo ( pid = 1234 ) /home/lab02$","title":"FASE 3"},{"location":"labs/processos/#nota-ate-essa-fase-80","text":"","title":"NOTA at\u00e9 essa fase: 8.0"},{"location":"labs/processos/#fase-4","text":"Nessa fase o comando interno ls deve ser incrementado. Considera a Figura 1 que apresenta uma de \u00e1rvore de diret\u00f3rios e arquivos de um sistema de arquivos. O seu programa inspersh.c deve implementar as seguintes funcionalidades: Figura 1 : Exemplo de \u00e1rvore de diret\u00f3rios e arquivos Implementa o argumento -o para o comando ls , o argumento indica ao comando ao comando ls que conte\u00fado do diretorio corrente deve ser impressa em ordem alfab\u00e9tica, colocando os diret\u00f3rios antes dos arquivos. Considere que o execut\u00e1vel inspersh est\u00e1 na raiz da \u00e1rvore acima, a sa\u00edda para o comando ls -o seria: ./dirA ./dirC ./temp.txt Implementa o argumento -n que percorre, a partir do diret\u00f3rio corrente, toda a \u00e1rvore de diret\u00f3rio por n\u00edvel , considere que o execut\u00e1vel inspersh est\u00e1 na raiz da \u00e1rvore apresentada na Figura 1 , a sa\u00edda para o comando ls -n seria: ./dirA ./dirC ./temp.txt ./dirA/dirB ./dirA/my1.dat ./dirC/my2.dat ./dirC/temp.txt ./dirA/dirB/my3.dat Implementa o argumento -h que faz com que o comando ls percorra toda \u00e1rvore de diret\u00f3rio a partir do diret\u00f3rio corrente explorando o primeiro diret\u00f3rio completamente antes de voltar e explorar o pr\u00f3ximo diret\u00f3rio no mesmo n\u00edvel, repetindo esse processo para cada diret\u00f3rio que ser\u00e1 percorrido. Considere que o execut\u00e1vel inspersh est\u00e1 na raiz da \u00e1rvore apresentada na Figura 1 , a sa\u00edda para o comando ls -h seria: ./dirA ./dirA/dirB ./dirA/dirB/my3.dat ./dirA/my1.dat ./dirC ./dirC/my2.dat ./dirC/temp.txt ./temp.txt","title":"FASE 4"},{"location":"labs/processos/#nota-ate-essa-fase-100","text":"IMPORTANTE: Considere as fases como cumulativas , ou seja, cada vers\u00e3o deve manter as funcionalidades da fase anterior e acrescentar novas. Por exemplo, a vers\u00e3o da Fase 2 , al\u00e9m de executar os comandos externos deve continuar os comandos internos implementado na Fase 1 , e assim por diante.","title":"NOTA at\u00e9 essa fase: 10.0"},{"location":"labs/processos/#notas-de-programacao","text":"A linha de comando do seu programa precisa manipular linhas de entrada de at\u00e9 1024 caracteres ; Um comando n\u00e3o ultrapassar\u00e1 8 tokens ; e Em diret\u00f3rio teremos no m\u00e1ximo 128 elementos (diret\u00f3rios e arquivos). Considere que o tamanho m\u00e1ximo de um <path> ser\u00e1 de 1024 caracteres.","title":"Notas de programa\u00e7\u00e3o"},{"location":"labs/processos/#restricoes","text":"Esta atividade serve como avalia\u00e7\u00e3o dos conceitos vistos na disciplina. Portanto, algumas restri\u00e7\u00f5es ser\u00e3o aplicadas ao c\u00f3digo de voc\u00eas: todo trabalho com arquivos dever\u00e1 ser feito usando as APIs POSIX vistas em aula. N\u00e3o \u00e9 permitido o uso de fun\u00e7\u00f5es da Standard I/O para manipula\u00e7\u00e3o de arquivos, como por exemplo fopen() , fdopen() , fread() , fclose() , entre outras . se voc\u00ea usar algum trecho de c\u00f3digo da documenta\u00e7\u00e3o (ou de outra fonte), coloque uma atribui\u00e7\u00e3o em um coment\u00e1rio no c\u00f3digo. Fica proibido o uso de ferramentas de gera\u00e7\u00e3o de c\u00f3digo autom\u00e1tico por IA , como por exemplo o ChatGPT . O n\u00e3o atendimento dessas restri\u00e7\u00f5es resultar\u00e3o em atribui\u00e7\u00e3o da nota zero para esse lab.","title":"Restri\u00e7\u00f5es"},{"location":"labs/processos/#entrega","text":"Voc\u00ea dever\u00e1 colocar o programa fonte inspersh.c na pasta lab/02-lab-processos em seu reposit\u00f3rio de atividades (github), na branch principal, e fazer upload (push) do arquivo fonte no seu reposit\u00f3rio , n\u00e3o precisa soltar tag. Lembre-se de se atentar ao prazo de entrega definido aqui! .","title":"Entrega"},{"location":"labs/threads/","text":"Lab de Threads \u00b6 Introdu\u00e7\u00e3o \u00b6 No Laborat\u00f3rio de Threads , iremos implementar um algoritmo de ordena\u00e7\u00e3o de grandes volumes de dados utilizando Threads para ganhar desempenho. O algoritmo, chamado Sort-Merge (ordena\u00e7\u00e3o-jun\u00e7\u00e3o), \u00e9 utilizado para ordenar dados em situa\u00e7\u00f5es nas quais n\u00e3o \u00e9 poss\u00edvel carregar todos os dados na mem\u00f3ria do computador. No caso dos algoritmos de ordena\u00e7\u00e3o tradicionais, como InsertionSort ou BubbleSort, os dados s\u00e3o carregados na mem\u00f3ria da m\u00e1quina e ordenados. O algoritmo Sort-Merge possui duas fases distintas, com cada fase consistindo em v\u00e1rios passos. Na primeira fase, chamada fase de Sort (ordena\u00e7\u00e3o), os dados s\u00e3o divididos em partes que caibam na mem\u00f3ria dispon\u00edvel, e s\u00e3o ent\u00e3o ordenados e armazenados em arquivos tempor\u00e1rios. Essa fase resulta na cria\u00e7\u00e3o de um conjunto de arquivos tempor\u00e1rios, cada um contendo partes (regi\u00f5es) do arquivo original ordenados. A Figura 1 abaixo ilustra a fase de Sort . Na segunda fase, denominada fase de Merge (jun\u00e7\u00e3o), pares de arquivos tempor\u00e1rios criados na fase anterior s\u00e3o lidos dos arquivos tempor\u00e1rios e ordenados, intercalando em ordem crescente os elementos lidos, de modo a resultar em um novo conjunto de arquivos tempor\u00e1rios ordenados. Os itens de dois arquivos da etapa anterior s\u00e3o intercalados at\u00e9 que se obtenha um arquivo com todos os dados ordenados. A Figura 2 abaixo ilustra a fase de Merge Restri\u00e7\u00f5es \u00b6 Este exerc\u00edcio serve como avalia\u00e7\u00e3o dos conceitos vistos na disciplina. Portanto, algumas restri\u00e7\u00f5es ser\u00e3o aplicadas ao c\u00f3digo de voc\u00eas: Todo trabalho com arquivos dever\u00e1 ser feito usando as APIs POSIX vistas em aula. N\u00e3o \u00e9 permitido o uso de fun\u00e7\u00f5es da Standard I/O para manipula\u00e7\u00e3o de arquivos, como por exemplo fopen() , fdopen() , fscanf() , fprintf() fread() e fclose() . Tamb\u00e9n n\u00e3o \u00e9 permitido o uso de vari\u00e1veis globais na sua solu\u00e7\u00e3o. Se voc\u00ea usar algum trecho de c\u00f3digo da documenta\u00e7\u00e3o (ou de outra fonte), coloque uma atribui\u00e7\u00e3o em um coment\u00e1rio no c\u00f3digo. Fica proibido o uso de ferramentas de gera\u00e7\u00e3o de c\u00f3digo autom\u00e1tico por IA, como por exemplo o ChatGPT. O que precisa ser feito \u00b6 Sua tarefa \u00e9 completar a implementa\u00e7\u00e3o do algoritmo Sort-Merge , est\u00e3o disponibilizados no sue reposit\u00f3rio de entregas na pasta lab/03-lab-threads o c\u00f3digo bin\u00e1rio de dois programas ( sort.o e sort-merge.o ) que auxiliar\u00e3o no desenvolvimento da sua solu\u00e7\u00e3o. O programa sort.o contem a implementa\u00e7\u00e3o da cria\u00e7\u00e3o das threads para fase de Sort , veja a seguir. #include .... void * sort(void *args); int main(int nArgs, char **argv) { int nThreads, nItens; int fdIn; if (nArgs < 4){ printf(\"USAGE:\\n\"); printf(\"./sort <qtd threads> <qtd itens> <arquivo com itens>\\n\"); return -1; } nThreads = atoi(argv[1]); nItens = atoi(argv[2]); fdIn=open(argv[3],O_RDONLY) ; if( fdIn < 0 ) { fprintf(stderr,\"./sort: Erro falha na abertura do arquivo %s \\n\", argv[3]); exit(EXIT_FAILURE); } printf(\"Serao criadas %d threads.\\n\",nThreads); pthread_t *tids = malloc(nThreads * sizeof(pthread_t)); struct sort_args *vet_sort = malloc(nThreads * sizeof(struct sort_args)); pthread_mutex_t mutex_file = PTHREAD_MUTEX_INITIALIZER; for (int i = 0; i < nThreads; i++) { vet_sort[i].idxThread = i; vet_sort[i].nThreads = nThreads; vet_sort[i].lineFiles = nItens; vet_sort[i].mutex_file = &mutex_file; vet_sort[i].fdIn = fdIn; pthread_create(&tids[i], NULL, sort, &vet_sort[i]); printf(\"Criou thread:%d fase sort\\n\", i); } printf(\"Funcao main() espera as threads sort finalizarem...\\n\"); for (int i = 0; i < nThreads; i++) { pthread_join(tids[i], NULL); close(vet_sort[i].fdOut); } close(fdIn); free(vet_sort); free(tids); printf(\"Funcao main() FASE Sort finalizando normalmente...\\n\"); return 0; } Voc\u00ea deve implementar a fun\u00e7\u00e3o void * sort(void * args) que representa a thread respons\u00e1vel em ler concorrentemente o arquivo de entrada no arquivo solucao.c , esse arquivo conter\u00e1 as solu\u00e7\u00f5es das fase de Sort e fase de Sort-Merge . Para compilar a sua solu\u00e7\u00e3o use o comando: $ gcc -g -Og -Wall sort.o solucao.c -o sort -pthread Para executar o programa e testar sua solu\u00e7\u00e3o, informe por linha de comando o n\u00famero de threads ( nThreads ) que o programa dever\u00e1 criar e o quantidade de itens ( nItens ) no arquivo que ser\u00e1 ordenado e o nome do arquivo, por exemplo: ./sort nThreads nItens arqIn ./sort 4 16 in16.txt Considere que o n\u00famero de Threads nThreads sempre ser\u00e1 maior igual a 2 e \u00e9 uma pot\u00eancia de 2, mas nem sempre a divis\u00e3o do n\u00famero de itens no arquivo nItens por nThreads ter\u00e1 resto 0. Por exemplo se nThreads=4 e nItens=19 As 3 primeiras Threads trabalharam com 4 itens e a \u00faltima com 7 itens na fase de Sort O programa sort-merge.o contem a implementa\u00e7\u00e3o completa da cria\u00e7\u00e3o das threads para fase de Sort e para fase de Merge , e ap\u00f3s resolver a fase anterior voc\u00ea pode compilar esse programa junto com a sua solu\u00e7\u00e3o no arquivo solucao.c . #include .. void * sort(void *args); void * merge(void *args); int main(int nArgs, char **argv) { int nThreads, nItens; int fdIn; int *vet_fdOut; if (nArgs < 4){ printf(\"USAGE:\\n\"); printf(\"./sort-merge <qtd threads> <qtd itens> <arquivo com itens>\\n\"); return -1; } nThreads = atoi(argv[1]); nItens = atoi(argv[2]); fdIn=open(argv[3],O_RDONLY) ; if( fdIn < 0 ) { fprintf(stderr,\"./sort-merge: Erro falha na abertura do arquivo %s \\n\", argv[3]); exit(EXIT_FAILURE); } printf(\"Serao criadas %d threads.\\n\",nThreads); pthread_t *tids = malloc(nThreads * sizeof(pthread_t)); struct sort_args *vet_sort = malloc(nThreads * sizeof(struct sort_args)); pthread_mutex_t mutex_file = PTHREAD_MUTEX_INITIALIZER; for (int i = 0; i < nThreads; i++) { vet_sort[i].idxThread = i; vet_sort[i].nThreads = nThreads; vet_sort[i].lineFiles = nItens; vet_sort[i].mutex_file = &mutex_file; vet_sort[i].fdIn = fdIn; pthread_create(&tids[i], NULL, sort, &vet_sort[i]); printf(\"Criou thread:%d fase sort\\n\", i); } printf(\"Funcao main() espera as threads sort finalizarem...\\n\"); vet_fdOut = malloc(nThreads*sizeof(int)); for (int i = 0; i < nThreads; i++) { pthread_join(tids[i], NULL); vet_fdOut[i]=vet_sort[i].fdOut; } close(fdIn); free(vet_sort); free(tids); while( nThreads > 1){ nThreads = nThreads/2; tids = malloc(nThreads * sizeof(pthread_t)); struct merge_args *vet_merge = malloc(nThreads * sizeof(struct merge_args)); for (int i = 0; i < nThreads; i++) { vet_merge[i].idxThread = i; vet_merge[i].nThreads = nThreads; vet_merge[i].fdIn1 = vet_fdOut[i*2]; vet_merge[i].fdIn2 = vet_fdOut[(i*2)+1]; pthread_create(&tids[i], NULL, merge, &vet_merge[i]); printf(\"Criou thread:%d fase merge nThread:%d \\n\", i,nThreads); } for (int i = 0; i < nThreads; i++) { pthread_join(tids[i], NULL); vet_fdOut[i]=vet_merge[i].fdOut; } free(tids); free(vet_merge); } close(vet_fdOut[0]); free(vet_fdOut); printf(\"Funcao main() FASE Sort-Merge finalizando normalmente...\\n\"); return 0; } Para compilar a sua solu\u00e7\u00e3o ( solucao.c ) com o programa sort-merge.o use o comando: $ gcc -g -Og -Wall sort-merge.o solucao.c -o sort-merge -pthread Como come\u00e7ar? \u00b6 Fa\u00e7a git pull no seu reposit\u00f3rio entregas e verifique na pasta lab se voc\u00ea recebeu os seguintes arquivos: sort.o contem o c\u00f3digo bin\u00e1rio que cria as threads na fase de Sort . sort-merge.o contem o c\u00f3digo bin\u00e1rio que cria as threads na fase de Sort e fase de Merge . sort-merge.h arquivo com a declara\u00e7\u00e3o das estrutas e as fun\u00e7\u00f5es usadas nas duas fases. in16.txt e outros arquivos de testes para voc\u00ea come\u00e7ar a implementar as suas solu\u00e7\u00f5es. solucao.c programa fonte que dever\u00e1 ser entrega com a sua implementa\u00e7\u00e3o das threads nas fases Sort e Merge . Avalia\u00e7\u00e3o \u00b6 O programa ser\u00e1 avaliado usando uma rubrica que descreve as duas fases implementadas. Aten\u00e7\u00e3o: Os testes autom\u00e1ticos ser\u00e3o nossa forma principal de avalia\u00e7\u00e3o. Entretanto, o professor poder\u00e1 utilizar processos extras de avalia\u00e7\u00e3o, como: entrevistas, revis\u00e3o manual de c\u00f3digo. IMPORTANTE : Os arquivos fontes disponilizados s\u00e3o para voc\u00eas entenderem como s\u00e3o realizadas as chamadas das threads , n\u00e3o gere novamente os arquivos sort.o e sort-merge.o . Tag lab3.0.x : fase Sort \u00b6 Na fase de Sort cada thread dever\u00e1 alocar um espa\u00e7ao na mem\u00f3ria para armazenar os itens de sua regi\u00e3o, para tanto considere as seguintes observa\u00e7\u00f5es: No arquivo de entrada cada item no arquivo de entrada ser\u00e1 uma sequ\u00eancia de caracteres (por exemplo um nome de um animal), considere que os itens ter\u00e3o no m\u00e1ximo 20 caracteres (somente letras em min\u00fasculo) e cada um deles estar\u00e1 armazenado em uma linha do arquivo finalizada por \\n , a exce\u00e7\u00e3o \u00e9 a \u00faltima linha que n\u00e3o tem \\n , al\u00e9m disso considere que podemos ter itens repetidos no arquivo. O arquivo de entrada ser\u00e1 um recurso compartilhado que precisar\u00e1 tem seu acesso controlado, a thread principal informa para as threads criadas o descritor do arquivo de entrada e cada thread filha deve acessar o arquivo em modo exclusivo. Um detalhe importante que voc\u00ea deve resolver \u00e9 como fazer com que as threads fihas fa\u00e7am a leitura correta de sua regi\u00e3o no arquivo de entrada. Ser\u00e3o criadas nThreads (Thread 0, 1, ... n), informado por linha de linha de comando, e cada thread deve ler sua regi\u00e3o no arquivo de entrada corretamente, ou seja, conforme exemplo da figura 1. Nessa fase voc\u00ea cada thread pode utilizar algoritmos tradicionais de ordena\u00e7\u00e3o (InsertionSort ou BubbleSort), para ordem ordenar sua por\u00e7\u00e3o do arquivo em mem\u00f3ria. Ao final da ordena\u00e7\u00e3o a thread deve escrever o seu resultado em um arquivo, a Thread 0 cria e escreve no arquivo 0.txt , a Thread 1 cria e escreve no arquivo 1.txt e assim por dianto. E por fim retorna para fun\u00e7\u00e3o principal ( main() ) o descritor do arquivo, que foi criado para armazenar os seus itens ordenados, no campo fdOut da estrutura struct sort_args . Importante : o arquivo criado n\u00e3o precisa ser fechado, pode deixar isso para fun\u00e7\u00e3o main() . O arquivo ordenado tem o mesmo formato do arquivo de entrada, ou seja, cada linha separada por \\n com exce\u00e7\u00e3o a \u00faltima linha que n\u00e3o tem \\n . Para entregar fase de Sort a envie para o github suas altera\u00e7\u00f5es e suba uma tag com o padr\u00e3o de nomenclatura lab3.0.x , substituindo x por qualquer n\u00famero inteiro! Ex: $ git tag -a lab3.0.0 -m \"lab3.0.0\" $ git push origin lab3.0.0 NOTA desta fase : 6.0 Tag lab3.1.x : fase Sort-Merge \u00b6 para realizar essa fase voc\u00ea dever\u00e1 ter finalizado a fase de Sort , pois esta fase tem como entrada os arquivos gerados na fase anterior (veja Figura 2). Por conta disso considere as seguintes observa\u00e7\u00f5es: As threads nessa fase ter\u00e3o como entrada os descritores de arquivos gerados na fase anterior. No programa sort-merge.o poder\u00e1 ver que os descritores de arquivos s\u00e3o passados para as threads atrav\u00e9s de uma estrutura ( struct ). Cada thread receber\u00e1 dois descritores de arquivos da fase anterior e far\u00e1 o merge (intercala\u00e7\u00e3o) dos dois arquivos e gerando um terceiro arquivo que ser\u00e1 retornado para a fun\u00e7\u00e3o principal ( main() ), que usar\u00e1 esse arquivo para pr\u00f3xima itera\u00e7\u00e3o. O nome do arquivo criado nessa fase dever\u00e1 ter o seguinte formato = quantidade de threads que est\u00e3o executanto simultanamente concatenado com o n\u00famero da thread (veja a Figura 2). Por exemplo se tiverem 2 threads executando simultaneamente a Thread 0 gerar\u00e1 o arquivo 20.txt e a Thread 1 gerar\u00e1 o arquivo 21.txt Note na fun\u00e7\u00e3o ( main() ) que a cada itera\u00e7\u00e3o o n\u00famero de threads ser\u00e1 reduzida pela metada, at\u00e9 que reste somente uma thread e assim \u00e9 finalizada o merge. Para entregar fase de Merge a envie para o github suas altera\u00e7\u00f5es e suba uma tag com o padr\u00e3o de nomenclatura lab3.1.x , substituindo x por qualquer n\u00famero inteiro! Ex: $ git tag -a lab3.1.0 -m \"lab3.1.0\" $ git push origin lab3.1.0 NOTA desta vers\u00e3o : 10.0 Prazo \u00b6 Clique Aqui","title":"Lab de Threads"},{"location":"labs/threads/#lab-de-threads","text":"","title":"Lab de Threads"},{"location":"labs/threads/#introducao","text":"No Laborat\u00f3rio de Threads , iremos implementar um algoritmo de ordena\u00e7\u00e3o de grandes volumes de dados utilizando Threads para ganhar desempenho. O algoritmo, chamado Sort-Merge (ordena\u00e7\u00e3o-jun\u00e7\u00e3o), \u00e9 utilizado para ordenar dados em situa\u00e7\u00f5es nas quais n\u00e3o \u00e9 poss\u00edvel carregar todos os dados na mem\u00f3ria do computador. No caso dos algoritmos de ordena\u00e7\u00e3o tradicionais, como InsertionSort ou BubbleSort, os dados s\u00e3o carregados na mem\u00f3ria da m\u00e1quina e ordenados. O algoritmo Sort-Merge possui duas fases distintas, com cada fase consistindo em v\u00e1rios passos. Na primeira fase, chamada fase de Sort (ordena\u00e7\u00e3o), os dados s\u00e3o divididos em partes que caibam na mem\u00f3ria dispon\u00edvel, e s\u00e3o ent\u00e3o ordenados e armazenados em arquivos tempor\u00e1rios. Essa fase resulta na cria\u00e7\u00e3o de um conjunto de arquivos tempor\u00e1rios, cada um contendo partes (regi\u00f5es) do arquivo original ordenados. A Figura 1 abaixo ilustra a fase de Sort . Na segunda fase, denominada fase de Merge (jun\u00e7\u00e3o), pares de arquivos tempor\u00e1rios criados na fase anterior s\u00e3o lidos dos arquivos tempor\u00e1rios e ordenados, intercalando em ordem crescente os elementos lidos, de modo a resultar em um novo conjunto de arquivos tempor\u00e1rios ordenados. Os itens de dois arquivos da etapa anterior s\u00e3o intercalados at\u00e9 que se obtenha um arquivo com todos os dados ordenados. A Figura 2 abaixo ilustra a fase de Merge","title":"Introdu\u00e7\u00e3o"},{"location":"labs/threads/#restricoes","text":"Este exerc\u00edcio serve como avalia\u00e7\u00e3o dos conceitos vistos na disciplina. Portanto, algumas restri\u00e7\u00f5es ser\u00e3o aplicadas ao c\u00f3digo de voc\u00eas: Todo trabalho com arquivos dever\u00e1 ser feito usando as APIs POSIX vistas em aula. N\u00e3o \u00e9 permitido o uso de fun\u00e7\u00f5es da Standard I/O para manipula\u00e7\u00e3o de arquivos, como por exemplo fopen() , fdopen() , fscanf() , fprintf() fread() e fclose() . Tamb\u00e9n n\u00e3o \u00e9 permitido o uso de vari\u00e1veis globais na sua solu\u00e7\u00e3o. Se voc\u00ea usar algum trecho de c\u00f3digo da documenta\u00e7\u00e3o (ou de outra fonte), coloque uma atribui\u00e7\u00e3o em um coment\u00e1rio no c\u00f3digo. Fica proibido o uso de ferramentas de gera\u00e7\u00e3o de c\u00f3digo autom\u00e1tico por IA, como por exemplo o ChatGPT.","title":"Restri\u00e7\u00f5es"},{"location":"labs/threads/#o-que-precisa-ser-feito","text":"Sua tarefa \u00e9 completar a implementa\u00e7\u00e3o do algoritmo Sort-Merge , est\u00e3o disponibilizados no sue reposit\u00f3rio de entregas na pasta lab/03-lab-threads o c\u00f3digo bin\u00e1rio de dois programas ( sort.o e sort-merge.o ) que auxiliar\u00e3o no desenvolvimento da sua solu\u00e7\u00e3o. O programa sort.o contem a implementa\u00e7\u00e3o da cria\u00e7\u00e3o das threads para fase de Sort , veja a seguir. #include .... void * sort(void *args); int main(int nArgs, char **argv) { int nThreads, nItens; int fdIn; if (nArgs < 4){ printf(\"USAGE:\\n\"); printf(\"./sort <qtd threads> <qtd itens> <arquivo com itens>\\n\"); return -1; } nThreads = atoi(argv[1]); nItens = atoi(argv[2]); fdIn=open(argv[3],O_RDONLY) ; if( fdIn < 0 ) { fprintf(stderr,\"./sort: Erro falha na abertura do arquivo %s \\n\", argv[3]); exit(EXIT_FAILURE); } printf(\"Serao criadas %d threads.\\n\",nThreads); pthread_t *tids = malloc(nThreads * sizeof(pthread_t)); struct sort_args *vet_sort = malloc(nThreads * sizeof(struct sort_args)); pthread_mutex_t mutex_file = PTHREAD_MUTEX_INITIALIZER; for (int i = 0; i < nThreads; i++) { vet_sort[i].idxThread = i; vet_sort[i].nThreads = nThreads; vet_sort[i].lineFiles = nItens; vet_sort[i].mutex_file = &mutex_file; vet_sort[i].fdIn = fdIn; pthread_create(&tids[i], NULL, sort, &vet_sort[i]); printf(\"Criou thread:%d fase sort\\n\", i); } printf(\"Funcao main() espera as threads sort finalizarem...\\n\"); for (int i = 0; i < nThreads; i++) { pthread_join(tids[i], NULL); close(vet_sort[i].fdOut); } close(fdIn); free(vet_sort); free(tids); printf(\"Funcao main() FASE Sort finalizando normalmente...\\n\"); return 0; } Voc\u00ea deve implementar a fun\u00e7\u00e3o void * sort(void * args) que representa a thread respons\u00e1vel em ler concorrentemente o arquivo de entrada no arquivo solucao.c , esse arquivo conter\u00e1 as solu\u00e7\u00f5es das fase de Sort e fase de Sort-Merge . Para compilar a sua solu\u00e7\u00e3o use o comando: $ gcc -g -Og -Wall sort.o solucao.c -o sort -pthread Para executar o programa e testar sua solu\u00e7\u00e3o, informe por linha de comando o n\u00famero de threads ( nThreads ) que o programa dever\u00e1 criar e o quantidade de itens ( nItens ) no arquivo que ser\u00e1 ordenado e o nome do arquivo, por exemplo: ./sort nThreads nItens arqIn ./sort 4 16 in16.txt Considere que o n\u00famero de Threads nThreads sempre ser\u00e1 maior igual a 2 e \u00e9 uma pot\u00eancia de 2, mas nem sempre a divis\u00e3o do n\u00famero de itens no arquivo nItens por nThreads ter\u00e1 resto 0. Por exemplo se nThreads=4 e nItens=19 As 3 primeiras Threads trabalharam com 4 itens e a \u00faltima com 7 itens na fase de Sort O programa sort-merge.o contem a implementa\u00e7\u00e3o completa da cria\u00e7\u00e3o das threads para fase de Sort e para fase de Merge , e ap\u00f3s resolver a fase anterior voc\u00ea pode compilar esse programa junto com a sua solu\u00e7\u00e3o no arquivo solucao.c . #include .. void * sort(void *args); void * merge(void *args); int main(int nArgs, char **argv) { int nThreads, nItens; int fdIn; int *vet_fdOut; if (nArgs < 4){ printf(\"USAGE:\\n\"); printf(\"./sort-merge <qtd threads> <qtd itens> <arquivo com itens>\\n\"); return -1; } nThreads = atoi(argv[1]); nItens = atoi(argv[2]); fdIn=open(argv[3],O_RDONLY) ; if( fdIn < 0 ) { fprintf(stderr,\"./sort-merge: Erro falha na abertura do arquivo %s \\n\", argv[3]); exit(EXIT_FAILURE); } printf(\"Serao criadas %d threads.\\n\",nThreads); pthread_t *tids = malloc(nThreads * sizeof(pthread_t)); struct sort_args *vet_sort = malloc(nThreads * sizeof(struct sort_args)); pthread_mutex_t mutex_file = PTHREAD_MUTEX_INITIALIZER; for (int i = 0; i < nThreads; i++) { vet_sort[i].idxThread = i; vet_sort[i].nThreads = nThreads; vet_sort[i].lineFiles = nItens; vet_sort[i].mutex_file = &mutex_file; vet_sort[i].fdIn = fdIn; pthread_create(&tids[i], NULL, sort, &vet_sort[i]); printf(\"Criou thread:%d fase sort\\n\", i); } printf(\"Funcao main() espera as threads sort finalizarem...\\n\"); vet_fdOut = malloc(nThreads*sizeof(int)); for (int i = 0; i < nThreads; i++) { pthread_join(tids[i], NULL); vet_fdOut[i]=vet_sort[i].fdOut; } close(fdIn); free(vet_sort); free(tids); while( nThreads > 1){ nThreads = nThreads/2; tids = malloc(nThreads * sizeof(pthread_t)); struct merge_args *vet_merge = malloc(nThreads * sizeof(struct merge_args)); for (int i = 0; i < nThreads; i++) { vet_merge[i].idxThread = i; vet_merge[i].nThreads = nThreads; vet_merge[i].fdIn1 = vet_fdOut[i*2]; vet_merge[i].fdIn2 = vet_fdOut[(i*2)+1]; pthread_create(&tids[i], NULL, merge, &vet_merge[i]); printf(\"Criou thread:%d fase merge nThread:%d \\n\", i,nThreads); } for (int i = 0; i < nThreads; i++) { pthread_join(tids[i], NULL); vet_fdOut[i]=vet_merge[i].fdOut; } free(tids); free(vet_merge); } close(vet_fdOut[0]); free(vet_fdOut); printf(\"Funcao main() FASE Sort-Merge finalizando normalmente...\\n\"); return 0; } Para compilar a sua solu\u00e7\u00e3o ( solucao.c ) com o programa sort-merge.o use o comando: $ gcc -g -Og -Wall sort-merge.o solucao.c -o sort-merge -pthread","title":"O que precisa ser feito"},{"location":"labs/threads/#como-comecar","text":"Fa\u00e7a git pull no seu reposit\u00f3rio entregas e verifique na pasta lab se voc\u00ea recebeu os seguintes arquivos: sort.o contem o c\u00f3digo bin\u00e1rio que cria as threads na fase de Sort . sort-merge.o contem o c\u00f3digo bin\u00e1rio que cria as threads na fase de Sort e fase de Merge . sort-merge.h arquivo com a declara\u00e7\u00e3o das estrutas e as fun\u00e7\u00f5es usadas nas duas fases. in16.txt e outros arquivos de testes para voc\u00ea come\u00e7ar a implementar as suas solu\u00e7\u00f5es. solucao.c programa fonte que dever\u00e1 ser entrega com a sua implementa\u00e7\u00e3o das threads nas fases Sort e Merge .","title":"Como come\u00e7ar?"},{"location":"labs/threads/#avaliacao","text":"O programa ser\u00e1 avaliado usando uma rubrica que descreve as duas fases implementadas. Aten\u00e7\u00e3o: Os testes autom\u00e1ticos ser\u00e3o nossa forma principal de avalia\u00e7\u00e3o. Entretanto, o professor poder\u00e1 utilizar processos extras de avalia\u00e7\u00e3o, como: entrevistas, revis\u00e3o manual de c\u00f3digo. IMPORTANTE : Os arquivos fontes disponilizados s\u00e3o para voc\u00eas entenderem como s\u00e3o realizadas as chamadas das threads , n\u00e3o gere novamente os arquivos sort.o e sort-merge.o .","title":"Avalia\u00e7\u00e3o"},{"location":"labs/threads/#tag-lab30x-fase-sort","text":"Na fase de Sort cada thread dever\u00e1 alocar um espa\u00e7ao na mem\u00f3ria para armazenar os itens de sua regi\u00e3o, para tanto considere as seguintes observa\u00e7\u00f5es: No arquivo de entrada cada item no arquivo de entrada ser\u00e1 uma sequ\u00eancia de caracteres (por exemplo um nome de um animal), considere que os itens ter\u00e3o no m\u00e1ximo 20 caracteres (somente letras em min\u00fasculo) e cada um deles estar\u00e1 armazenado em uma linha do arquivo finalizada por \\n , a exce\u00e7\u00e3o \u00e9 a \u00faltima linha que n\u00e3o tem \\n , al\u00e9m disso considere que podemos ter itens repetidos no arquivo. O arquivo de entrada ser\u00e1 um recurso compartilhado que precisar\u00e1 tem seu acesso controlado, a thread principal informa para as threads criadas o descritor do arquivo de entrada e cada thread filha deve acessar o arquivo em modo exclusivo. Um detalhe importante que voc\u00ea deve resolver \u00e9 como fazer com que as threads fihas fa\u00e7am a leitura correta de sua regi\u00e3o no arquivo de entrada. Ser\u00e3o criadas nThreads (Thread 0, 1, ... n), informado por linha de linha de comando, e cada thread deve ler sua regi\u00e3o no arquivo de entrada corretamente, ou seja, conforme exemplo da figura 1. Nessa fase voc\u00ea cada thread pode utilizar algoritmos tradicionais de ordena\u00e7\u00e3o (InsertionSort ou BubbleSort), para ordem ordenar sua por\u00e7\u00e3o do arquivo em mem\u00f3ria. Ao final da ordena\u00e7\u00e3o a thread deve escrever o seu resultado em um arquivo, a Thread 0 cria e escreve no arquivo 0.txt , a Thread 1 cria e escreve no arquivo 1.txt e assim por dianto. E por fim retorna para fun\u00e7\u00e3o principal ( main() ) o descritor do arquivo, que foi criado para armazenar os seus itens ordenados, no campo fdOut da estrutura struct sort_args . Importante : o arquivo criado n\u00e3o precisa ser fechado, pode deixar isso para fun\u00e7\u00e3o main() . O arquivo ordenado tem o mesmo formato do arquivo de entrada, ou seja, cada linha separada por \\n com exce\u00e7\u00e3o a \u00faltima linha que n\u00e3o tem \\n . Para entregar fase de Sort a envie para o github suas altera\u00e7\u00f5es e suba uma tag com o padr\u00e3o de nomenclatura lab3.0.x , substituindo x por qualquer n\u00famero inteiro! Ex: $ git tag -a lab3.0.0 -m \"lab3.0.0\" $ git push origin lab3.0.0 NOTA desta fase : 6.0","title":"Tag lab3.0.x: fase Sort"},{"location":"labs/threads/#tag-lab31x-fase-sort-merge","text":"para realizar essa fase voc\u00ea dever\u00e1 ter finalizado a fase de Sort , pois esta fase tem como entrada os arquivos gerados na fase anterior (veja Figura 2). Por conta disso considere as seguintes observa\u00e7\u00f5es: As threads nessa fase ter\u00e3o como entrada os descritores de arquivos gerados na fase anterior. No programa sort-merge.o poder\u00e1 ver que os descritores de arquivos s\u00e3o passados para as threads atrav\u00e9s de uma estrutura ( struct ). Cada thread receber\u00e1 dois descritores de arquivos da fase anterior e far\u00e1 o merge (intercala\u00e7\u00e3o) dos dois arquivos e gerando um terceiro arquivo que ser\u00e1 retornado para a fun\u00e7\u00e3o principal ( main() ), que usar\u00e1 esse arquivo para pr\u00f3xima itera\u00e7\u00e3o. O nome do arquivo criado nessa fase dever\u00e1 ter o seguinte formato = quantidade de threads que est\u00e3o executanto simultanamente concatenado com o n\u00famero da thread (veja a Figura 2). Por exemplo se tiverem 2 threads executando simultaneamente a Thread 0 gerar\u00e1 o arquivo 20.txt e a Thread 1 gerar\u00e1 o arquivo 21.txt Note na fun\u00e7\u00e3o ( main() ) que a cada itera\u00e7\u00e3o o n\u00famero de threads ser\u00e1 reduzida pela metada, at\u00e9 que reste somente uma thread e assim \u00e9 finalizada o merge. Para entregar fase de Merge a envie para o github suas altera\u00e7\u00f5es e suba uma tag com o padr\u00e3o de nomenclatura lab3.1.x , substituindo x por qualquer n\u00famero inteiro! Ex: $ git tag -a lab3.1.0 -m \"lab3.1.0\" $ git push origin lab3.1.0 NOTA desta vers\u00e3o : 10.0","title":"Tag lab3.1.x: fase Sort-Merge"},{"location":"labs/threads/#prazo","text":"Clique Aqui","title":"Prazo"},{"location":"outros/DicasLinks/","text":"Dicas e links \u00b6 Refer\u00eancia para as instru\u00e7\u00f5es do Assembly x86 e amd64 \u00b6 Este guia de refer\u00eancia https://www.felixcloutier.com/x86/ sobre as intru\u00e7\u00f5es da linguagem Assembly \u00e9 um resumo da refer\u00eancia oficial da Intel . Acredito que para nossos propositos na disciplina de SisHard seja suficiente. GDB - refer\u00eancia completa \u00b6 O GNU Debugger, mais conhecido por GDB, \u00e9 um depurador do GNU. Ele pode ser usado para depura\u00e7\u00e3o em sistemas Unix-like, como por exemplo o Ubuntu 22.04, na nossa disciplina usaremos o GDB para entender os c\u00f3digos em assemblye de atividades e do Lab01 Para aprender como depurar c\u00f3digo com GDB acesse este link https://diveintosystems.org/book/C3-C_debug/gdb.html e nesse link https://diveintosystems.org/book/C3-C_debug/gdb_commands.html voc\u00ea poder\u00e1 conhecer o os principais comandos do gdb. Nesse link [ https://sourceware.org/gdb/current/onlinedocs/gdb ] ( https://sourceware.org/gdb/current/onlinedocs/gdb ) voc\u00ea ter\u00e1 a documenta\u00e7\u00e3o completa do GDB. Aqui https://sourceware.org/gdb/current/onlinedocs/gdb.html/Memory.html tem as explica\u00e7\u00f5es do comando x ( x/nfu addr ) que permite examinar a mem\u00f3ria de um programa Assembly. Compiler Explorer - godbolt.org \u00b6 Compiler Explorer, tamb\u00e9m chamado de godbolt.org, \u00e9 um site interativo de explora\u00e7\u00e3o de compiladores. Ele permite ao usu\u00e1rio inserir c\u00f3digo em uma das linguagens C e visualizar a tradu\u00e7\u00e3o do c\u00f3digo para Assembly. Para utiliz\u00e1-lo acesse o LINK , a configua\u00e7\u00e3o do godbolt est\u00e1 nos slides da aula 04 - Fun\u00e7\u00f5es-mov . Resumo SisHard da Universidade Stanford \u00b6 No link abaixo est\u00e1 uma vis\u00e3o geral dos assuntos abordados na primeira parte da disciplina de Sistemas Hardware-Software elaborado na Universidade de Stanford. acesse o LINK Dicas ponteiros e aloca\u00e7\u00e3o de mem\u00f3ria na Linguagem C \u00b6 Alguns links que podem ajuda-los a entender ponteiros e aloca\u00e7\u00e3o de mem\u00f3ria na Linguagem C. Os links abaixo s\u00e3o do material desenvolvido pelo professor Paulo Feofiloff: Endere\u00e7os e ponteiros Aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria Os links abaixo s\u00e3o do material desenvolvido pelo professor Carlos Maziero: Ponteiros Aloca\u00e7\u00e3o de mem\u00f3ria Aloca\u00e7\u00e3o din\u00e2mica de matrizes","title":"Dicas e links"},{"location":"outros/DicasLinks/#dicas-e-links","text":"","title":"Dicas e links"},{"location":"outros/DicasLinks/#referencia-para-as-instrucoes-do-assembly-x86-e-amd64","text":"Este guia de refer\u00eancia https://www.felixcloutier.com/x86/ sobre as intru\u00e7\u00f5es da linguagem Assembly \u00e9 um resumo da refer\u00eancia oficial da Intel . Acredito que para nossos propositos na disciplina de SisHard seja suficiente.","title":"Refer\u00eancia para as instru\u00e7\u00f5es do Assembly x86 e amd64"},{"location":"outros/DicasLinks/#gdb-referencia-completa","text":"O GNU Debugger, mais conhecido por GDB, \u00e9 um depurador do GNU. Ele pode ser usado para depura\u00e7\u00e3o em sistemas Unix-like, como por exemplo o Ubuntu 22.04, na nossa disciplina usaremos o GDB para entender os c\u00f3digos em assemblye de atividades e do Lab01 Para aprender como depurar c\u00f3digo com GDB acesse este link https://diveintosystems.org/book/C3-C_debug/gdb.html e nesse link https://diveintosystems.org/book/C3-C_debug/gdb_commands.html voc\u00ea poder\u00e1 conhecer o os principais comandos do gdb. Nesse link [ https://sourceware.org/gdb/current/onlinedocs/gdb ] ( https://sourceware.org/gdb/current/onlinedocs/gdb ) voc\u00ea ter\u00e1 a documenta\u00e7\u00e3o completa do GDB. Aqui https://sourceware.org/gdb/current/onlinedocs/gdb.html/Memory.html tem as explica\u00e7\u00f5es do comando x ( x/nfu addr ) que permite examinar a mem\u00f3ria de um programa Assembly.","title":"GDB - refer\u00eancia completa"},{"location":"outros/DicasLinks/#compiler-explorer-godboltorg","text":"Compiler Explorer, tamb\u00e9m chamado de godbolt.org, \u00e9 um site interativo de explora\u00e7\u00e3o de compiladores. Ele permite ao usu\u00e1rio inserir c\u00f3digo em uma das linguagens C e visualizar a tradu\u00e7\u00e3o do c\u00f3digo para Assembly. Para utiliz\u00e1-lo acesse o LINK , a configua\u00e7\u00e3o do godbolt est\u00e1 nos slides da aula 04 - Fun\u00e7\u00f5es-mov .","title":"Compiler Explorer - godbolt.org"},{"location":"outros/DicasLinks/#resumo-sishard-da-universidade-stanford","text":"No link abaixo est\u00e1 uma vis\u00e3o geral dos assuntos abordados na primeira parte da disciplina de Sistemas Hardware-Software elaborado na Universidade de Stanford. acesse o LINK","title":"Resumo SisHard da Universidade Stanford"},{"location":"outros/DicasLinks/#dicas-ponteiros-e-alocacao-de-memoria-na-linguagem-c","text":"Alguns links que podem ajuda-los a entender ponteiros e aloca\u00e7\u00e3o de mem\u00f3ria na Linguagem C. Os links abaixo s\u00e3o do material desenvolvido pelo professor Paulo Feofiloff: Endere\u00e7os e ponteiros Aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria Os links abaixo s\u00e3o do material desenvolvido pelo professor Carlos Maziero: Ponteiros Aloca\u00e7\u00e3o de mem\u00f3ria Aloca\u00e7\u00e3o din\u00e2mica de matrizes","title":"Dicas ponteiros e aloca\u00e7\u00e3o de mem\u00f3ria na Linguagem C"},{"location":"outros/github/","text":"Github Password \u00b6 Caso o seu Github esteja solicitando senha a cada push, voc\u00ea tem duas op\u00e7\u00f5es para configurar um esquema de login autom\u00e1tico: chave ssh ou token . Chave SSH \u00b6 Se voc\u00ea costuma clonar os reposit\u00f3rios utilizando ssh , acesse este LINK e veja como criar uma chave no Ubuntu e adicionar no Github. Ap\u00f3s esta configura\u00e7\u00e3o, acessos utilizando esta chave ser\u00e3o automaticamente reconhecidos e aceitos como do seu usu\u00e1rio. Arquivo .netrc \u00b6 Se voc\u00ea costuma clonar os reposit\u00f3rios utilizando https , acesse este LINK e crie um Token . Na cria\u00e7\u00e3o do Token, selecione uma validade adequada (pelo menos 90 dias) e marque em Select scopes pelo menos a se\u00e7\u00e3o repo . Em seguida, crie um arquivo .netrc (sim, come\u00e7a com \"ponto\") na raiz do seu usu\u00e1rio no Ubuntu. O conte\u00fado deste arquivo deve estar no padr\u00e3o: machine github.com login bruna2022 password ghp_123412341234123412341234123412341234 Example Substitua bruna2022 pelo seu usu\u00e1rio do Github e ghp_1234* pelo Token criado. No terminal, configure as permiss\u00f5es adequadas para o arquivo: $ chmod 600 ~/.netrc E feito! Clique aqui para mais informa\u00e7\u00f5es","title":"Github Password"},{"location":"outros/github/#github-password","text":"Caso o seu Github esteja solicitando senha a cada push, voc\u00ea tem duas op\u00e7\u00f5es para configurar um esquema de login autom\u00e1tico: chave ssh ou token .","title":"Github Password"},{"location":"outros/github/#chave-ssh","text":"Se voc\u00ea costuma clonar os reposit\u00f3rios utilizando ssh , acesse este LINK e veja como criar uma chave no Ubuntu e adicionar no Github. Ap\u00f3s esta configura\u00e7\u00e3o, acessos utilizando esta chave ser\u00e3o automaticamente reconhecidos e aceitos como do seu usu\u00e1rio.","title":"Chave SSH"},{"location":"outros/github/#arquivo-netrc","text":"Se voc\u00ea costuma clonar os reposit\u00f3rios utilizando https , acesse este LINK e crie um Token . Na cria\u00e7\u00e3o do Token, selecione uma validade adequada (pelo menos 90 dias) e marque em Select scopes pelo menos a se\u00e7\u00e3o repo . Em seguida, crie um arquivo .netrc (sim, come\u00e7a com \"ponto\") na raiz do seu usu\u00e1rio no Ubuntu. O conte\u00fado deste arquivo deve estar no padr\u00e3o: machine github.com login bruna2022 password ghp_123412341234123412341234123412341234 Example Substitua bruna2022 pelo seu usu\u00e1rio do Github e ghp_1234* pelo Token criado. No terminal, configure as permiss\u00f5es adequadas para o arquivo: $ chmod 600 ~/.netrc E feito! Clique aqui para mais informa\u00e7\u00f5es","title":"Arquivo .netrc"},{"location":"outros/vbox/","text":"Virtualbox \u00b6 Shared Folder \u00b6 Uma boa maneira de transferir arquivos entre a VM e a m\u00e1quina hospedeira (ambas as dire\u00e7\u00f5es) \u00e9 criar uma pasta compartilhada no Virtualbox. Acesse este LINK para mais informa\u00e7\u00f5es! Shared Clipboard \u00b6 Tamb\u00e9m \u00e9 poss\u00edvel fazer com que algo copiado (CTRL + C) no sistema principal possa ser colado no Ubuntu (CTRL + V na m\u00e1quina Virtual), e vice-versa! Procure no Google virtualbox enable shared clipboard .","title":"Virtualbox"},{"location":"outros/vbox/#virtualbox","text":"","title":"Virtualbox"},{"location":"outros/vbox/#shared-folder","text":"Uma boa maneira de transferir arquivos entre a VM e a m\u00e1quina hospedeira (ambas as dire\u00e7\u00f5es) \u00e9 criar uma pasta compartilhada no Virtualbox. Acesse este LINK para mais informa\u00e7\u00f5es!","title":"Shared Folder"},{"location":"outros/vbox/#shared-clipboard","text":"Tamb\u00e9m \u00e9 poss\u00edvel fazer com que algo copiado (CTRL + C) no sistema principal possa ser colado no Ubuntu (CTRL + V na m\u00e1quina Virtual), e vice-versa! Procure no Google virtualbox enable shared clipboard .","title":"Shared Clipboard"}]}